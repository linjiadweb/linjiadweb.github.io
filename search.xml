<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>导论1</title>
    <url>/2020/06/25/01%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/01%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/00%E5%AF%BC%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="为什么学习数据结构与算法"><a href="#为什么学习数据结构与算法" class="headerlink" title="为什么学习数据结构与算法"></a>为什么学习数据结构与算法</h1><ul>
<li>似乎我们在学习编程中，没有必要了解这些，我们只是在学习一门语言基本语法/高级语法/做出界面效果/实现复杂逻辑就可以了</li>
<li>如果我们只是想了解语言的应用层面，那么数据结构和算法显得就没那么重要了</li>
<li>如果我们想了解语言的设计层面，那么数据结构和算法显得尤为重要了</li>
<li>比如JAVA中有ArrayList以及LinkList，如何选则？<ul>
<li>ArrayList利用下标值去做一些操作效率快</li>
<li>LinkList双向链表结构，在中间插入数据效率更快</li>
</ul>
</li>
</ul>
<h1 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h1><blockquote>
<p>数据结构就是在计算机中存储和组织数据的方式</p>
</blockquote>
<ul>
<li>我们知道计算机中存储了大量的数据，如何以更高效的方式来存储这些数据？</li>
<li>好比一个庞大的图书馆中存放了大量的书籍，我们不仅仅是把书放进去，我们还要考虑如何快速的把书取出来</li>
</ul>
<h2 id="图书摆放"><a href="#图书摆放" class="headerlink" title="图书摆放"></a>图书摆放</h2><ul>
<li>图书的摆放要使得两个操作方便实现<ul>
<li>新书如何插入</li>
<li>如何找到指定的书</li>
</ul>
</li>
<li>方法一：随便放<ul>
<li>新书插入简单，哪里有空插哪里，一步到位</li>
<li>找某书时，累死…</li>
</ul>
</li>
<li>方法二：按书名的拼音字母摆放<ul>
<li>新书插入时按字母顺序找到位置插入</li>
<li>找某书时，里用二分法进行查找</li>
</ul>
</li>
<li>方法三：把书架划分成几个区域，按类别存放，类别中按字母顺序<ul>
<li>新书插入时先定类别，二分查找确定位置，插入</li>
<li>找某书时，先定类别，二分查找</li>
</ul>
</li>
</ul>
<h1 id="什么是算法"><a href="#什么是算法" class="headerlink" title="什么是算法"></a>什么是算法</h1><blockquote>
<p>在解决问题的过程中，不仅仅数据的存储方式会影响效率，算法的优劣也会影响效率</p>
</blockquote>
<p><img src="./01.png" alt="数据结构预算法目录"></p>
]]></content>
  </entry>
  <entry>
    <title>导言</title>
    <url>/2020/09/08/02web/GraphQL/01%E5%AF%BC%E8%A8%80/</url>
    <content><![CDATA[<h1 id="GraphQl-介绍"><a href="#GraphQl-介绍" class="headerlink" title="GraphQl 介绍"></a>GraphQl 介绍</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>GraphQL 是一种新的 API 的查询语言， 它提供了一种更高效、 强大和灵活 API 查询。 它是由 Facebook 开发和开源， 目前由来自世界各地的大公司和个人维护。GraphQL 对你的 API<br>中的数据提供了一套易于理解的完整描述， 使得客户端能够准确地获得它需要的数据， 而且没有任何冗余。 它弥补了 RESTful API（字段冗余， 扩展性差、 无法聚合 api、 无法定义数据类型、 网络请求次数多） 等不足。<br>注意： GraphQL 是 api 的查询语言， 而不是数据库。 从这个意义上说， 它是数据库无关的，<br>而且可以在使用 API 的任何环境中有效使用， 我们可以理解为 GraphQL 是基于 API 之上的一层封装， 目的是为了更好， 更灵活的适用于业务的需求变化</p>
<h2 id="GraphQL用处"><a href="#GraphQL用处" class="headerlink" title="GraphQL用处"></a>GraphQL用处</h2><ul>
<li>可以用在常见各种服务器端语言以及客户端语言中。<ul>
<li>服务器端语言： C# / .NET、 Clojure、 Elixir、 Erlang、 Go、 Groovy、 Java、 JavaScript、 PHP、 Python、Scala、 Ruby</li>
</ul>
</li>
<li>客户端语言： js、 React + React Native、 Angular、 Vue.js、 Apollo Link、 Native iOS、 Native Android、<ul>
<li>Scala.js</li>
</ul>
</li>
<li>中文文档： <a href="http://graphql.cn" target="_blank" rel="noopener">http://graphql.cn</a></li>
</ul>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><ul>
<li>RESTful API 不足<ul>
<li>1、扩展性（多个终端需要返回不同的字段），单个 RESTful 接口返回数据越来越臃肿。前端对于真正用到的字段是没有直观映像的，仅仅通过 url 地址，无法预测也无法回忆返回的字段数目和字段是否有效，接口返回 50 个字段，但却只用 5 个字段，造成字段冗余，扩展性差，单个 RESTful 接口返回数据越来越臃肿。</li>
<li>2、API 聚合问题，某个前端展现，实际需要调用多个独立的 RESTful API 才能获取到足够的数据，导致网络请求次数多</li>
<li>3、前后端字段频繁改动，导致类型不一致，错误的数据类型可能会导致网站出错尤其是在业务多变的场景中，很难在保证工程质量的同时快速满足业务需求</li>
</ul>
</li>
<li>GraphQL 的优点<ul>
<li>1、吸收了 RESTful API 的特性。</li>
<li>2、所见即所得各种不同的前端框架和平台可以指定自己需要的字段。查询的返回结果就是输入的查询结构的精确映射</li>
<li>3、客户端可以自定义 Api 聚合。如果设计的数据结构是从属的，直接就能在查询语句中指定;即使数据结构是独立的，也可以在查询语句中指定上下文，只需要一次网络请求，就能获得资源和子资源的数据。</li>
<li>4、代码即是文档GraphQL 会把 schema 定义和相关的注释生成可视化的文档，从而使得代码的变更，直接就反映到最新的文档上，避免 RESTful 中手工维护可能会造成代码、文档不一致的问题。</li>
<li>5、参数类型强校验RESTful 方案本身没有对参数的类型做规定，往往都需要自行实现参数的校验机制，以确保安全。但 GraphQL 提供了强类型的 schema 机制，从而天然确保了参数类型的合法性</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>栈</title>
    <url>/2020/06/25/01%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/01%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/01%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/02%E6%A0%88/</url>
    <content><![CDATA[<h1 id="认识栈结构"><a href="#认识栈结构" class="headerlink" title="认识栈结构"></a>认识栈结构</h1><blockquote>
<p>栈也是一种非常常见的数据结构, 并且在程序中的应用非常广泛.</p>
</blockquote>
<h2 id="栈结构"><a href="#栈结构" class="headerlink" title="栈结构"></a>栈结构</h2><ul>
<li><p>数组</p>
<ul>
<li>我们知道数组是一种线性结构, 并且可以在数组的任意位置插入和删除数据.</li>
<li>但是有时候, 我们为了实现某些功能, 必须对这种任意性加以限制.</li>
<li>而栈和队列就是比较常见的受限的线性结构</li>
</ul>
</li>
<li><p>栈结构示意图<br><img src="./01.png" alt="栈结构示意图"></p>
</li>
<li><p>特点</p>
<ul>
<li>受限的线性表，后进先出</li>
<li>只能在前端进行删除和插入</li>
</ul>
</li>
<li><p>举例</p>
<ul>
<li>自助餐盘最先放上去的最后被拿走</li>
<li>阅读邮件，邮箱底部的是最早被放入邮箱的但是最后被阅读的</li>
<li>方法函数栈：A方法调用B，B调用C，肯定是C先执行完再执行B最后执行A</li>
</ul>
</li>
<li><p>栈面试题<br><img src="./02.png" alt="栈面试题"></p>
<ul>
<li>题目答案: C<ul>
<li>A答案: 65进栈, 5出栈, 4进栈出栈, 3进栈出栈, 6出栈, 21进栈,1出栈, 2出栈</li>
<li>B答案: 654进栈, 4出栈, 5出栈, 3进栈出栈, 2进栈出栈, 1进栈出栈, 6出栈</li>
<li>D答案: 65432进栈, 2出栈, 3出栈, 4出栈, 1进栈出栈, 5出栈, 6出栈</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h1><h2 id="封装栈类"><a href="#封装栈类" class="headerlink" title="封装栈类"></a>封装栈类</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 栈类</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 栈中的属性</span></span><br><span class="line">        <span class="keyword">var</span> items = []</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 栈相关的方法</span></span><br><span class="line">        <span class="comment">// 压栈操作（入栈）</span></span><br><span class="line">        <span class="keyword">this</span>.push = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">            items.push(element)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 出栈操作</span></span><br><span class="line">        <span class="keyword">this</span>.pop = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> items.pop()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// peek操作（查看栈顶元素）</span></span><br><span class="line">        <span class="keyword">this</span>.peek = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> items[items.length - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断栈中的元素是否为空</span></span><br><span class="line">        <span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> items.length == <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取栈中元素的个数</span></span><br><span class="line">        <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> items.length</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// toString方法</span></span><br><span class="line">        <span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; items.length;i++)&#123;</span><br><span class="line">                result += items[i] + <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="模拟面试题"><a href="#模拟面试题" class="headerlink" title="模拟面试题"></a>模拟面试题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stack = <span class="keyword">new</span> Stack()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况下代码模拟</span></span><br><span class="line">stack.push(<span class="number">6</span>)</span><br><span class="line">stack.push(<span class="number">5</span>)</span><br><span class="line">stack.pop()     <span class="comment">// 5</span></span><br><span class="line">stack.push(<span class="number">4</span>)</span><br><span class="line">stack.pop()     <span class="comment">// 4</span></span><br><span class="line">stack.push(<span class="number">3</span>)</span><br><span class="line">stack.pop()     <span class="comment">// 3</span></span><br><span class="line">stack.pop()     <span class="comment">// 6</span></span><br><span class="line">stack.push(<span class="number">2</span>)</span><br><span class="line">stack.push(<span class="number">1</span>)</span><br><span class="line">stack.pop()     <span class="comment">// 1</span></span><br><span class="line">stack.pop()     <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h1 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h1><p>将100转换为二进制</p>
<h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><blockquote>
<p>计算100/2整数50余数0<br>  计算50/2整数25余数0<br>  计算25/2整数12余数1<br>  计算12/2整数6余数0<br>  计算6/2整数3余数0<br>  计算3/2整数1余数1<br>  计算1/2整数0余数1<br>  结果为：1100100</p>
</blockquote>
<h2 id="封装函数"><a href="#封装函数" class="headerlink" title="封装函数"></a>封装函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装十进制转二进制的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dec2bin</span>(<span class="params">decNumer</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 定义变量</span></span><br><span class="line">        <span class="keyword">var</span> stack = <span class="keyword">new</span> Stack()</span><br><span class="line">        <span class="keyword">var</span> remainder;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环除法（循环入栈）</span></span><br><span class="line">        <span class="keyword">while</span> (decNumer &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            remainder = decNumer % <span class="number">2</span></span><br><span class="line">            <span class="comment">// 所除整数用于下次计算</span></span><br><span class="line">            decNumer = <span class="built_in">Math</span>.floor(decNumer / <span class="number">2</span>)</span><br><span class="line">            <span class="comment">// 所除余数放入栈</span></span><br><span class="line">            stack.push(remainder)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将数据取出(循环通过栈出栈获得0和1)</span></span><br><span class="line">        <span class="keyword">var</span> binayriStrng = <span class="string">""</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            binayriStrng += stack.pop()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> binayriStrng</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试函数</span></span><br><span class="line">    alert(dec2bin(<span class="number">10</span>))</span><br><span class="line">    alert(dec2bin(<span class="number">233</span>))</span><br><span class="line">    alert(dec2bin(<span class="number">1000</span>))</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>队列</title>
    <url>/2020/06/25/01%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/01%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/01%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/03%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="认识队列结构"><a href="#认识队列结构" class="headerlink" title="认识队列结构"></a>认识队列结构</h1><blockquote>
<p>队列也是一种非常常见的数据结构, 并且在程序中的应用非常广泛.</p>
</blockquote>
<ul>
<li><p>特点</p>
<ul>
<li>队列是一种受限的线性结构</li>
<li>只能在前端进行删除</li>
<li>只能在后端进行插入</li>
</ul>
</li>
<li><p>队列结构示意图<br><img src="./01.png" alt="队列结构示意图"></p>
</li>
<li><p>举例</p>
<ul>
<li>排队购票</li>
<li>打印机打印文件</li>
<li>开发中线程处理任务，使用线程队列<ul>
<li>在进行多线程开发时, 我们不可能无限制的开启新的线程.</li>
<li>这个时候, 如果有需要开启线程处理任务的情况, 我们就会使用线程队列.</li>
<li>线程队列会依照次序来启动线程, 并且处理对应的任务</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="队列实现"><a href="#队列实现" class="headerlink" title="队列实现"></a>队列实现</h1><h2 id="封装队列类"><a href="#封装队列类" class="headerlink" title="封装队列类"></a>封装队列类</h2><ul>
<li>定义队列</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义队列</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Queue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> items = []</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列操作的方法</span></span><br><span class="line">        <span class="comment">// enter queue方法（向队列尾部添加数据，入队）</span></span><br><span class="line">        <span class="keyword">this</span>.enqueue = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">            items.push(element)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// delete queue方法（从队列头部删除，出队）</span></span><br><span class="line">        <span class="keyword">this</span>.dequeue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> items.shift()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查看前端的元素</span></span><br><span class="line">        <span class="keyword">this</span>.front = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> items[<span class="number">0</span>]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查看队列是否为空</span></span><br><span class="line">        <span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> items.length == <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查看队列中元素的个数</span></span><br><span class="line">        <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> items.length</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// toString方法</span></span><br><span class="line">        <span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; items.length;i++)&#123;</span><br><span class="line">                result += items[i] + <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用队列</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建队列对象</span></span><br><span class="line">        <span class="keyword">var</span> queue = <span class="keyword">new</span> Queue()</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 在队列中添加元素</span></span><br><span class="line">        queue.enqueue(<span class="string">"abc"</span>)</span><br><span class="line">        queue.enqueue(<span class="string">"cba"</span>)</span><br><span class="line">        queue.enqueue(<span class="string">"nba"</span>)</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 查看一下队列前端元素</span></span><br><span class="line">        alert(queue.front())</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 查看队列是否为空和元素个数</span></span><br><span class="line">        alert(queue.isEmpty())</span><br><span class="line">        alert(queue.size())</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 从队列中删除元素</span></span><br><span class="line">        alert(queue.dequeue())</span><br><span class="line">        alert(queue.dequeue())</span><br><span class="line">        alert(queue)</span><br><span class="line">        alert(queue.dequeue())</span><br></pre></td></tr></table></figure>

<h2 id="模拟面试题"><a href="#模拟面试题" class="headerlink" title="模拟面试题"></a>模拟面试题</h2><p>击鼓传花<br>*题目</p>
<ul>
<li>几个朋友一起玩一个游戏, 围成一圈, 开始数数, 数到某个数字的人自动淘汰.</li>
<li>最后剩下的这个人会获得胜利, 请问最后剩下的是原来在哪一个位置上的人?</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现击鼓传花的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">passGame</span>(<span class="params">nameList, num</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建一个队列, 并且将所有的人放在队列中</span></span><br><span class="line">    <span class="comment">// 1.1.创建队列</span></span><br><span class="line">    <span class="keyword">var</span> queue = <span class="keyword">new</span> Queue()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.2.通过for循环, 将nameList中的人放在队列中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nameList.length; i++) &#123;</span><br><span class="line">        queue.enqueue(nameList[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.寻找最后剩下的人</span></span><br><span class="line">    <span class="keyword">while</span> (queue.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 将前num-1中的人, 都从队列的前端取出放在队列的后端</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            queue.enqueue(queue.dequeue())</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将第num个人, 从队列中移除</span></span><br><span class="line">        queue.dequeue()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.获取剩下的一个人</span></span><br><span class="line">    alert(queue.size())</span><br><span class="line">    <span class="keyword">var</span> endName = queue.dequeue()</span><br><span class="line">    alert(<span class="string">"最终留下来的人:"</span> + endName)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.获取该人在队列中的位置</span></span><br><span class="line">    <span class="keyword">return</span> nameList.indexOf(endName)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h1><h2 id="认识优先级队列"><a href="#认识优先级队列" class="headerlink" title="认识优先级队列"></a>认识优先级队列</h2><ul>
<li><p>特点</p>
<ul>
<li>插入元素会考虑数据的优先级</li>
<li>每个元素不仅仅是一个数据还有数据的优先级</li>
</ul>
</li>
<li><p>举例</p>
<ul>
<li>登机头等舱优先级高</li>
<li>线程先处理优先级高的任务</li>
</ul>
</li>
</ul>
<h2 id="封装优先级队列"><a href="#封装优先级队列" class="headerlink" title="封装优先级队列"></a>封装优先级队列</h2><ul>
<li><p>封装优先级队列</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装优先级队列</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">PriorityQueue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> items = []</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 封装一个新的构造函数, 用于保存元素和元素的优先级</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">QueueElement</span>(<span class="params">element, priority</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.element = element</span><br><span class="line">            <span class="keyword">this</span>.priority = priority</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加元素的方法</span></span><br><span class="line">        <span class="keyword">this</span>.enqueue = <span class="function"><span class="keyword">function</span> (<span class="params">element, priority</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 1.根据传入的元素, 创建新的QueueElement</span></span><br><span class="line">            <span class="keyword">var</span> queueElement = <span class="keyword">new</span> QueueElement(element, priority)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.获取传入元素应该在正确的位置</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">                items.push(queueElement)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">var</span> added = <span class="literal">false</span> <span class="comment">// 判断是否插入到优先级队列</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">                    <span class="comment">// 注意: 我们这里是数字越小, 优先级越高</span></span><br><span class="line">                    <span class="keyword">if</span> (queueElement.priority &lt; items[i].priority) &#123;</span><br><span class="line">                        items.splice(i, <span class="number">0</span>, queueElement)</span><br><span class="line">                        added = <span class="literal">true</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 遍历完所有的元素, 优先级都大于新插入的元素时, 就插入到最后</span></span><br><span class="line">                <span class="keyword">if</span> (!added) &#123;</span><br><span class="line">                    items.push(queueElement)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除元素的方法</span></span><br><span class="line">        <span class="keyword">this</span>.dequeue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> items.shift()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取前端的元素</span></span><br><span class="line">        <span class="keyword">this</span>.front = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> items[<span class="number">0</span>]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查看元素是否为空</span></span><br><span class="line">        <span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> items.length == <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取元素的个数</span></span><br><span class="line">        <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> items.length</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>检验优先级队列</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建优先级队列对象</span></span><br><span class="line">    <span class="keyword">var</span> pQueue = <span class="keyword">new</span> PriorityQueue()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    pQueue.enqueue(<span class="string">"abc"</span>, <span class="number">10</span>)</span><br><span class="line">    pQueue.enqueue(<span class="string">"cba"</span>, <span class="number">5</span>)</span><br><span class="line">    pQueue.enqueue(<span class="string">"nba"</span>, <span class="number">12</span>)</span><br><span class="line">    pQueue.enqueue(<span class="string">"mba"</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="comment">// 遍历所有的元素</span></span><br><span class="line">    <span class="keyword">var</span> size = pQueue.size()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> item = pQueue.dequeue()</span><br><span class="line">        alert(item.element + <span class="string">"-"</span> + item.priority)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>字典</title>
    <url>/2020/06/26/01%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/01%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/01%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/07%E5%AD%97%E5%85%B8/</url>
    <content><![CDATA[<h1 id="什么是字典"><a href="#什么是字典" class="headerlink" title="什么是字典"></a>什么是字典</h1><ul>
<li>生活中的字典<ul>
<li>中文字典我们可以根据拼音去查找汉字, 并且找到汉字对应的词以及解释.</li>
<li>英文字典也是类似, 根据英文字母找到对应的单词, 再查看其翻译和应用场景</li>
</ul>
</li>
<li>字典特点<ul>
<li>一一对应</li>
<li>key是不可重复的</li>
<li>key是无序的</li>
<li>可以通过key取出value</li>
</ul>
</li>
<li>字典和数组<ul>
<li>使用数组的方式: [18, “Coderwhy”, 1.88]. 可以通过下标值取出信息.</li>
<li>使用字典的方式: {“age” : 18, “name” : “Coderwhy”, “height”: 1.88}. 可以通过key取出value</li>
<li>字典可以非常方便的通过key来搜索对应的value, key可以包含特殊含义, 也更容易被人们记住.</li>
</ul>
</li>
<li>字典和对象<ul>
<li>很多编程语言(比如Java)中对字典和对象区分比较明显, 对象通常是一种在编译期就确定下来的结构, 不可以动态的添加或者删除属性. 而字典通常会使用类似于哈希表的数据结构去实现一种可以动态的添加数据的结构.</li>
<li>在JavaScript中, 对象本身就是一种字典. 所有在早期的JavaScript中, 没有字典这种数据类型, 因为完全可以使用对象去代替.</li>
</ul>
</li>
</ul>
<h1 id="封装实现"><a href="#封装实现" class="headerlink" title="封装实现"></a>封装实现</h1><h2 id="封装字典"><a href="#封装字典" class="headerlink" title="封装字典"></a>封装字典</h2><ul>
<li>字典常见的操作<ul>
<li>set(key,value)：向字典中添加新元素。</li>
<li>remove(key)：通过使用键值来从字典中移除键值对应的数据值。</li>
<li>has(key)：如果某个键值存在于这个字典中，则返回true，反之则返回false。</li>
<li>get(key)：通过键值查找特定的数值并返回。</li>
<li>clear()：将这个字典中的所有元素全部删除。</li>
<li>size()：返回字典所包含元素的数量。与数组的length属性类似。</li>
<li>keys()：将字典所包含的所有键名以数组形式返回。</li>
<li>values()：将字典所包含的所有数值以数组形式返回</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建字典的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dictionay</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 字典属性</span></span><br><span class="line">    <span class="keyword">this</span>.items = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字典操作方法</span></span><br><span class="line">    <span class="comment">// 在字典中添加键值对</span></span><br><span class="line">    Dictionay.prototype.set = <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.items[key] = value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断字典中是否有某个key</span></span><br><span class="line">    Dictionay.prototype.has = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.hasOwnProperty(key)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从字典中移除元素</span></span><br><span class="line">    Dictionay.prototype.remove = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 1.判断字典中是否有这个key</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.has(key)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.从字典中删除key</span></span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>.items[key]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据key去获取value</span></span><br><span class="line">    Dictionay.prototype.get = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.has(key) ? <span class="keyword">this</span>.items[key] : <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取所有的keys</span></span><br><span class="line">    Dictionay.prototype.keys = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.items)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取所有的value</span></span><br><span class="line">    Dictionay.prototype.values = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.values(<span class="keyword">this</span>.items)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// size方法</span></span><br><span class="line">    Dictionay.prototype.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.keys().length</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear方法</span></span><br><span class="line">    Dictionay.prototype.clear = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.items = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建字典对象</span></span><br><span class="line"><span class="keyword">var</span> dict = <span class="keyword">new</span> Dictionay()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在字典中添加元素</span></span><br><span class="line">dict.set(<span class="string">"age"</span>, <span class="number">18</span>)</span><br><span class="line">dict.set(<span class="string">"name"</span>, <span class="string">"Coderwhy"</span>)</span><br><span class="line">dict.set(<span class="string">"height"</span>, <span class="number">1.88</span>)</span><br><span class="line">dict.set(<span class="string">"address"</span>, <span class="string">"广州市"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取字典的信息</span></span><br><span class="line">alert(dict.keys()) <span class="comment">// age,name,height,address</span></span><br><span class="line">alert(dict.values()) <span class="comment">// 18,Coderwhy,1.88,广州市</span></span><br><span class="line">alert(dict.size()) <span class="comment">// 4</span></span><br><span class="line">alert(dict.get(<span class="string">"name"</span>)) <span class="comment">// Coderwhy</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字典的删除方法</span></span><br><span class="line">dict.remove(<span class="string">"height"</span>)</span><br><span class="line">alert(dict.keys())<span class="comment">// age,name,address</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空字典</span></span><br><span class="line">dict.clear()</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>数组</title>
    <url>/2020/06/25/01%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/01%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/01%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/01%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="创建和初始化数组"><a href="#创建和初始化数组" class="headerlink" title="创建和初始化数组"></a>创建和初始化数组</h1><p>用JavaScript声明、创建和初始化数组很简单</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建和初始化数组</span></span><br><span class="line"><span class="keyword">var</span> daysOfWeek = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line"><span class="keyword">var</span> daysOfWeek = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">7</span>)</span><br><span class="line"><span class="keyword">var</span> daysOfWeek = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'Sunday'</span>, <span class="string">'Monday'</span>, <span class="string">'Tuesday'</span>, <span class="string">'Wednesday'</span>,<span class="string">'Thursday'</span>, <span class="string">'Friday'</span>, <span class="string">'Saturday'</span>)</span><br><span class="line"><span class="keyword">var</span> daysOfWeek = [<span class="string">'Sunday'</span>, <span class="string">'Monday'</span>, <span class="string">'Tuesday'</span>, <span class="string">'Wednesday'</span>,<span class="string">'Thursday'</span>, <span class="string">'Friday'</span>, <span class="string">'Saturday'</span>];</span><br></pre></td></tr></table></figure>

<h1 id="数组长度和遍历数组"><a href="#数组长度和遍历数组" class="headerlink" title="数组长度和遍历数组"></a>数组长度和遍历数组</h1><p>获取数组的长度</p>
<blockquote>
<p>daysOfWeek.length</p>
</blockquote>
<p>通过下标值来遍历数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 普通for方式遍历数组</span><br><span class="line">for (var i &#x3D; 0; i &lt; daysOfWeek.length; i++) &#123;</span><br><span class="line">    alert(daysOfWeek[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过foreach遍历数组</span><br><span class="line">daysOfWeek.forEach(function (value) &#123;</span><br><span class="line">    alert(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="数组的常见操作"><a href="#数组的常见操作" class="headerlink" title="数组的常见操作"></a>数组的常见操作</h1><h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><ul>
<li>假如我们有一个数组: numbers, 初始化0~9</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化一个数组</span></span><br><span class="line"><span class="keyword">var</span> numbers = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>添加一个元素到数组的最后位置</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一:</span></span><br><span class="line">numbers[numbers.length] = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二:</span></span><br><span class="line">numbers.push(<span class="number">11</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>在数组首位插入一个元素自己实现代码</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在数组首位插入一个元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = numbers.length; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    numbers[i] = numbers[i<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">numbers[<span class="number">0</span>] = <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>上面代码实现的原理是怎样的呢?<br><img src="./01.png" alt="数据结构预算法目录"></p>
</li>
<li><p>当然, 我们在数组首位插入数据可以直接使用unshift方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过unshift在首位插入数据</span></span><br><span class="line">numbers.unshift(<span class="number">-2</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><ul>
<li><p>如果希望删除数组最后的元素, 可以使用pop()方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除最后的元素</span></span><br><span class="line">numbers.pop()</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果我们希望移除的首位元素, 自己实现代码:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除首位的元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">    numbers[i] = numbers[i+<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">numbers.pop()</span><br></pre></td></tr></table></figure>
</li>
<li><p>当然, 我们可以直接使用shift方法来实现:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">numbers.shift()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="splice实现删除添加"><a href="#splice实现删除添加" class="headerlink" title="splice实现删除添加"></a>splice实现删除添加</h2><ul>
<li>通过splice删除数据</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除指定位置的几个元素</span></span><br><span class="line">numbers.splice(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 上面的代码会删除索引为5, 6, 7位置的元素.</span></span><br><span class="line"><span class="comment">// 第一个参数表示索引起始的位置为5(其实是第6个元素, 因为索引从0开始的), 删除3个元素</span></span><br></pre></td></tr></table></figure>

<ul>
<li>用splice来插入数据</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入指定位置元素</span></span><br><span class="line">numbers.splice(<span class="number">5</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 从索引为5的位置开始插入数据. 其他数据依次向后位移</span></span><br><span class="line"><span class="comment">// 第一个参数依然是索引值为5(第六个位置)</span></span><br><span class="line"><span class="comment">// 第二个参数为0时表示不是删除数据, 而是插入数据.</span></span><br><span class="line"><span class="comment">// 后面紧跟的是在这个位置要插入的数据</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用splice来修改数据</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改指定位置的元素</span></span><br><span class="line">numbers.splice(<span class="number">5</span>, <span class="number">3</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>)</span><br><span class="line"><span class="comment">// 第一个参数依然是索引的位置为5(第六个位置)</span></span><br><span class="line"><span class="comment">// 第二个参数是要将数组中多少个元素给替换掉, 我们这里是3个(也可以使用3个元素来替换2个)</span></span><br><span class="line"><span class="comment">// 后面跟着的就是要替换的元素.</span></span><br></pre></td></tr></table></figure>

<h1 id="数组的其他操作"><a href="#数组的其他操作" class="headerlink" title="数组的其他操作"></a>数组的其他操作</h1><h2 id="数组合并"><a href="#数组合并" class="headerlink" title="数组合并"></a>数组合并</h2><p>数组的合并非常简单, 使用concat即可(也可以直接+进行合并)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// concat</span></span><br><span class="line"><span class="keyword">var</span> nums1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> nums2 = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]</span><br><span class="line"><span class="keyword">var</span> newNums = nums1.concat(nums2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// + </span></span><br><span class="line">newNums = nums1 + nums2</span><br></pre></td></tr></table></figure>

<h2 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h2><h3 id="every-方法——是否全部"><a href="#every-方法——是否全部" class="headerlink" title="every()方法——是否全部"></a>every()方法——是否全部</h3><ul>
<li>every()方法是将数组中每一个元素传入到一个函数中, 该函数返回true/false</li>
<li>如果函数中每一个元素都返回true, 那么结果为true, 有一个为false, 那么结果为false</li>
</ul>
<p>判断一组元素中是否都包含某一个字符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义数组</span></span><br><span class="line"><span class="keyword">var</span> names = [<span class="string">"abc"</span>, <span class="string">"cb"</span>, <span class="string">"mba"</span>, <span class="string">"dna"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断数组的元素是否都包含a字符</span></span><br><span class="line"><span class="keyword">var</span> flag = names.every(<span class="function"><span class="keyword">function</span> (<span class="params">t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.indexOf(<span class="string">'a'</span>) != <span class="number">-1</span></span><br><span class="line">&#125;)</span><br><span class="line">alert(flag)</span><br></pre></td></tr></table></figure>

<h3 id="some-方法——是否有"><a href="#some-方法——是否有" class="headerlink" title="some()方法——是否有"></a>some()方法——是否有</h3><ul>
<li>some()方法是将数组中每一个元素传入到一个函数中, 该函数返回true/false</li>
<li>但是和every不同的是, 一旦有一次函数返回了true, 那么迭代就会结束. 并且结果为true</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义数组</span></span><br><span class="line"><span class="keyword">var</span> names = [<span class="string">"abc"</span>, <span class="string">"cb"</span>, <span class="string">"mba"</span>, <span class="string">"dna"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断数组中是否包含有a字符的字符</span></span><br><span class="line"><span class="keyword">var</span> flag = names.some(<span class="function"><span class="keyword">function</span> (<span class="params">t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.indexOf(<span class="string">"a"</span>) != <span class="number">-1</span></span><br><span class="line">&#125;)</span><br><span class="line">alert(flag)</span><br></pre></td></tr></table></figure>

<h3 id="forEach-方法"><a href="#forEach-方法" class="headerlink" title="forEach()方法"></a>forEach()方法</h3><ul>
<li>forEach()方法仅仅是一种快速迭代数组的方式而已.</li>
<li>该方法不需要返回值</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义数组</span></span><br><span class="line"><span class="keyword">var</span> names = [<span class="string">"abc"</span>, <span class="string">"cb"</span>, <span class="string">"mba"</span>, <span class="string">"dna"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// forEach的使用</span></span><br><span class="line">names.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">t</span>) </span>&#123;</span><br><span class="line">    alert(t)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="filter-方法"><a href="#filter-方法" class="headerlink" title="filter()方法"></a>filter()方法</h3><ul>
<li>filter()方法是一种过滤的函数</li>
<li>首先会遍历数组中每一个元素传入到函数中</li>
<li>函数的结果返回true, 那么这个元素会被添加到最新的数组中, 返回false, 则忽略该元素.</li>
<li>最终会形成一个新的数组, 该数组就是filter()方法的返回值</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义数组</span></span><br><span class="line"><span class="keyword">var</span> names = [<span class="string">"abc"</span>, <span class="string">"cb"</span>, <span class="string">"mba"</span>, <span class="string">"dna"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取names中所有包含'a'字符的元素</span></span><br><span class="line"><span class="keyword">var</span> newNames = names.filter(<span class="function"><span class="keyword">function</span> (<span class="params">t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.indexOf(<span class="string">"a"</span>) != <span class="number">-1</span></span><br><span class="line">&#125;)</span><br><span class="line">alert(newNames)</span><br></pre></td></tr></table></figure>

<h3 id="map-方法"><a href="#map-方法" class="headerlink" title="map()方法"></a>map()方法</h3><ul>
<li>map()方法提供的是一种映射函数.</li>
<li>首先会遍历数组中每一个元素传入到函数中.</li>
<li>元素会经过函数中的指令进行各种变换, 生成新的元素, 并且将新的元素返回.</li>
<li>最终会将返回的所有元素形成一个新的数组, 该数组就是map()方法的返回值</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义数组</span></span><br><span class="line"><span class="keyword">var</span> names = [<span class="string">"abc"</span>, <span class="string">"cb"</span>, <span class="string">"mba"</span>, <span class="string">"dna"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在names中所有的元素后面拼接-abc</span></span><br><span class="line"><span class="keyword">var</span> newNames = names.map(<span class="function"><span class="keyword">function</span> (<span class="params">t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t + <span class="string">"-abc"</span></span><br><span class="line">&#125;)</span><br><span class="line">alert(newNames)</span><br></pre></td></tr></table></figure>

<h3 id="reduce方法"><a href="#reduce方法" class="headerlink" title="reduce方法"></a>reduce方法</h3><p>求一个数组中，数字的累加</p>
<ul>
<li><p>使用forEach实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> total = <span class="number">0</span></span><br><span class="line">numbers.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">t</span>) </span>&#123;</span><br><span class="line">    total += t</span><br><span class="line">&#125;)</span><br><span class="line">alert(total)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用reduce方法实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> total = numbers.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">pre, cur</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pre + cur</span><br><span class="line">&#125;)</span><br><span class="line">alert(total)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>reduce方法有返回值, reduce方法本身就可以作为参数直接传递给另外一个需要reduce返回值的作为参数的函数. 而forEach中你只能先将每次函数的结果保存在一个变量, 最后再将变量传入到参数中</p>
</blockquote>
<h1 id="数组特点"><a href="#数组特点" class="headerlink" title="数组特点"></a>数组特点</h1><ol>
<li>连续空间，定义之后就不允许扩展<ul>
<li>如果定义为5个位置，需要添加第六个则需要开辟新的内存，之后把第一个数组复制进去再在后面继续添加</li>
</ul>
</li>
<li>添加删除操作消耗大<ul>
<li>在数组前面添加或删除数据都需要把后面的元素以此移位，所以消耗较大</li>
</ul>
</li>
<li>有固定下标查找方便</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>集合</title>
    <url>/2020/06/26/01%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/01%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/01%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/06%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="集合特点"><a href="#集合特点" class="headerlink" title="集合特点"></a>集合特点</h1><ul>
<li>无序的，不能重复的</li>
<li>不能通过下标值直接进行访问</li>
<li>看成一种特殊的数组</li>
</ul>
<p><em>ES6中包含了Set类, 所以其实我们可以不封装, 直接使用它</em> </p>
<h1 id="集合间的操作"><a href="#集合间的操作" class="headerlink" title="集合间的操作"></a>集合间的操作</h1><ul>
<li>并集<ul>
<li>对于给定的两个集合，返回一个包含两个集合中所有的元素的新集合</li>
</ul>
</li>
<li>交集<ul>
<li>对于给定的两个集合，返回一个包含两个集合中公共的元素的新集合</li>
</ul>
</li>
<li>差集<ul>
<li>对于给定的两个集合，返回一个包含所有存在于第一个集合并且不存在于第二个集合的元素的新集合</li>
</ul>
</li>
<li>子集<ul>
<li>验证一个给定集合是否是另外一个集合的子集</li>
</ul>
</li>
</ul>
<h1 id="封装集合"><a href="#封装集合" class="headerlink" title="封装集合"></a>封装集合</h1><h2 id="创建集合类"><a href="#创建集合类" class="headerlink" title="创建集合类"></a>创建集合类</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装集合的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 使用一个对象来保存集合的元素</span></span><br><span class="line">    <span class="keyword">this</span>.items = &#123;&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断集合中是否有某个元素"><a href="#判断集合中是否有某个元素" class="headerlink" title="判断集合中是否有某个元素"></a>判断集合中是否有某个元素</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断集合中是否有某个元素</span></span><br><span class="line"><span class="built_in">Set</span>.prototype.has = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.hasOwnProperty(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="向集合中添加元素"><a href="#向集合中添加元素" class="headerlink" title="向集合中添加元素"></a>向集合中添加元素</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向集合中添加元素</span></span><br><span class="line"><span class="built_in">Set</span>.prototype.add = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.判断集合中是否已经包含了该元素</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.has(value)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.将元素添加到集合中</span></span><br><span class="line">    <span class="keyword">this</span>.items[value] = value</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="从集合中删除某个元素"><a href="#从集合中删除某个元素" class="headerlink" title="从集合中删除某个元素"></a>从集合中删除某个元素</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从集合中删除某个元素</span></span><br><span class="line"><span class="built_in">Set</span>.prototype.remove = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.判断集合中是否包含该元素</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.has(value)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.包含该元素, 那么将元素删除</span></span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>.items[value] <span class="comment">//  delete操作符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="清空集合中所有的元素"><a href="#清空集合中所有的元素" class="headerlink" title="清空集合中所有的元素"></a>清空集合中所有的元素</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 清空集合中所有的元素</span></span><br><span class="line"><span class="built_in">Set</span>.prototype.clear = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.items = &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取集合的大小"><a href="#获取集合的大小" class="headerlink" title="获取集合的大小"></a>获取集合的大小</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取集合的大小</span></span><br><span class="line"><span class="built_in">Set</span>.prototype.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.items).length</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    考虑兼容性问题, 使用下面的代码</span></span><br><span class="line"><span class="comment">    var count = 0</span></span><br><span class="line"><span class="comment">    for (var value in this.items) &#123;</span></span><br><span class="line"><span class="comment">        if (this.items.hasOwnProperty(value)) &#123;</span></span><br><span class="line"><span class="comment">            count++</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return count</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取集合中所有的值"><a href="#获取集合中所有的值" class="headerlink" title="获取集合中所有的值"></a>获取集合中所有的值</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取集合中所有的值</span></span><br><span class="line"><span class="built_in">Set</span>.prototype.values = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.items)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    考虑兼容性问题, 使用下面的代码</span></span><br><span class="line"><span class="comment">    var keys = []</span></span><br><span class="line"><span class="comment">    for (var value in this.items) &#123;</span></span><br><span class="line"><span class="comment">        keys.push(value)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return keys</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="built_in">Set</span>.prototype.union = <span class="function"><span class="keyword">function</span> (<span class="params">otherSet</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建新的集合</span></span><br><span class="line">    <span class="keyword">var</span> unionSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="comment">// 将A集合中的所有元素添加到新的集合</span></span><br><span class="line">    <span class="keyword">var</span> values= <span class="keyword">this</span>.values();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;values.length;i++)&#123;</span><br><span class="line">        unionSet.add(values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取出B集合中的元素，判断是否需要添加到新的集合</span></span><br><span class="line">    values= otherSet.values();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;values.length;i++)&#123;</span><br><span class="line">        unionSet.add(values[i]); <span class="comment">// 过滤重复数据再add方法里面有</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unionSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="built_in">Set</span>.prototype.intersection = <span class="function"><span class="keyword">function</span> (<span class="params">otherSet</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建新的集合</span></span><br><span class="line">    <span class="keyword">var</span> intersection = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="comment">// 将A集合中的所有元素判断是否存在于集合B中，如果存在进行存放</span></span><br><span class="line">    <span class="keyword">var</span> values= <span class="keyword">this</span>.values();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;values.length;i++)&#123;</span><br><span class="line">        <span class="keyword">var</span> item = values[i];</span><br><span class="line">        <span class="comment">// 如果B中存在则加入新集合中</span></span><br><span class="line">        <span class="keyword">if</span>(otherSet.has(item))&#123;</span><br><span class="line">            intersection.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intersection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="built_in">Set</span>.prototype.difference = <span class="function"><span class="keyword">function</span> (<span class="params">otherSet</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建新的集合</span></span><br><span class="line">    <span class="keyword">var</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="comment">// 将A集合中的所有元素判断是否存在于集合B中，如果不存在进行存放</span></span><br><span class="line">    <span class="keyword">var</span> values= <span class="keyword">this</span>.values();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;values.length;i++)&#123;</span><br><span class="line">        <span class="keyword">var</span> item = values[i];</span><br><span class="line">        <span class="comment">// 如果B中不存在则加入新集合中</span></span><br><span class="line">        <span class="keyword">if</span>(!otherSet.has(item))&#123;</span><br><span class="line">            difference.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> difference;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子集</span></span><br><span class="line"><span class="built_in">Set</span>.prototype.subSet = <span class="function"><span class="keyword">function</span> (<span class="params">otherSet</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将A集合中的所有元素判断是否存在于集合B中，如果不存在进行存放</span></span><br><span class="line">    <span class="keyword">var</span> values= <span class="keyword">this</span>.values();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;values.length;i++)&#123;</span><br><span class="line">        <span class="keyword">var</span> item = values[i];</span><br><span class="line">        <span class="comment">// 如果B中不存在则返回false</span></span><br><span class="line">        <span class="keyword">if</span>(!otherSet.has(item))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试和使用集合类</span></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">set</span> = new Set()</span><br><span class="line"></span><br><span class="line">    // 添加元素</span><br><span class="line">    <span class="keyword">set</span>.add(1)</span><br><span class="line">    alert(<span class="keyword">set</span>.values()) // 1</span><br><span class="line">    <span class="keyword">set</span>.add(1)</span><br><span class="line">    alert(<span class="keyword">set</span>.values()) // 1</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span>.add(100)</span><br><span class="line">    <span class="keyword">set</span>.add(200)</span><br><span class="line">    alert(<span class="keyword">set</span>.values()) // 1,100,200</span><br><span class="line"></span><br><span class="line">    // 判断是否包含元素</span><br><span class="line">    alert(<span class="keyword">set</span>.has(100)) // true</span><br><span class="line"></span><br><span class="line">    // 删除元素</span><br><span class="line">    <span class="keyword">set</span>.remove(100)</span><br><span class="line">    alert(<span class="keyword">set</span>.values()) // 1, 200</span><br><span class="line"></span><br><span class="line">    // 获取集合的大小</span><br><span class="line">    alert(<span class="keyword">set</span>.size()) // 2</span><br><span class="line">    <span class="keyword">set</span>.clear()</span><br><span class="line">    alert(<span class="keyword">set</span>.size()) // 0</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2020/06/25/01%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/01%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/01%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/04%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="什么是链表"><a href="#什么是链表" class="headerlink" title="什么是链表"></a>什么是链表</h1><blockquote>
<p>链表类似于火车: 有一个火车头, 火车头会连接一个节点, 节点上有乘客, 并且这个节点会连接下一个节点, 以此类推.</p>
</blockquote>
<ul>
<li>链表的火车结构</li>
</ul>
<p><img src="./01.png" alt="火车结构"></p>
<ul>
<li>链表的数据结构</li>
</ul>
<p><img src="./02.png" alt="链表结构"></p>
<ul>
<li>给火车加上数据后的结构</li>
</ul>
<p><img src="./03.png" alt="火车链表结构"></p>
<h1 id="数组和链表"><a href="#数组和链表" class="headerlink" title="数组和链表"></a>数组和链表</h1><h3 id="数组的缺点"><a href="#数组的缺点" class="headerlink" title="数组的缺点"></a>数组的缺点</h3><ul>
<li>数组的创建通常需要申请一段连续的内存空间(一整块的内存), 并且大小是固定的, 所以当当前数组不能满足容量需求时, 需要扩容. (一般情况下是申请一个更大的数组, 比如2倍. 然后将原数组中的元素复制过去)</li>
<li>在数组开头或中间位置插入数据的成本很高, 需要进行大量元素的位移.</li>
</ul>
<h3 id="链表的优点"><a href="#链表的优点" class="headerlink" title="链表的优点"></a>链表的优点</h3><ul>
<li>内存空间不是比是连续的. 可以充分利用计算机的内存. 实现灵活的内存动态管理</li>
<li>链表不必在创建时就确定大小, 并且大小可以无限的延伸下去</li>
<li>链表在插入和删除数据时, 时间复杂度可以达到O(1). 相对数组效率高很多</li>
</ul>
<h3 id="链表的缺点"><a href="#链表的缺点" class="headerlink" title="链表的缺点"></a>链表的缺点</h3><ul>
<li>链表访问任何一个位置的元素时, 都需要从头开始访问.(无法跳过第一个元素访问任何一个元素).</li>
<li>无法通过下标直接访问元素, 需要从头一个个访问, 直到找到对应的问题.</li>
</ul>
<h1 id="链表的封装"><a href="#链表的封装" class="headerlink" title="链表的封装"></a>链表的封装</h1><h2 id="创建链表类"><a href="#创建链表类" class="headerlink" title="创建链表类"></a>创建链表类</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装链表的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 封装一个Node类, 用于保存每个节点信息</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element <span class="comment">// 节点数据</span></span><br><span class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span> <span class="comment">// 指向下个节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表中的属性</span></span><br><span class="line">    <span class="keyword">this</span>.length = <span class="number">0</span>  <span class="comment">// 链表的长度</span></span><br><span class="line">    <span class="keyword">this</span>.head = <span class="literal">null</span> <span class="comment">// 链表的第一个节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表尾部追加元素方法"><a href="#链表尾部追加元素方法" class="headerlink" title="链表尾部追加元素方法"></a>链表尾部追加元素方法</h2><ul>
<li>场景一: 链表本身是空的, 比如这种情况下我们插入了一个15作为元素.</li>
</ul>
<p><img src="./04.png" alt="尾部追加场景1"></p>
<ul>
<li>场景二: 链表中已经有元素了, 需要向最后的节点的next中添加节点.<ul>
<li>首先找到head</li>
<li>循环到最后，让最后节点指向这个新节点</li>
<li>长度+1</li>
</ul>
</li>
</ul>
<p><img src="./05.png" alt="尾部追加场景2"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链表尾部追加元素方法</span></span><br><span class="line">LinkedList.prototype.append = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.根据新元素创建节点</span></span><br><span class="line">    <span class="keyword">var</span> newNode = <span class="keyword">new</span> Node(element)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.判断原来链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.head === <span class="literal">null</span>) &#123; <span class="comment">// 链表为空</span></span><br><span class="line">        <span class="keyword">this</span>.head = newNode <span class="comment">// 直接插入，让头指向这个节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 链表不为空</span></span><br><span class="line">        <span class="comment">// 2.1.定义变量, 保存当前找到的节点</span></span><br><span class="line">        <span class="keyword">var</span> current = <span class="keyword">this</span>.head</span><br><span class="line">        <span class="keyword">while</span> (current.next) &#123; <span class="comment">// 循环直到next为null就代表是末尾</span></span><br><span class="line">            current = current.next <span class="comment">// 这个是最后一个next=null的</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.2.找到最后一项, 将其next赋值为node</span></span><br><span class="line">        current.next = newNode</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.链表长度增加1</span></span><br><span class="line">    <span class="keyword">this</span>.length++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表的toString方法"><a href="#链表的toString方法" class="headerlink" title="链表的toString方法"></a>链表的toString方法</h2><ul>
<li>定义两个变量<ul>
<li>找到链表的头</li>
<li>定义字符串</li>
</ul>
</li>
<li>循环获取链表中所有的元素</li>
<li>返回最终结果</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链表的toString方法</span></span><br><span class="line">LinkedList.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.定义两个变量</span></span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span>.head <span class="comment">// 找到链表的头</span></span><br><span class="line">    <span class="keyword">var</span> listString = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.循环获取链表中所有的元素</span></span><br><span class="line">    <span class="keyword">while</span> (current) &#123;</span><br><span class="line">        listString += <span class="string">","</span> + current.element</span><br><span class="line">        current = current.next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.返回最终结果</span></span><br><span class="line">    <span class="keyword">return</span> listString.slice(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="根据位置插入元素"><a href="#根据位置插入元素" class="headerlink" title="根据位置插入元素"></a>根据位置插入元素</h2><ul>
<li>添加到第一个位置<ul>
<li>获取原来的头元素</li>
<li>让head指向新元素</li>
<li>新元素链表指向原来的头元素</li>
</ul>
</li>
</ul>
<p><img src="./06.png" alt="根据位置插入元素1"></p>
<ul>
<li>添加到其他位置<ul>
<li>循环一直到添加的位置，并获取原来元素以及这个元素的前一个元素</li>
<li>前一个元素指向新元素</li>
<li>新元素指向之前元素</li>
</ul>
</li>
</ul>
<p><img src="./07.png" alt="根据位置插入元素2"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">LinkedList.prototype.insert = <span class="function"><span class="keyword">function</span> (<span class="params">position, element</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.检测越界问题: 越界插入失败</span></span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt; <span class="keyword">this</span>.length) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.定义变量, 保存信息</span></span><br><span class="line">    <span class="keyword">var</span> newNode = <span class="keyword">new</span> Node(element)</span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span>.head <span class="comment">// 这个是这个节点，需要新节点指向下一个节点</span></span><br><span class="line">    <span class="keyword">var</span> previous = <span class="literal">null</span> <span class="comment">// 这个是上一个节点，需要上一个节点的next指向新节点</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.判断是否列表是否在第一个位置插入</span></span><br><span class="line">    <span class="keyword">if</span> (position == <span class="number">0</span>) &#123;</span><br><span class="line">        newNode.next = current</span><br><span class="line">        <span class="keyword">this</span>.head = newNode</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (index++ &lt; position) &#123; <span class="comment">//先判断再++</span></span><br><span class="line">            previous = current</span><br><span class="line">            current = current.next</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        newNode.next = current <span class="comment">// 新节点的next指向current</span></span><br><span class="line">        previous.next = newNode <span class="comment">// 前一个节点指向newNode</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.length+1</span></span><br><span class="line">    <span class="keyword">this</span>.length++</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="根据位置获取节点"><a href="#根据位置获取节点" class="headerlink" title="根据位置获取节点"></a>根据位置获取节点</h2><ul>
<li>循环直到指定的位置</li>
<li>返回这个位置的元素</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据位置获取节点</span></span><br><span class="line">LinkedList.prototype.get = <span class="function"><span class="keyword">function</span> (<span class="params">position</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.检测越界问题: 越界移除失败, 返回null</span></span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="keyword">this</span>.length) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.定义变量, 保存信息</span></span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 循环到要获取的位置</span></span><br><span class="line">    <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">        current = current.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.返回获取的数据</span></span><br><span class="line">    <span class="keyword">return</span> current.element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="根据元素获取链表中的位置"><a href="#根据元素获取链表中的位置" class="headerlink" title="根据元素获取链表中的位置"></a>根据元素获取链表中的位置</h2><ul>
<li>循环直到节点等于传入的节点</li>
<li>返回这个位置</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据元素获取链表中的位置</span></span><br><span class="line">LinkedList.prototype.indexOf = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.定义变量, 保存信息</span></span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span>.head</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.找到元素所在的位置</span></span><br><span class="line">    <span class="keyword">while</span> (current) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current.element === element) &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">        index++</span><br><span class="line">        current = current.next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.来到这个位置, 说明没有找到, 则返回-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="根据位置移除节点"><a href="#根据位置移除节点" class="headerlink" title="根据位置移除节点"></a>根据位置移除节点</h2><ul>
<li>移除第一项的信息<ul>
<li>移除第一项时, 直接让head指向第二项信息就可以啦</li>
<li>第一项信息没有引用指向, 就在链表中不再有效, 后面会被回收掉</li>
</ul>
</li>
</ul>
<p><img src="./08.png" alt="据位置移除节点1"></p>
<ul>
<li>移除其他项的信息<ul>
<li>通过while循环, 找到正确的位置</li>
<li>找到正确位置后, 就可以直接将上一项的next指向current项的next, 这样中间的项就没有引用指向它, 也就不再存在于链表后, 会面会被回收掉.</li>
</ul>
</li>
</ul>
<p><img src="./10.png" alt="据位置移除节点2"></p>
<p><img src="./11.png" alt="据位置移除节点3"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据位置移除节点</span></span><br><span class="line">LinkedList.prototype.removeAt = <span class="function"><span class="keyword">function</span> (<span class="params">position</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.检测越界问题: 越界移除失败, 返回null</span></span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="keyword">this</span>.length) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.定义变量, 保存信息</span></span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="keyword">var</span> previous = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.判断是否是移除第一项</span></span><br><span class="line">    <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.head = current.next</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">            previous = current</span><br><span class="line">            current = current.next</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        previous.next = current.next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.length-1</span></span><br><span class="line">    <span class="keyword">this</span>.length--</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.返回移除的数据</span></span><br><span class="line">    <span class="keyword">return</span> current.element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="根据位置修改节点"><a href="#根据位置修改节点" class="headerlink" title="根据位置修改节点"></a>根据位置修改节点</h2><ul>
<li>循环到指定位置</li>
<li>修改节点的值</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据位置修改节点</span></span><br><span class="line">LinkedList.prototype.update = <span class="function"><span class="keyword">function</span> (<span class="params">position, newData</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.检测越界问题: 越界移除失败, 返回null</span></span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="keyword">this</span>.length) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.定义变量, 保存信息</span></span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 循环到要获取的位置</span></span><br><span class="line">    <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">        current = current.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改节点</span></span><br><span class="line">    current.element = newData;</span><br><span class="line">    <span class="comment">// 5.返回成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="根据元素删除信息"><a href="#根据元素删除信息" class="headerlink" title="根据元素删除信息"></a>根据元素删除信息</h2><ul>
<li>调用之前定义的indexOf方法获取元素的位置</li>
<li>调用之前定义的removeAt方法移除元素</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据元素删除信息</span></span><br><span class="line">LinkedList.prototype.remove = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> index = <span class="keyword">this</span>.indexOf(element) <span class="comment">// 找到这个元素的位置</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.removeAt(index)<span class="comment">// 通过位置删除元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断链表是否为空"><a href="#判断链表是否为空" class="headerlink" title="判断链表是否为空"></a>判断链表是否为空</h2><ul>
<li>看长度是否为0</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断链表是否为空</span></span><br><span class="line">LinkedList.prototype.isEmpty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取链表的长度"><a href="#获取链表的长度" class="headerlink" title="获取链表的长度"></a>获取链表的长度</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取链表的长度</span></span><br><span class="line">LinkedList.prototype.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取第一个节点"><a href="#获取第一个节点" class="headerlink" title="获取第一个节点"></a>获取第一个节点</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取第一个节点</span></span><br><span class="line">LinkedList.prototype.getFirst = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.head.element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试链表"><a href="#测试链表" class="headerlink" title="测试链表"></a>测试链表</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.创建链表</span></span><br><span class="line">    <span class="keyword">var</span> list = <span class="keyword">new</span> LinkedList()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.追加元素</span></span><br><span class="line">    list.append(<span class="number">15</span>)</span><br><span class="line">    list.append(<span class="number">10</span>)</span><br><span class="line">    list.append(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.打印链表的结果</span></span><br><span class="line">    alert(list) <span class="comment">// 15,10,20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.测试insert方法</span></span><br><span class="line">    list.insert(<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">    list.insert(<span class="number">4</span>, <span class="number">200</span>)</span><br><span class="line">    list.insert(<span class="number">2</span>, <span class="number">300</span>)</span><br><span class="line">    alert(list) <span class="comment">// 100,15,300,10,20,200</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.测试removeAt方法</span></span><br><span class="line">    list.removeAt(<span class="number">0</span>)</span><br><span class="line">    list.removeAt(<span class="number">1</span>)</span><br><span class="line">    list.removeAt(<span class="number">3</span>)</span><br><span class="line">    alert(list)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.测试indexOf方法</span></span><br><span class="line">   alert(list.indexOf(<span class="number">15</span>))</span><br><span class="line">   alert(list.indexOf(<span class="number">10</span>))</span><br><span class="line">   alert(list.indexOf(<span class="number">20</span>))</span><br><span class="line">   alert(list.indexOf(<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.测试remove方法</span></span><br><span class="line">    list.remove(<span class="number">15</span>)</span><br><span class="line">    alert(list)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8.测试其他方法</span></span><br><span class="line">    alert(list.isEmpty())</span><br><span class="line">    alert(list.size())</span><br><span class="line">    alert(list.getFirst())</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>二叉搜索树</title>
    <url>/2020/07/01/01%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/01%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/03%E6%A0%91/02%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1 id="什么是二叉搜索树"><a href="#什么是二叉搜索树" class="headerlink" title="什么是二叉搜索树"></a>什么是二叉搜索树</h1><h2 id="二叉搜索树特点"><a href="#二叉搜索树特点" class="headerlink" title="二叉搜索树特点"></a>二叉搜索树特点</h2><ul>
<li>二叉搜索树（BST，Binary Search Tree），也称二叉排序树或二叉查找树</li>
<li>二叉搜索树是一颗二叉树, 可以为空；如果不为空，满足以下性质<ul>
<li>非空左子树的所有键值小于其根结点的键值</li>
<li>非空右子树的所有键值大于其根结点的键值</li>
<li>左、右子树本身也都是二叉搜索树</li>
</ul>
</li>
</ul>
<p><img src="./01.png" alt="二叉搜索树"></p>
<ul>
<li>二叉搜索树特点<ul>
<li>对较小的值总是保存在左结点上</li>
<li>相对较大的值总是保存在右结点上</li>
<li>查找效率非常高, 这也是二叉搜索树中, 搜索的来源</li>
</ul>
</li>
</ul>
<h2 id="二叉搜索树遍历"><a href="#二叉搜索树遍历" class="headerlink" title="二叉搜索树遍历"></a>二叉搜索树遍历</h2><ul>
<li>先序遍历（根节点在第一位）<ul>
<li>访问根结点</li>
<li>先序遍历其左子树</li>
<li>先序遍历其右子树</li>
</ul>
</li>
</ul>
<p><img src="./02.png" alt="先序遍历"></p>
<ul>
<li>中序遍历（根节点在中间）<ul>
<li>中序遍历其左子树</li>
<li>访问根结点</li>
<li>中序遍历其右子树</li>
</ul>
</li>
</ul>
<p><img src="./03.png" alt="中序遍历"></p>
<ul>
<li>后序遍历（根节点在最后）<ul>
<li>后序遍历其左子树</li>
<li>后序遍历其右子树</li>
<li>访问根结点</li>
</ul>
</li>
</ul>
<p><img src="./04.png" alt="后序遍历"></p>
<h2 id="二叉搜索树的操作"><a href="#二叉搜索树的操作" class="headerlink" title="二叉搜索树的操作"></a>二叉搜索树的操作</h2><ul>
<li>insert(key)：向树中插入一个新的键。</li>
<li>search(key)：在树中查找一个键，如果结点存在，则返回true；如果不存在，则返回false。</li>
<li>inOrderTraverse：通过中序遍历方式遍历所有结点。</li>
<li>preOrderTraverse：通过先序遍历方式遍历所有结点。</li>
<li>postOrderTraverse：通过后序遍历方式遍历所有结点。</li>
<li>min：返回树中最小的值/键。</li>
<li>max：返回树中最大的值/键。</li>
<li>remove(key)：从树中移除某个键</li>
</ul>
<h1 id="二叉搜索树的实现"><a href="#二叉搜索树的实现" class="headerlink" title="二叉搜索树的实现"></a>二叉搜索树的实现</h1><h2 id="创建二叉搜索树"><a href="#创建二叉搜索树" class="headerlink" title="创建二叉搜索树"></a>创建二叉搜索树</h2><p>先来封装一个BinarySearchTree的类</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建BinarySearchTree</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BinarySerachTree</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建结点构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key</span><br><span class="line">        <span class="keyword">this</span>.left = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">this</span>.right = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存根的属性</span></span><br><span class="line">    <span class="keyword">this</span>.root = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="向树中插入数据"><a href="#向树中插入数据" class="headerlink" title="向树中插入数据"></a>向树中插入数据</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向树中插入数据</span></span><br><span class="line">BinarySerachTree.prototype.insert = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.根据key创建对应的node</span></span><br><span class="line">    <span class="keyword">var</span> newNode = <span class="keyword">new</span> Node(key)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.判断根节点是否有值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.root === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.root = newNode</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.insertNode(<span class="keyword">this</span>.root, newNode)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入时用递归函数，直到遇到一个为null的节点</span></span><br><span class="line">BinarySerachTree.prototype.insertNode = <span class="function"><span class="keyword">function</span> (<span class="params">node, newNode</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (newNode.key &lt; node.key) &#123; <span class="comment">// 1.准备向左子树插入数据</span></span><br><span class="line">        <span class="keyword">if</span> (node.left === <span class="literal">null</span>) &#123; <span class="comment">// 1.1.node的左子树上没有内容</span></span><br><span class="line">            node.left = newNode</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 1.2.node的左子树上已经有了内容</span></span><br><span class="line">            <span class="keyword">this</span>.insertNode(node.left, newNode)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 2.准备向右子树插入数据</span></span><br><span class="line">        <span class="keyword">if</span> (node.right === <span class="literal">null</span>) &#123; <span class="comment">// 2.1.node的右子树上没有内容</span></span><br><span class="line">            node.right = newNode</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 2.2.node的右子树上有内容</span></span><br><span class="line">            <span class="keyword">this</span>.insertNode(node.right, newNode)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>*按照下面的代码插入, 最后形成什么样的树</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">var</span> bst = <span class="keyword">new</span> BinarySerachTree()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入数据</span></span><br><span class="line">bst.insert(<span class="number">11</span>)</span><br><span class="line">bst.insert(<span class="number">7</span>)</span><br><span class="line">bst.insert(<span class="number">15</span>)</span><br><span class="line">bst.insert(<span class="number">5</span>)</span><br><span class="line">bst.insert(<span class="number">3</span>)</span><br><span class="line">bst.insert(<span class="number">9</span>)</span><br><span class="line">bst.insert(<span class="number">8</span>)</span><br><span class="line">bst.insert(<span class="number">10</span>)</span><br><span class="line">bst.insert(<span class="number">13</span>)</span><br><span class="line">bst.insert(<span class="number">12</span>)</span><br><span class="line">bst.insert(<span class="number">14</span>)</span><br><span class="line">bst.insert(<span class="number">20</span>)</span><br><span class="line">bst.insert(<span class="number">18</span>)</span><br><span class="line">bst.insert(<span class="number">25</span>)</span><br></pre></td></tr></table></figure>

<p><img src="./05.png" alt="测试"></p>
<ul>
<li>如果这个时候, 我新插入一个数据6,</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">bst.insert(<span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<p><img src="./06.png" alt="测试2"></p>
<h2 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h2><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><ul>
<li>遍历树最好用的办法就是递归, 因为每个节点都可能有自己的子节点, 所以递归调用是最好的方式.</li>
<li>在先序遍历中, 我们在经过节点的时候, 会先将该节点打印出来.</li>
<li>然后, 我们会遍历节点的左子树, 再然后遍历节点的右子树.</li>
<li>handler处理遍历出来节点的函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历方法</span></span><br><span class="line"><span class="comment">// 先序遍历 handler是一个回调方法</span></span><br><span class="line">BinarySerachTree.prototype.preOrderTraversal = <span class="function"><span class="keyword">function</span> (<span class="params">handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.preOrderTranversalNode(<span class="keyword">this</span>.root, handler)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归调用</span></span><br><span class="line">BinarySerachTree.prototype.preOrderTranversalNode = <span class="function"><span class="keyword">function</span> (<span class="params">node, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 返回处理结果的节点</span></span><br><span class="line">        handler(node.key)</span><br><span class="line">        <span class="comment">// 递归调用左侧节点</span></span><br><span class="line">        <span class="keyword">this</span>.preOrderTranversalNode(node.left, handler)</span><br><span class="line">        <span class="comment">// 递归调用右侧节点</span></span><br><span class="line">        <span class="keyword">this</span>.preOrderTranversalNode(node.right, handler)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="./07.png" alt="先序遍历"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试前序遍历结果</span></span><br><span class="line"><span class="keyword">var</span> resultString = <span class="string">""</span></span><br><span class="line">bst.preOrderTraversal(<span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">   resultString += key + <span class="string">" "</span></span><br><span class="line">&#125;)</span><br><span class="line">alert(resultString) <span class="comment">// 11 7 5 3 6 9 8 10 15 13 12 14 20 18 25</span></span><br></pre></td></tr></table></figure>

<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line">BinarySerachTree.prototype.inOrderTraversal = <span class="function"><span class="keyword">function</span> (<span class="params">handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.inOrderTraversalNode(<span class="keyword">this</span>.root, handler)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归调用</span></span><br><span class="line">BinarySerachTree.prototype.inOrderTraversalNode = <span class="function"><span class="keyword">function</span> (<span class="params">node, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.inOrderTraversalNode(node.left, handler)</span><br><span class="line">        handler(node.key)</span><br><span class="line">        <span class="keyword">this</span>.inOrderTraversalNode(node.right, handler)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="./08.png" alt="中序遍历"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试中序遍历结果</span></span><br><span class="line">resultString = <span class="string">""</span></span><br><span class="line">bst.inOrderTraversal(<span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    resultString += key + <span class="string">" "</span></span><br><span class="line">&#125;)</span><br><span class="line">alert(resultString) <span class="comment">// 3 5 6 7 8 9 10 11 12 13 14 15 18 20 25</span></span><br></pre></td></tr></table></figure>

<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line">BinarySerachTree.prototype.postOrderTraversal = <span class="function"><span class="keyword">function</span> (<span class="params">handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.postOrderTraversalNode(<span class="keyword">this</span>.root, handler)</span><br><span class="line">&#125;</span><br><span class="line">BinarySerachTree.prototype.postOrderTraversalNode = <span class="function"><span class="keyword">function</span> (<span class="params">node, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.postOrderTraversalNode(node.left, handler)</span><br><span class="line">        <span class="keyword">this</span>.postOrderTraversalNode(node.right, handler)</span><br><span class="line">        handler(node.key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="./09.png" alt="后序遍历"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试后续遍历结果</span></span><br><span class="line">resultString = <span class="string">""</span></span><br><span class="line">bst.postOrderTraversal(<span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">   resultString += key + <span class="string">" "</span></span><br><span class="line">&#125;)</span><br><span class="line">alert(resultString) <span class="comment">// 3 6 5 8 10 9 7 12 14 13 18 25 20 15 11</span></span><br></pre></td></tr></table></figure>

<h2 id="最大值和最小值"><a href="#最大值和最小值" class="headerlink" title="最大值和最小值"></a>最大值和最小值</h2><ul>
<li>代码依次向左找到最左边的结点就是最小值,</li>
<li>代码依次向右找到最右边的结点就是最大值.</li>
</ul>
<p><img src="./10.png" alt="最大值和最小值"></p>
<ul>
<li>获取最小值</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取最大值和最小值（一直沿着二叉树往左找，最左面的值）</span></span><br><span class="line">BinarySerachTree.prototype.min = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="keyword">this</span>.root</span><br><span class="line">    <span class="keyword">while</span> (node.left !== <span class="literal">null</span>) &#123;</span><br><span class="line">        node = node.left</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.key</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取最大值</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// （一直沿着二叉树往右找，最右面的值）</span></span><br><span class="line">BinarySerachTree.prototype.max = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="keyword">this</span>.root</span><br><span class="line">    <span class="keyword">while</span> (node.right !== <span class="literal">null</span>) &#123;</span><br><span class="line">        node = node.right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.key</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="搜索是否存在特定的值"><a href="#搜索是否存在特定的值" class="headerlink" title="搜索是否存在特定的值"></a>搜索是否存在特定的值</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">BinarySerachTree.prototype.search = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="keyword">this</span>.root</span><br><span class="line">    <span class="keyword">while</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.key &gt; key) &#123; <span class="comment">// key小于node时向左循环</span></span><br><span class="line">            node = node.left</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.key &lt; key) &#123; <span class="comment">// key大于node时向右循环</span></span><br><span class="line">            node = node.right</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// key等于node时，找到了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环之后也没有找到返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><ul>
<li>删除节点要从查找要删的节点开始, 找到节点后, 需要考虑三种情况:<ul>
<li>该节点是也结点(没有字节点, 比较简单)</li>
<li>该节点有一个子节点(也相对简单)</li>
<li>该节点有两个子节点.(情况比较复杂)</li>
</ul>
</li>
</ul>
<h3 id="查找要删除的节点"><a href="#查找要删除的节点" class="headerlink" title="查找要删除的节点"></a>查找要删除的节点</h3><ul>
<li>current: 用于一会儿找到的要删除的节点对应的node.</li>
<li>parent: 用于保存current节点的父节点. 因为如果current有子节点, 那么在删除current节点的时候, 必然需要将parent的left或者right指向它的某一个子节点. 所以需要保存起来current的parent. (树中的节点关系不能向上的, 和链表非常相似)</li>
<li>isLeftChild: boolean类型,它用户记录我们是在current是在父节点的左侧还是右侧, 以便到时候设置parent的left或者right</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除结点</span></span><br><span class="line">BinarySerachTree.prototype.remove = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.定义临时保存的变量</span></span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span>.root <span class="comment">// 需要删除的节点</span></span><br><span class="line">    <span class="keyword">var</span> parent = <span class="keyword">this</span>.root <span class="comment">// 需要删除节点的根节点</span></span><br><span class="line">    <span class="keyword">var</span> isLeftChild = <span class="literal">true</span> <span class="comment">// 判断删除的时根节点的左孩子还是右孩子</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.开始查找节点</span></span><br><span class="line">    <span class="keyword">while</span> (current.key !== key) &#123; <span class="comment">// 只要key不相等就是没找到就一直循环查找</span></span><br><span class="line">        parent = current <span class="comment">// 上一次循环的节点作为这次循环的根节点</span></span><br><span class="line">        <span class="keyword">if</span> (key &lt; current.key) &#123; <span class="comment">//向左继续查找</span></span><br><span class="line">            isLeftChild = <span class="literal">true</span></span><br><span class="line">            current = current.left</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 向右查找</span></span><br><span class="line">            isLeftChild = <span class="literal">false</span></span><br><span class="line">            current = current.right</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果发现current已经指向null, 那么说明没有找到要删除的数据（因为叶子节点的left和right都是null）</span></span><br><span class="line">        <span class="keyword">if</span> (current === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 证明删除成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除的是叶子节点"><a href="#删除的是叶子节点" class="headerlink" title="删除的是叶子节点"></a>删除的是叶子节点</h3><ul>
<li>需要检测current的left以及right是否都为null.</li>
<li>是否current就是根, 都为null, 并且为跟根, 那么相当于要清空二叉树(只是清空了根, 因为只有它).</li>
</ul>
<p><img src="./11.png" alt="删除的是叶子节点"></p>
<ul>
<li>否则就把父节点的left或者right字段设置为null即可</li>
</ul>
<p><img src="./12.png" alt="删除的是叶子节点2"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.删除的结点是叶结点（直接给这个系欸但的）</span></span><br><span class="line"><span class="keyword">if</span> (current.left === <span class="literal">null</span> &amp;&amp; current.right === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="keyword">this</span>.root) &#123; <span class="comment">// 如果删除的是根节点，直接让root=null</span></span><br><span class="line">        <span class="keyword">this</span>.root == <span class="literal">null</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123; <span class="comment">// 如果这个节点是左节点，就给父节点的left设置为null</span></span><br><span class="line">        parent.left = <span class="literal">null</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果这个节点是左右点，就给父节点的right设置为null</span></span><br><span class="line">        parent.right = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一个子节点"><a href="#一个子节点" class="headerlink" title="一个子节点"></a>一个子节点</h3><ul>
<li>要删除的current结点, 只有2个连接(如果有两个子结点, 就是三个连接了), 一个连接父节点, 一个连接唯一的子节点.</li>
<li>需要从这三者之间: 爷爷 - 自己 - 儿子, 将自己(current)剪短, 让爷爷直接连接儿子即可.</li>
<li>这个过程要求改变父节点的left或者right, 指向要删除节点的子节点.</li>
<li>在这个过程中还要考虑是否current就是根.</li>
</ul>
<p><img src="./13.png" alt="删除的是叶子节点2"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4.删除有一个子节点的节点</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (current.right === <span class="literal">null</span>) &#123; <span class="comment">// 删除节点右节点为null，则把这个节点的左子节点挂到父节点上</span></span><br><span class="line">    <span class="keyword">if</span> (current == <span class="keyword">this</span>.root) &#123; <span class="comment">// 如果是根节点，直接给根节点挂上孙子节点</span></span><br><span class="line">        <span class="keyword">this</span>.root = current.left</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123; <span class="comment">// 如果这个节点是左节点就给父节点的左节点挂上孙子节点</span></span><br><span class="line">        parent.left = current.left</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果这个节点是右节点就给父节点的右节点挂上孙子节点</span></span><br><span class="line">        parent.right = current.left</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.left === <span class="literal">null</span>) &#123; <span class="comment">// 删除节点左节点为null，则把这个节点的右子节点挂到父节点上</span></span><br><span class="line">    <span class="keyword">if</span> (current == <span class="keyword">this</span>.root) &#123;<span class="comment">// 如果是根节点，直接给根节点挂上孙子节点</span></span><br><span class="line">        <span class="keyword">this</span>.root = current.right</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123; <span class="comment">// 如果这个节点是左节点就给父节点的左节点挂上孙子节点</span></span><br><span class="line">        parent.left = current.right</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果这个节点是右节点就给父节点的右节点挂上孙子节点</span></span><br><span class="line">        parent.right = current.right</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="两个子节点"><a href="#两个子节点" class="headerlink" title="两个子节点"></a>两个子节点</h3><p><img src="./14.png" alt="两个子节点"></p>
<ul>
<li>如果我们要删除的节点有两个子节点, 甚至子节点还有子节点, 这种情况下我们需要从下面的子节点中找到一个节点, 来替换当前的节点.</li>
<li>但是找到的这个节点有什么特征呢? 应该是current节点下面所有节点中最接近current节点的.<ul>
<li>要么比current节点小一点点, 要么比current节点大一点点.</li>
<li>总结你最接近current, 你就可以用来替换current的位置.</li>
</ul>
</li>
<li>这个节点怎么找呢<ul>
<li>比current小一点点的节点, 一定是current左子树的最大值.</li>
<li>比current大一点点的节点, 一定是current右子树的最小值.</li>
</ul>
</li>
<li>前驱&amp;后继<ul>
<li>比current小一点点的节点, 称为current节点的前驱.</li>
<li>比current大一点点的节点, 称为current节点的后继.</li>
</ul>
</li>
<li>也就是为了能够删除有两个子节点的current, 要么找到它的前驱, 要么找到它的后继</li>
<li>这里以找后继为例</li>
</ul>
<h4 id="找后继方法"><a href="#找后继方法" class="headerlink" title="找后继方法"></a>找后继方法</h4><ul>
<li>对于删除9. 做法就是将7节点的right 赋值为 10. 10节点的left应该赋值为8即可.</li>
<li>对于删除15我们还缺少什么呢?<ul>
<li>已经完成: 11的right指向了18, 18的right指向了13.</li>
<li>没有完成: 19怎么办? 20这个左子树怎么办?</li>
<li>很明显, 19应该放在20的左边, 20应该放在18的右边.</li>
<li>19放在20的左边代码: successorParent.left = successor.right</li>
<li>20放在18的右边代码: successor.right = delNode.right</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找后继的方法</span></span><br><span class="line">BinarySerachTree.prototype.getSuccessor = <span class="function"><span class="keyword">function</span> (<span class="params">delNode</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.使用变量保存临时的节点</span></span><br><span class="line">    <span class="keyword">var</span> successorParent = delNode</span><br><span class="line">    <span class="keyword">var</span> successor = delNode <span class="comment">// 后继节点的父节点</span></span><br><span class="line">    <span class="keyword">var</span> current = delNode.right <span class="comment">// 要从右子树开始找</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.寻找节点（右子树最左面的节点）</span></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123; <span class="comment">// 只要节点有值就一直取左侧</span></span><br><span class="line">        successorParent = successor</span><br><span class="line">        successor = current</span><br><span class="line">        current = current.left</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.如果是删除图中15的情况, 还需要如下代码（判断寻找到的后继节点是否直接就是delNode的right节点）</span></span><br><span class="line">    <span class="comment">// 处理后继节点上的节点</span></span><br><span class="line">    <span class="keyword">if</span> (successor != delNode.right) &#123;</span><br><span class="line">        successorParent.left = successor.right</span><br><span class="line">        successor.right = delNode.right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> successor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="找到后继节点后"><a href="#找到后继节点后" class="headerlink" title="找到后继节点后"></a>找到后继节点后</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 5.删除有两个节点的节点</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取后继节点</span></span><br><span class="line">    <span class="keyword">var</span> successor = <span class="keyword">this</span>.getSuccessor(current)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.判断是否是根节点</span></span><br><span class="line">    <span class="keyword">if</span> (current == <span class="keyword">this</span>.root) &#123;</span><br><span class="line">        <span class="keyword">this</span>.root = successor</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">        parent.left = successor</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent.right = successor</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.将删除节点的左子树赋值给successor（右子树找前驱）</span></span><br><span class="line">    successor.left = current.left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>双向链表</title>
    <url>/2020/06/26/01%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/01%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/01%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/05%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="链表与双向链表"><a href="#链表与双向链表" class="headerlink" title="链表与双向链表"></a>链表与双向链表</h1><h2 id="链表的缺点"><a href="#链表的缺点" class="headerlink" title="链表的缺点"></a>链表的缺点</h2><ul>
<li>只能从头遍历到尾</li>
<li>可以轻松的到达下一个节点, 但是回到钱一个节点是很难的</li>
</ul>
<h2 id="双向链表优点"><a href="#双向链表优点" class="headerlink" title="双向链表优点"></a>双向链表优点</h2><ul>
<li>既可以从头遍历到尾, 又可以从尾遍历到头</li>
<li>一个节点既有向前连接的引用, 也有一个向后连接的引用</li>
</ul>
<h2 id="双向列表缺点"><a href="#双向列表缺点" class="headerlink" title="双向列表缺点"></a>双向列表缺点</h2><ul>
<li>每次在插入或删除某个节点时, 需要处理四个节点的引用, 而不是两个</li>
<li>相当于单向链表, 必然占用内存空间更大一些</li>
</ul>
<h2 id="图解双向链表"><a href="#图解双向链表" class="headerlink" title="图解双向链表"></a>图解双向链表</h2><p><img src="./01.png" alt="图解双向链表"></p>
<h1 id="双向链表的封装"><a href="#双向链表的封装" class="headerlink" title="双向链表的封装"></a>双向链表的封装</h1><h2 id="创建双向链表类"><a href="#创建双向链表类" class="headerlink" title="创建双向链表类"></a>创建双向链表类</h2><ul>
<li>基本思路和单向链表比较相似, 都是创建节点结构函数以及定义一些属性和方法.</li>
<li>只是Node中添加了一个this.prev属性, 该属性用于指向上一个节点.</li>
<li>另外属性中添加了一个this.tail属性, 该属性指向末尾的节点</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建双向链表的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DoublyLinkedList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建节点构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span> <span class="comment">// 下一节点</span></span><br><span class="line">        <span class="keyword">this</span>.prev = <span class="literal">null</span> <span class="comment">// 上一节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义属性</span></span><br><span class="line">    <span class="keyword">this</span>.length = <span class="number">0</span> <span class="comment">// 双向列表长度</span></span><br><span class="line">    <span class="keyword">this</span>.head = <span class="literal">null</span> <span class="comment">// 头部</span></span><br><span class="line">    <span class="keyword">this</span>.tail = <span class="literal">null</span> <span class="comment">// 尾部</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="尾部添加数据"><a href="#尾部添加数据" class="headerlink" title="尾部添加数据"></a>尾部添加数据</h2><ul>
<li>链表原来为空<ul>
<li>链表中原来如果没有数据, 那么直接让head和tail指向这个新的节点即可</li>
</ul>
</li>
<li>链表中已经存在数据<ul>
<li>首先tail中的next之前指向的是null. 现在应该指向新的节点newNode: this.tail.next = newNode</li>
<li>因为是双向链表, 新节点的next/tail目前都是null. 但是作为最后一个节点, 需要有一个指向前一个节点的引用. 所以这里我们需要newNode.prev = this.tail</li>
<li>因为目前newNod已经变成了最后的节点, 所以this.tail属性的引用应该指向最后: this.tail = newNode即可</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在尾部追加数据</span></span><br><span class="line">DoublyLinkedList.prototype.append = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.根据元素创建节点</span></span><br><span class="line">    <span class="keyword">var</span> newNode = <span class="keyword">new</span> Node(element)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.判断列表是否为空列表</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.head = newNode <span class="comment">// 头指向这个节点</span></span><br><span class="line">        <span class="keyword">this</span>.tail = newNode<span class="comment">// 尾也指向这个系欸但</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.tail.next = newNode <span class="comment">// 原来双向链表的尾部指向这个新节点</span></span><br><span class="line">        newNode.prev = <span class="keyword">this</span>.tail <span class="comment">// 新节点的上一级节点指向之前的尾部节点</span></span><br><span class="line">        <span class="keyword">this</span>.tail = newNode <span class="comment">// 新节点成为这个双向连的尾部节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.length+1</span></span><br><span class="line">    <span class="keyword">this</span>.length++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="遍历和toString方法"><a href="#遍历和toString方法" class="headerlink" title="遍历和toString方法"></a>遍历和toString方法</h2><h3 id="正向遍历"><a href="#正向遍历" class="headerlink" title="正向遍历"></a>正向遍历</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正向遍历的方法</span></span><br><span class="line">DoublyLinkedList.prototype.forwardString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="keyword">var</span> forwardStr = <span class="string">""</span></span><br><span class="line">    <span class="comment">// 通过next向后遍历</span></span><br><span class="line">    <span class="keyword">while</span> (current) &#123;</span><br><span class="line">        forwardStr += <span class="string">","</span> + current.element</span><br><span class="line">        current = current.next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> forwardStr.slice(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反向遍历"><a href="#反向遍历" class="headerlink" title="反向遍历"></a>反向遍历</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反向遍历的方法</span></span><br><span class="line">DoublyLinkedList.prototype.reverseString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span>.tail</span><br><span class="line">    <span class="keyword">var</span> reverseStr = <span class="string">""</span></span><br><span class="line">    <span class="comment">// 通过prev向前遍历</span></span><br><span class="line">    <span class="keyword">while</span> (current) &#123;</span><br><span class="line">        reverseStr += <span class="string">","</span> + current.element</span><br><span class="line">        current = current.prev</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> reverseStr.slice(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h3><p>直接调用正向遍历方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现toString方法</span></span><br><span class="line">DoublyLinkedList.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 调用正向遍历方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.forwardString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在指定位置插入数据"><a href="#在指定位置插入数据" class="headerlink" title="在指定位置插入数据"></a>在指定位置插入数据</h2><ul>
<li>将元素插入到头部(position === 0)<ul>
<li>列表为空. 那么直接让head/tail指向newNode即可</li>
<li>列表不为空, 这个时候需要修改原来head的prev指向新节点. 新节点的next指向原来的head. 并且head现在要指向newNode</li>
</ul>
</li>
</ul>
<p><img src="./02.png" alt="插入到头"></p>
<ul>
<li>将元素插入到尾部(position === length)</li>
</ul>
<p><img src="./03.png" alt="插入到尾部"></p>
<ul>
<li>将元素插入到中间位置<ul>
<li>循环到指定位置</li>
<li>newNode的next/prev必然要指向前后的节点, 也就是current和previous</li>
<li>而current的prev需要指向newNode, 而previous的next需要指向newNode</li>
</ul>
</li>
</ul>
<p><img src="./04.png" alt="插入到中间"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在指定位置插入数据</span></span><br><span class="line">DoublyLinkedList.prototype.insert = <span class="function"><span class="keyword">function</span> (<span class="params">position, element</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.判断越界的问题</span></span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt; <span class="keyword">this</span>.length) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建新的节点</span></span><br><span class="line">    <span class="keyword">var</span> newNode = <span class="keyword">new</span> Node(element)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.判断插入的位置</span></span><br><span class="line">    <span class="keyword">if</span> (position === <span class="number">0</span>) &#123; <span class="comment">// 在第一个位置插入数据</span></span><br><span class="line">        <span class="comment">// 判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.head = newNode</span><br><span class="line">            <span class="keyword">this</span>.tail = newNode</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.head.prev = newNode <span class="comment">// 之前的第一个数据的上个节点指向newNode</span></span><br><span class="line">            newNode.next = <span class="keyword">this</span>.head<span class="comment">// newNode的下一个节点指向之前的头节点</span></span><br><span class="line">            <span class="keyword">this</span>.head = newNode<span class="comment">// 更新头节点为这个新的节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position === <span class="keyword">this</span>.length) &#123; <span class="comment">// 插入到最后的情况</span></span><br><span class="line">        <span class="comment">// 思考: 这种情况是否需要判断链表为空的情况呢? 答案是不需要, 为什么?空的话position必须是0否则上面就越界了</span></span><br><span class="line">        <span class="keyword">this</span>.tail.next = newNode</span><br><span class="line">        newNode.prev = <span class="keyword">this</span>.tail</span><br><span class="line">        <span class="keyword">this</span>.tail = newNode</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 在中间位置插入数据</span></span><br><span class="line">        <span class="comment">// 定义属性</span></span><br><span class="line">        <span class="keyword">var</span> index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> current = <span class="keyword">this</span>.head</span><br><span class="line">        <span class="keyword">var</span> previous = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找正确的位置</span></span><br><span class="line">        <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">            previous = current</span><br><span class="line">            current = current.next</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换节点的指向顺序</span></span><br><span class="line">        newNode.next = current</span><br><span class="line">        newNode.prev = previous</span><br><span class="line">        current.prev = newNode</span><br><span class="line">        previous.next = newNode</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.length+1</span></span><br><span class="line">    <span class="keyword">this</span>.length++</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="根据位置获取节点"><a href="#根据位置获取节点" class="headerlink" title="根据位置获取节点"></a>根据位置获取节点</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据位置获取节点</span></span><br><span class="line">DoublyLinkedList.prototype.get = <span class="function"><span class="keyword">function</span> (<span class="params">position</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.检测越界问题: 越界移除失败, 返回null</span></span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="keyword">this</span>.length) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.定义变量, 保存信息</span></span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 循环到要获取的位置</span></span><br><span class="line">    <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">        current = current.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.返回获取的数据</span></span><br><span class="line">    <span class="keyword">return</span> current.element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="根据位置删除对应的元素"><a href="#根据位置删除对应的元素" class="headerlink" title="根据位置删除对应的元素"></a>根据位置删除对应的元素</h2><ul>
<li>删除头部的元素<ul>
<li>链表只有一个元素, 那么将head/tail直接设置为null即可</li>
<li>链表有多个元素, 这个时候删除头部的元素. head = head.next. head.prev = null</li>
</ul>
</li>
</ul>
<p><img src="./05.png" alt="删除头部的元素"></p>
<ul>
<li>删除尾部的元素</li>
</ul>
<p><img src="./06.png" alt="删除尾部的元素"></p>
<ul>
<li>删除中间位置的元素<ul>
<li>先找到正确的位置, 还是使用while循环</li>
<li>将previous的next直接设置成current的next, 将current.next的prev设置成previous即可</li>
</ul>
</li>
</ul>
<p><img src="./07.png" alt="删除中间的元素"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据位置删除对应的元素</span></span><br><span class="line">DoublyLinkedList.prototype.removeAt = <span class="function"><span class="keyword">function</span> (<span class="params">position</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.判断越界的问题</span></span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="keyword">this</span>.length) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.判断移除的位置</span></span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.head = <span class="literal">null</span></span><br><span class="line">            <span class="keyword">this</span>.tail = <span class="literal">null</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.head = <span class="keyword">this</span>.head.next</span><br><span class="line">            <span class="keyword">this</span>.head.prev = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position === <span class="keyword">this</span>.length <span class="number">-1</span>) &#123;</span><br><span class="line">        current = <span class="keyword">this</span>.tail</span><br><span class="line">        <span class="keyword">this</span>.tail = <span class="keyword">this</span>.tail.prev</span><br><span class="line">        <span class="keyword">this</span>.tail.next = <span class="literal">null</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> previous = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">            previous = current</span><br><span class="line">            current = current.next</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        previous.next = current.next</span><br><span class="line">        current.next.prev = previous</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.length-1</span></span><br><span class="line">    <span class="keyword">this</span>.length--</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> current.element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="根据元素获取在链表中的位置"><a href="#根据元素获取在链表中的位置" class="headerlink" title="根据元素获取在链表中的位置"></a>根据元素获取在链表中的位置</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据元素获取在链表中的位置</span></span><br><span class="line">DoublyLinkedList.prototype.indexOf = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.定义变量保存信息</span></span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.查找正确的信息</span></span><br><span class="line">    <span class="keyword">while</span> (current) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current.element === element) &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">        index++</span><br><span class="line">        current = current.next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.来到这个位置, 说明没有找到, 则返回-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="根据位置修改节点"><a href="#根据位置修改节点" class="headerlink" title="根据位置修改节点"></a>根据位置修改节点</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据位置修改节点</span></span><br><span class="line">DoublyLinkedList.prototype.update = <span class="function"><span class="keyword">function</span> (<span class="params">position, newData</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.检测越界问题: 越界移除失败, 返回null</span></span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="keyword">this</span>.length) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.定义变量, 保存信息</span></span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 循环到要获取的位置</span></span><br><span class="line">    <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">        current = current.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改节点</span></span><br><span class="line">    current.element = newData;</span><br><span class="line">    <span class="comment">// 5.返回成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="根据元素删除"><a href="#根据元素删除" class="headerlink" title="根据元素删除"></a>根据元素删除</h2><ul>
<li>利用indexOf方法获取元素位置</li>
<li>利用removeAt方法删除该位置的元素</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">DoublyLinkedList.prototype.remove = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> index = <span class="keyword">this</span>.indexOf(element)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.removeAt(index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断是否为空"><a href="#判断是否为空" class="headerlink" title="判断是否为空"></a>判断是否为空</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">DoublyLinkedList.prototype.isEmpty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length === <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取链表长度"><a href="#获取链表长度" class="headerlink" title="获取链表长度"></a>获取链表长度</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取链表长度</span></span><br><span class="line">DoublyLinkedList.prototype.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取第一个元素"><a href="#获取第一个元素" class="headerlink" title="获取第一个元素"></a>获取第一个元素</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取第一个元素</span></span><br><span class="line">DoublyLinkedList.prototype.getHead = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.head.element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取最后一个元素"><a href="#获取最后一个元素" class="headerlink" title="获取最后一个元素"></a>获取最后一个元素</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取最后一个元素</span></span><br><span class="line">DoublyLinkedList.prototype.getTail = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.tail.element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>哈希表理论</title>
    <url>/2020/06/27/01%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/01%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/02%E5%93%88%E5%B8%8C%E8%A1%A8/01%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="认识哈希表"><a href="#认识哈希表" class="headerlink" title="认识哈希表"></a>认识哈希表</h1><h2 id="哈希表特点"><a href="#哈希表特点" class="headerlink" title="哈希表特点"></a>哈希表特点</h2><ul>
<li><p>优点</p>
<ul>
<li>哈希表通常是基于数组进行实现的, 但是相对于数组, 它也很多的优势</li>
<li>可以提供非常快速的插入-删除-查找操作</li>
<li>无论多少数据, 插入和删除值需要接近常量的时间</li>
<li>哈希表的速度比树还要快, 基本可以瞬间查找到想要的元素</li>
<li>哈希表相对于树来说编码要容易很多</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>哈希表中的数据是没有顺序的, 所以不能以一种固定的方式(比如从小到大)来遍历其中的元素</li>
<li>通常情况下, 哈希表中的key是不允许重复的, 不能放置相同的key, 用于保存不同的元素</li>
</ul>
</li>
<li><p>总结特点</p>
<ul>
<li>基于数组进行实现的</li>
<li>提供非常快速的插入，删除，查找操作</li>
<li>无论多少数据，插入和删除是O(1)时间级</li>
<li>key不允许重复</li>
<li>空间利用率不高, 底层使用的是数组, 并且某些单元是没有被利用的</li>
<li>哈希表中的元素是无序的, 不能按照固定的顺序来遍历哈希表中的元素</li>
<li>不能快速的找出哈希表中的最大值或者最小值这些特殊的值.</li>
</ul>
</li>
</ul>
<blockquote>
<p>它的结构就是数组, 但是它神奇的地方在于对下标值的一种变换, 这种变换我们可以称之为哈希函数, 通过哈希函数可以获取到HashCode.</p>
</blockquote>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><ul>
<li><p>内容介绍：</p>
<ul>
<li>假如一家公司有1000个员工, 现在我们需要将这些员工的信息使用某种数据结构来保存起来</li>
</ul>
</li>
<li><p>方案一:数组</p>
<ul>
<li>员工依次存入一个长度为1000的数组中. 每个员工的信息都保存在数组的某个位置上</li>
<li>通过编号易于查找(数组的特性)</li>
<li>通过姓名查找时消耗大(需要循环匹配判断是否相等)</li>
<li>插入删除消耗大(需要移动插入或删除位置后面的所有元素)</li>
</ul>
</li>
<li><p>方案二:链表</p>
<ul>
<li>链表对应插入和删除数据有一定的优势</li>
<li>但是对于获取员工的信息, 每次都必须从头遍历到尾</li>
</ul>
</li>
<li><p>思考</p>
<ul>
<li>这样看最终方案似乎就是数组了</li>
<li>假如我想查看一下张三这位员工的信息, 但是我不知道张三的员工编号, 怎么办?</li>
<li>能不能有一种办法, 让张三的名字和它的员工编号产生直接的关系呢</li>
<li>也就是通过张三这个名字, 我就能获取到它的索引值, 而再通过索引值我就能获取到张三的信息</li>
</ul>
</li>
</ul>
<h2 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h2><ul>
<li><p>内容介绍</p>
<ul>
<li>使用一种数据结构存储单词信息, 比如有50000个单词. 找到单词后每个单词有自己的翻译&amp;读音&amp;应用等等</li>
</ul>
</li>
<li><p>方案一: 数组</p>
<ul>
<li>我拿到一个单词Python, 我想知道这个单词的翻译/读音/应用. 怎么可以从数组中查到这个单词的位置呢？</li>
<li>线性查找? 50000次比较?</li>
<li>使用数组来实现这个功能, 效率会非常非常低</li>
</ul>
</li>
<li><p>方案二: 链表</p>
<ul>
<li>和数组面临同样的问题</li>
</ul>
</li>
<li><p>思考</p>
<ul>
<li>如果单词转成数组的下标, 那么以后我们要查找某个单词的信息, 直接按照下标值一步即可访问到想要的元素.</li>
</ul>
</li>
</ul>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="设定编码"><a href="#设定编码" class="headerlink" title="设定编码"></a>设定编码</h3><ul>
<li>其实计算机中有很多的编码方案就是用数字代替单词的字符.</li>
<li>比如ASCII编码: a是97, b是98, 依次类推122代表z</li>
<li>我们也可以设计一个自己的编码系统, 比如a是1, b是2, c是3, 依次类推, z是26. 当然我们可以加上空格用0代替, 就是27个字符(不考虑大写问题)</li>
</ul>
<h3 id="字母转换成数组"><a href="#字母转换成数组" class="headerlink" title="字母转换成数组"></a>字母转换成数组</h3><p>但是, 有了编码系统后, 一个单词如何转成数字呢?</p>
<ul>
<li><p>方案一: 数字相加</p>
<ul>
<li>例如单词cats转成数字: 3+1+20+19=43, 那么43就作为cats单词的下标存在数组中.</li>
<li>比如was/tin/give/tend/moan/tick等，很多单词最终的下标可能都是43</li>
<li>数组中一个下标值位置只能存储一个数据, 如果存入后来的数据, 必然会造成数据的覆盖.</li>
</ul>
</li>
<li><p>方案二: 幂的连乘</p>
<ul>
<li>大于10的数字, 可以用一种幂的连乘来表示它的唯一性:比如: 7654 = 7<em>10³+6</em>10²+5*10+4</li>
<li>单词也可以使用这种方案来表示: 比如cats = 3 * 27³ + 1 * 27² + 20 * 27 + 17 = 60337  (因为一共是26字母+0空格)</li>
<li>得到的数字可以几乎保证它的唯一性, 不会和别的单词重复.</li>
<li>如果一个单词是zzzzzzzzzz. 那么得到的数字超过7000000000000.<ul>
<li>数组可以表示这么大的下标值吗</li>
<li>而且就算能创建这么大的数组, 事实上有很多是无效的单词. 创建这么大的数组是没有意义的</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="./01.png" alt="幂的连乘"></p>
<ul>
<li>总结:<ul>
<li>第一种方案(把数字相加求和)产生的数组下标太少.</li>
<li>第二种方案(与27的幂相乘求和)产生的数组下标又太多.</li>
</ul>
</li>
</ul>
<h3 id="压缩-哈希化"><a href="#压缩-哈希化" class="headerlink" title="压缩(哈希化)"></a>压缩(哈希化)</h3><p>现在需要一种压缩方法, 把幂的连乘方案系统中得到的巨大整数范围压缩到可接受的数组范围中.</p>
<ul>
<li>方法<ul>
<li>假设把从0~199的数字, 比如使用largeNumber代表, 压缩为从0到9的数字, 比如使用smallRange代表.</li>
<li>下标值的结果: index = largeNumber % smallRange;</li>
<li>当一个数被10整除时, 余数一定在0~9之间;</li>
<li>比如13%10=3, 157%10=7</li>
</ul>
</li>
<li>相关概念<ul>
<li>哈希化: 将大数字转化成数组范围内下标的过程, 我们就称之为哈希化.</li>
<li>哈希函数: 通常我们会将单词转成大数字, 大数字在进行哈希化的代码实现放在一个函数中, 这个函数我们成为哈希函数.</li>
<li>哈希表: 最终将数据插入到的这个数组, 我们就称之为是一个哈希表</li>
</ul>
</li>
</ul>
<h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><ul>
<li>0~199的数字选取5个放在长度为10的单元格中</li>
<li>如果我们随机选出来的是33, 82, 11, 45, 90, 那么最终它们的位置会是3-2-1-5-0, 没有发生冲突.</li>
<li>但是如果其中有一个33, 还有一个73呢? 还是发生了冲突.</li>
</ul>
<h4 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h4><blockquote>
<p>链地址法是一种比较常见的解决冲突的方案.(也称为拉链法)</p>
</blockquote>
<ul>
<li>链地址法解决冲突的办法是每个数组单元中存储的不再是单个数据, 而是一个链条</li>
<li>这个链条使用数组或者链表</li>
<li>每个数组单元中存储着一个链表. 一旦发现重复, 将重复的元素插入到链表的首端或者末端即可.</li>
<li>当查询时, 先根据哈希化后的下标值找到对应的位置, 再取出链表, 依次查询找寻找的数据.</li>
</ul>
<p><img src="./02.png" alt="链地址法"></p>
<h4 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h4><blockquote>
<p>开放地址法的主要工作方式是寻找空白的单元格来添加重复的数据</p>
</blockquote>
<p><img src="./03.png" alt="开放地址法"></p>
<ul>
<li>探索这个位置的方式不同, 有三种方法:<ul>
<li>线性探测</li>
<li>二次探测</li>
<li>再哈希法</li>
</ul>
</li>
</ul>
<h5 id="线性探测"><a href="#线性探测" class="headerlink" title="线性探测"></a>线性探测</h5><blockquote>
<p>线性探测非常好理解: 线性的查找空白的单元</p>
</blockquote>
<ul>
<li>插入的32<ul>
<li>经过哈希化得到的index=2, 但是在插入的时候, 发现该位置已经有了82</li>
<li>线性探测就是从index位置+1开始一点点查找合适的位置来放置32</li>
<li>空的位置就是合适的位置, 在我们上面的例子中就是index=3的位置, 这个时候32就会放在该位置</li>
</ul>
</li>
<li>查询32<ul>
<li>首先经过哈希化得到index=2, 比如2的位置结果和查询的数值是否相同, 相同那么就直接返回</li>
<li>不相同呢? 线性查找, 从index位置+1开始查找和32一样的</li>
<li>查询到空位置, 就停止. (因为查询到这里有空位置, 32之前不可能跳过空位置去其他的位置)</li>
</ul>
</li>
<li>删除32<ul>
<li>删除操作一个数据项时, 不可以将这个位置下标的内容设置为null  </li>
<li>因为将它设置为null可能会影响我们之后查询其他操作, 所以通常删除一个位置的数据项时, 我们可以将它进行特殊处理(比如设置为-1)</li>
<li>我们之后看到-1位置的数据项时, 就知道查询时要继续查询, 但是插入时这个位置可以放置数据.</li>
</ul>
</li>
<li>带来的问题<ul>
<li>插入22-23-24-25-26, 那么意味着下标值:2-3-4-5-6的位置都有元素. 这种一连串填充单元就叫做聚集</li>
<li>聚集会影响哈希表的性能, 无论是插入/查询/删除都会影响</li>
<li>比如我们插入一个32, 会发现连续的单元都不允许我们放置数据, 并且在这个过程中我们需要探索多次</li>
</ul>
</li>
</ul>
<h5 id="二次探测"><a href="#二次探测" class="headerlink" title="二次探测"></a>二次探测</h5><blockquote>
<p>二次探测主要优化的是探测时的步长</p>
</blockquote>
<ul>
<li><p>特点</p>
<ul>
<li>线性探测, 我们可以看成是步长为1的探测, 比如从下标值x开始, 那么线性测试就是x+1, x+2, x+3依次探测.</li>
<li>二次探测, 对步长做了优化, 比如从下标值x开始, x+1², x+2², x+3².</li>
<li>这样就可以一次性探测比较常的距离, 比避免那些聚集带来的影响</li>
</ul>
</li>
<li><p>带来的问题</p>
<ul>
<li>二次探测依然存在问题, 比如我们连续插入的是32-112-82-2-192, 那么它们依次累加的时候步长的相同的</li>
<li>这种情况下会造成步长不一的一种聚集. 还是会影响效率.</li>
<li>怎么根本解决这个问题呢? ——让每个人的步长不一样！</li>
</ul>
</li>
</ul>
<h5 id="再哈希法"><a href="#再哈希法" class="headerlink" title="再哈希法"></a>再哈希法</h5><blockquote>
<p>把关键字用另外一个哈希函数, 再做一次哈希化, 用这次哈希化的结果作为步长</p>
</blockquote>
<ul>
<li>特点：<ul>
<li>和第一个哈希函数不同. (不要再使用上一次的哈希函数了, 不然结果还是原来的位置)</li>
<li>不能输出为0(否则, 将没有步长. 每次探测都是原地踏步, 算法就进入了死循环)</li>
</ul>
</li>
<li>公式<ul>
<li>stepSize = constant - (key - constant)</li>
<li>其中constant是质数, 且小于数组的容量.</li>
<li>例如: stepSize = 5 - (key % 5), 满足需求, 并且结果不可能为0.</li>
</ul>
</li>
</ul>
<p><img src="./04.png" alt="导图"></p>
]]></content>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/2020/07/07/01%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/01%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/03%E6%A0%91/03%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><h2 id="二叉搜索树的缺陷"><a href="#二叉搜索树的缺陷" class="headerlink" title="二叉搜索树的缺陷"></a>二叉搜索树的缺陷</h2><ul>
<li>二叉搜索树查找某一结点次数等于该节点的度</li>
<li>如果节点都在根的一侧（非平衡树）会增加查找次数</li>
<li>为了解决这个平衡性问题需要一种算法，这种算法结合的树就是红黑树</li>
</ul>
<p><img src="./01.jpg" alt="缺陷"></p>
<h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><ul>
<li>节点必须是红色或黑色</li>
<li>根节点只能是黑色</li>
<li>每个叶子节点都是黑色的空节点<ul>
<li>在二叉搜索树的基础上，把每个叶子节点都补充两个黑色null节点</li>
</ul>
</li>
<li>每个红色节点两个子节点必须都是黑色的</li>
<li>任何一个节点到其每个叶子的所有路径都包含相同数目的黑色节点</li>
<li>根到叶子最长路径，不会超过最短可能路径的两倍<ul>
<li>黑色=n，红色&lt;=n-1  ===&gt;  n+n-1=2n-1&lt;2n</li>
</ul>
</li>
</ul>
<h2 id="红黑树的变换"><a href="#红黑树的变换" class="headerlink" title="红黑树的变换"></a>红黑树的变换</h2><ul>
<li>变色<ul>
<li>插入节点时首先选则红色</li>
</ul>
</li>
<li>左旋转<ul>
<li>逆时针旋转红黑树的两个节点</li>
<li>右节点变为自己的父节点</li>
<li>自己变为右节点的左节点</li>
<li>右节点的左节点变为自己的右节点</li>
<li>其他都不变</li>
</ul>
</li>
</ul>
<p><img src="./01.gif" alt="左旋转1"><br><img src="./02.png" alt="左旋转2"></p>
<ul>
<li>右旋转<ul>
<li>顺时针旋转红黑树的两个节点</li>
<li>左节点变为自己的父节点</li>
<li>自己变为左节点的右节点</li>
<li>左节点的右节点变为自己的左节点</li>
<li>其他都不变</li>
</ul>
</li>
</ul>
<p><img src="./02.gif" alt="右旋转1"><br><img src="./03.png" alt="右旋转2"></p>
<h2 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h2><ul>
<li>情况1==&gt;新增节点N位于根上，没有父节点<ul>
<li>直接将红色变成黑色即可</li>
</ul>
</li>
<li>情况2==&gt;新增节点N父节点为黑色<ul>
<li>直接添加即可</li>
</ul>
</li>
<li>情况3==&gt;新增节点N父节点（P）为红色，叔叔节点（U）也为红色，祖父节点（G）为黑<ul>
<li>P,U,G全部变为相反颜色</li>
<li>G的父节点为红色，则递归调用，到根节点为红色则需要旋转</li>
</ul>
</li>
<li>情况4==&gt;新增节点N父节点（P）为红色，叔叔节点（U）为黑，祖父节点（G）为黑，N为左节点<ul>
<li>P,G全部变为相反颜色，之后进行右旋转</li>
</ul>
</li>
<li>情况5==&gt;新增节点N父节点（P）为红色，叔叔节点（U）为黑，祖父节点（G）为黑，N为右节点<ul>
<li>以P为根左旋转</li>
<li>将P作为新插入的节点考虑即可（见详情4）</li>
</ul>
</li>
</ul>
<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>案例：插入10，9，8，7，6，5，4，3，2，1到红黑树中</p>
<p><img src="./01.png" alt="红黑树"></p>
]]></content>
  </entry>
  <entry>
    <title>哈希表实现</title>
    <url>/2020/06/30/01%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/01%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/02%E5%93%88%E5%B8%8C%E8%A1%A8/02%E5%93%88%E5%B8%8C%E8%A1%A8%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h1><p>好的哈希函数满足下面几个特性</p>
<ul>
<li>快速的计算</li>
<li>均匀的分布</li>
<li>扩容</li>
</ul>
<h2 id="快速的计算"><a href="#快速的计算" class="headerlink" title="快速的计算"></a>快速的计算</h2><ul>
<li>好的哈希函数应该尽可能让计算的过程变得简单, 应该可以快速计算出结果<ul>
<li>哈希表的主要优点是它的速度, 所以在速度上不能满足, 那么就达不到设计的目的了.</li>
<li>提高速度的一个办法就是让哈希函数中尽量少的有乘法和除法. 因为它们的性能是比较低的</li>
</ul>
</li>
<li>cats = 3 * 27³+ 1 * 27² + 20 * 27 + 17= 60337<ul>
<li>我们抽象一下, 这个表达式其实是一个多项式: a(n) * x^n + a(n-1) * x^(n-1) + … + a(1) * x + a(0)</li>
<li>现在问题就变成了多项式有多少次乘法和加法<ul>
<li>乘法次数: n＋(n－1)＋…＋1＝n(n+1)/2</li>
<li>加法次数: n次</li>
</ul>
</li>
</ul>
</li>
<li>多项式的优化: 霍纳法则(秦九韶算法)<ul>
<li>a(n) * x^n + a(n-1) * x^(n-1) + … + a(1) * x + a(0) = ((…(((an * x + a(n－1))x+a(n－2))x+ a(n－3))…)x+a1)x+a0</li>
<li>变换后有多少次乘法和加法<ul>
<li>乘法次数: n次</li>
<li>加法次数: n次</li>
</ul>
</li>
<li>如果使用大O表示时间复杂度的话, 我们直接从O(N²)降到了O(N).</li>
</ul>
</li>
</ul>
<h2 id="均匀的分布"><a href="#均匀的分布" class="headerlink" title="均匀的分布"></a>均匀的分布</h2><ul>
<li>使用链地址法或者开放地址法处理映射到相同下标值的情况</li>
<li>为了提供效率,避免聚集, 最好的情况还是让数据在哈希表中均匀分布</li>
<li>我们需要在使用常量的地方, 尽量使用质数<ul>
<li>一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数</li>
</ul>
</li>
<li>哈希表的长度使用质数<ul>
<li>表长为15， 步长为5<ul>
<li>有一个特定关键字映射到0, 步长为5. 探测序列是多少呢</li>
<li>0 - 5 - 10 - 0 - 5 - 10, 依次类推, 循环下去</li>
<li>算法只尝试着三个单元, 如果这三个单元已经有了数据, 那么会一直循环下去, 知道程序崩溃.</li>
</ul>
</li>
<li>表长为13， 步长为5<ul>
<li>0 - 5 - 10 - 2 - 7 - 12 - 4 - 9 - 1 - 6 - 11 - 3, 一直这样下去</li>
<li>不仅不会产生循环, 而且可以让数据在哈希表中更加均匀的分布</li>
</ul>
</li>
</ul>
</li>
<li>N次幂的底数, 使用质数<ul>
<li>采用质数的原因是为了产生的数据不按照某种规律递增</li>
<li>表长为8， 步长为4<ul>
<li>0 - 4 - 0 - 4, 依次类推, 循环下去</li>
</ul>
</li>
<li>表长为8， 步长为5<ul>
<li>0 - 5 - 2 - 7 - 4, 一直这样下去.</li>
</ul>
</li>
</ul>
</li>
<li>链地址法中质数没有那么重要<ul>
<li>因为不需要找空位置插入数据</li>
</ul>
</li>
</ul>
<h2 id="哈希函数实现"><a href="#哈希函数实现" class="headerlink" title="哈希函数实现"></a>哈希函数实现</h2><ul>
<li>“abc”.charCodeAt(0) // 97</li>
<li>str 需要哈希化的字符串</li>
<li>max 取摩运算的值，就是哈希表的长度</li>
<li>之前使用的是27, 这次可以使用一个接近的数, 比如29/31/37等等. 这里可以使用37.</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">hashFunc</span>(<span class="params">str, max</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.初始化hashCode的值</span></span><br><span class="line">    <span class="keyword">var</span> hashCode = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.霍纳算法, 来计算hashCode的数值（把转换后的下标组合起来）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        hashCode = <span class="number">37</span> * hashCode + str.charCodeAt(i) <span class="comment">// 提取的公因式是37</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.取模运算（压缩）</span></span><br><span class="line">    hashCode = hashCode % max</span><br><span class="line">    <span class="keyword">return</span> hashCode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(hashFunc(<span class="string">"abc"</span>, <span class="number">7</span>)) <span class="comment">// 4</span></span><br><span class="line">alert(hashFunc(<span class="string">"cba"</span>, <span class="number">7</span>)) <span class="comment">// 3</span></span><br><span class="line">alert(hashFunc(<span class="string">"nba"</span>, <span class="number">7</span>)) <span class="comment">// 5</span></span><br><span class="line">alert(hashFunc(<span class="string">"mba"</span>, <span class="number">7</span>)) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><ul>
<li>采用链地址法来实现哈希表</li>
<li>最终我们的哈希表的数据格式是这样: [[ [k,v], [k,v], [k,v] ] , [ [k,v], [k,v] ], [ [k,v] ]]</li>
</ul>
<h2 id="创建哈希表类"><a href="#创建哈希表类" class="headerlink" title="创建哈希表类"></a>创建哈希表类</h2><ul>
<li>storage ：存放元素的集合（最终我们的哈希表的数据格式是这样: [[ [k,v], [k,v], [k,v] ] , [ [k,v], [k,v] ], [ [k,v] ] ]，k是员工的姓名，v是员工的信息）</li>
<li>count ：当前Hash表存放多少元素（如果count大于limit则需要扩容）</li>
<li>limit ：Hash表当前总长度</li>
<li>直接将哈希函数定义在HashTable中</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建HashTable构造函数（链地址法）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HashTable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 定义属性</span></span><br><span class="line">    <span class="keyword">this</span>.storage = [] <span class="comment">// 存放元素的集合（最终我们的哈希表的数据格式是这样: [[ [k,v], [k,v], [k,v] ] , [ [k,v], [k,v] ], [ [k,v] ] ]，k是员工的姓名，v是员工的信息）</span></span><br><span class="line">    <span class="keyword">this</span>.count = <span class="number">0</span> <span class="comment">// 当前Hash表存放多少元素（如果count大于limit则需要扩容）</span></span><br><span class="line">    <span class="keyword">this</span>.limit = <span class="number">8</span> <span class="comment">// Hash表当前总长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希函数</span></span><br><span class="line">    HashTable.prototype.hashFunc = <span class="function"><span class="keyword">function</span>(<span class="params">str, max</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 1.初始化hashCode的值</span></span><br><span class="line">        <span class="keyword">var</span> hashCode = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.霍纳算法, 来计算hashCode的数值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">            hashCode = <span class="number">37</span> * hashCode + str.charCodeAt(i)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.取模运算</span></span><br><span class="line">        hashCode = hashCode % max</span><br><span class="line">        <span class="keyword">return</span> hashCode</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入-amp-修改数据"><a href="#插入-amp-修改数据" class="headerlink" title="插入&amp;修改数据"></a>插入&amp;修改数据</h2><p>如果没有就是插入，如果有就是修改</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入数据方法</span></span><br><span class="line">HashTable.prototype.put = <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.获取key对应的index（storage中的位置）也是哈希化</span></span><br><span class="line">    <span class="keyword">var</span> index = <span class="keyword">this</span>.hashFunc(key, <span class="keyword">this</span>.limit)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.取出数组(也可以使用链表)</span></span><br><span class="line">    <span class="comment">// 数组中放置数据的方式: [[ [k,v], [k,v], [k,v] ] , [ [k,v], [k,v] ]  [ [k,v] ] ]</span></span><br><span class="line">    <span class="keyword">var</span> bucket = <span class="keyword">this</span>.storage[index]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.判断这个数组是否存在（storage中是否存在）</span></span><br><span class="line">    <span class="keyword">if</span> (bucket === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="comment">// 3.1创建桶</span></span><br><span class="line">        bucket = [] <span class="comment">// 如果不存在就创建空数组</span></span><br><span class="line">        <span class="keyword">this</span>.storage[index] = bucket <span class="comment">// 这个新建数组指向storage数组中的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.判断是新增还是修改原来的值.（如果k存在就是修改，如果k不存在就是插入）</span></span><br><span class="line">    <span class="keyword">var</span> override = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; bucket.length; i++) &#123; <span class="comment">// 循环这个桶，如果是空数组[]，就会直接跳过循环</span></span><br><span class="line">        <span class="keyword">var</span> tuple = bucket[i]</span><br><span class="line">        <span class="keyword">if</span> (tuple[<span class="number">0</span>] === key) &#123; <span class="comment">//如果桶里面的key和插入的key相同，就做修改操作</span></span><br><span class="line">            tuple[<span class="number">1</span>] = value</span><br><span class="line">            override = <span class="literal">true</span> <span class="comment">// 把override设置为true为了跳过下面新增方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.如果是新增, !override这个是false就跳过下面方法</span></span><br><span class="line">    <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">        bucket.push([key, value])</span><br><span class="line">        <span class="keyword">this</span>.count++ <span class="comment">// Hash表中数据增加了所以++</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.count &gt; <span class="keyword">this</span>.limit * <span class="number">0.75</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> primeNum = <span class="keyword">this</span>.getPrime(<span class="keyword">this</span>.limit * <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">this</span>.resize(primeNum)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扩充-缩减哈希表"><a href="#扩充-缩减哈希表" class="headerlink" title="扩充/缩减哈希表"></a>扩充/缩减哈希表</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 哈希表扩容</span></span><br><span class="line">HashTable.prototype.resize = <span class="function"><span class="keyword">function</span> (<span class="params">newLimit</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.保存旧的数组内容</span></span><br><span class="line">    <span class="keyword">var</span> oldStorage = <span class="keyword">this</span>.storage</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.重置属性</span></span><br><span class="line">    <span class="keyword">this</span>.limit = newLimit <span class="comment">// 传入新的大小</span></span><br><span class="line">    <span class="keyword">this</span>.count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">this</span>.storage = []</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.遍历旧数组中的所有数据项, 并且重新插入到哈希表中</span></span><br><span class="line">    oldStorage.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">bucket</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 1.bucket为null, 说明这里面没有数据</span></span><br><span class="line">        <span class="keyword">if</span> (bucket == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.bucket中有数据, 那么将里面的数据重新哈希化插入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> tuple = bucket[i]</span><br><span class="line">            <span class="keyword">this</span>.put(tuple[<span class="number">0</span>], tuple[<span class="number">1</span>])<span class="comment">//重新插入到新的数组</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).bind(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取存放的数据</span></span><br><span class="line">HashTable.prototype.get = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.获取key对应的index</span></span><br><span class="line">    <span class="keyword">var</span> index = <span class="keyword">this</span>.hashFunc(key, <span class="keyword">this</span>.limit)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.获取对应的bucket</span></span><br><span class="line">    <span class="keyword">var</span> bucket = <span class="keyword">this</span>.storage[index]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.如果bucket为null, 那么说明这个位置没有数据</span></span><br><span class="line">    <span class="keyword">if</span> (bucket == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.有bucket, 判断是否有对应的key</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> tuple = bucket[i]</span><br><span class="line">        <span class="keyword">if</span> (tuple[<span class="number">0</span>] === key) &#123;</span><br><span class="line">            <span class="keyword">return</span> tuple[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.没有找到, return null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line">HashTable.prototype.remove = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.获取key对应的index</span></span><br><span class="line">    <span class="keyword">var</span> index = <span class="keyword">this</span>.hashFunc(key, <span class="keyword">this</span>.limit)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.获取对应的bucket</span></span><br><span class="line">    <span class="keyword">var</span> bucket = <span class="keyword">this</span>.storage[index]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.判断同是否为null, 为null则说明没有对应的数据</span></span><br><span class="line">    <span class="keyword">if</span> (bucket == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.遍历bucket, 寻找对应的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> tuple = bucket[i]</span><br><span class="line">        <span class="keyword">if</span> (tuple[<span class="number">0</span>] === key) &#123;</span><br><span class="line">            bucket.splice(i, <span class="number">1</span>) <span class="comment">// 删除桶中数据</span></span><br><span class="line">            <span class="keyword">this</span>.count-- <span class="comment">// Hash表中少了，所以--</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 缩小数组的容量</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.limit &gt; <span class="number">7</span> &amp;&amp; <span class="keyword">this</span>.count &lt; <span class="keyword">this</span>.limit * (<span class="number">1</span><span class="number">-0.75</span>)) &#123;</span><br><span class="line">                <span class="keyword">var</span> primeNum = <span class="keyword">this</span>.getPrime(<span class="built_in">Math</span>.floor(<span class="keyword">this</span>.limit / <span class="number">2</span>))</span><br><span class="line">                <span class="keyword">this</span>.resize(primeNum) <span class="comment">// 缩小容量</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> tuple[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.来到该位置, 说明没有对应的数据, 那么返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><ul>
<li>判断哈希表是否为空: isEmpty</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// isEmpty方法</span></span><br><span class="line">HashTable.prototype.isEmpty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.count == <span class="number">0</span> <span class="comment">// 如果count是0就代表是空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>size方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// size方法</span></span><br><span class="line">HashTable.prototype.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>图</title>
    <url>/2020/07/07/01%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/01%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/03%E6%A0%91/05%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><ul>
<li>在数学的概念上, 树是图的一种.</li>
</ul>
<p>村庄间的关系网<br><img src="./01.png" alt="图"></p>
<h2 id="图的特点"><a href="#图的特点" class="headerlink" title="图的特点"></a>图的特点</h2><ul>
<li>一组顶点：通常用 V (Vertex) 表示顶点的集合</li>
<li>一组边：通常用 E (Edge) 表示边的集合<ul>
<li>边是顶点和顶点之间的连线</li>
<li>边可以是有向的, 也可以是无向的.(比如A — B, 通常表示无向. A –&gt; B, 通常表示有向)</li>
</ul>
</li>
</ul>
<h2 id="图的术语"><a href="#图的术语" class="headerlink" title="图的术语"></a>图的术语</h2><p>把上面的村庄图进行抽象<br><img src="./02.png" alt="图的术语"></p>
<ul>
<li>顶点<ul>
<li>图中的一个结点</li>
<li>多个村庄中的某个村庄</li>
</ul>
</li>
<li>边<ul>
<li>表示顶点和顶点之间的连线</li>
<li>两个村庄之间的连线</li>
<li>0 - 1有一条边, 1 - 2有一条边, 0 - 2没有边</li>
</ul>
</li>
<li>相邻顶点<ul>
<li>由一条边连接在一起的顶点称为相邻顶点</li>
<li>比如0 - 1是相邻的, 0 - 3是相邻的. 0 - 2是不相邻的</li>
</ul>
</li>
<li>度<ul>
<li>一个顶点的度是相邻顶点的数量</li>
<li>比如0顶点和其他两个顶点相连, 0顶点的度是2</li>
<li>比如1顶点和其他四个顶点相连, 1顶点的度是4</li>
</ul>
</li>
<li>路径<ul>
<li>路径是顶点v1, v2…, vn的一个连续序列, 比如上图中0 1 5 9就是一条路径</li>
<li>简单路径: 简单路径要求不包含重复的顶点. 比如 0 1 5 9是一条简单路径.</li>
<li>回路: 第一个顶点和最后一个顶点相同的路径称为回路. 比如 0 1 5 6 3 0</li>
</ul>
</li>
<li>无向图<ul>
<li>上面的图就是一张无向图, 因为所有的边都没有方向.</li>
</ul>
</li>
<li>有向图<ul>
<li>有向图表示的图中的边是有方向的.</li>
</ul>
</li>
<li>无权图<ul>
<li>上面的图就是一张无权图(边没有携带权重)</li>
</ul>
</li>
<li>带权图<ul>
<li>带权图表示边有一定的权重.</li>
<li>里的权重可以是任意你希望表示的数据: 比如距离或者花费的时间或者票价.</li>
</ul>
</li>
</ul>
<p><img src="./03.png" alt="图的术语"></p>
<h1 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h1><p>一个图包含很多顶点, 另外包含顶点和顶点之间的连线(边), 这两个都是非常重要的图信息, 因此都需要在程序中体现出来</p>
<h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><ul>
<li>邻接矩阵让每个节点和一个整数向关联, 该整数作为数组的下标值.</li>
<li>我们用一个二维数组来表示顶点之间的连接</li>
</ul>
<p><img src="./04.png" alt="邻接矩阵"></p>
<ul>
<li>图片解析<ul>
<li>在二维数组中, 0表示没有连线, 1表示有连线.</li>
<li>通过二维数组, 我们可以很快的找到一个顶点和哪些顶点有连线.(比如A顶点, 只需要遍历第一行即可)</li>
<li>A - A, B - B(也就是顶点到自己的连线), 通常使用0表示</li>
</ul>
</li>
<li>问题<ul>
<li>如果图是一个稀疏图那么矩阵中将存在大量的0，那么矩阵中将存在大量的0</li>
</ul>
</li>
</ul>
<h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><ul>
<li>邻接表由图中每个顶点以及和顶点相邻的顶点列表组成.</li>
<li>这个列表有很多中方式来存储: 数组/链表/字典(哈希表)都可以.</li>
</ul>
<p><img src="./05.png" alt="邻接表"></p>
<ul>
<li><p>要表示和A顶点有关联的顶点(边), A和B/C/D有边, 那么我们可以通过A找到对应的数组/链表/字典, 再取出其中的内容就可以啦</p>
</li>
<li><p>问题</p>
<ul>
<li>邻接表计算”出度”是比较简单的(出度: 指向别人的数量, 入度: 指向自己的数量)</li>
<li>邻接表如果需要计算有向图的”入度”, 那么是一件非常麻烦的事情.</li>
<li>它必须构造一个”“逆邻接表”, 才能有效的计算”入度”. 而临街矩阵会非常简单</li>
</ul>
</li>
</ul>
<h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><ul>
<li>有两种算法可以对图进行遍历<ul>
<li>广度优先搜索(Breadth-First Search, 简称BFS)</li>
<li>深度优先搜索(Depth-First Search, 简称DFS)</li>
<li>两种遍历算法, 都需要明确指定第一个被访问的顶点.</li>
</ul>
</li>
</ul>
<h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><ul>
<li>广度优先算法会从指定的第一个顶点开始遍历图, 先访问其所有的相邻点, 就像一次访问图的一层.</li>
<li>就是先宽后深的访问顶点</li>
</ul>
<p><img src="./06.png" alt="广度优先搜索"></p>
<h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><ul>
<li>深度优先搜索算法将会从第一个指定的顶点开始遍历图, 沿着路径知道这条路径最后被访问了.</li>
<li>接着原路回退并探索吓一条路径.</li>
</ul>
<p><img src="./08.png" alt="深度优先搜索"></p>
<h1 id="图的封装"><a href="#图的封装" class="headerlink" title="图的封装"></a>图的封装</h1><h2 id="定义字典类型"><a href="#定义字典类型" class="headerlink" title="定义字典类型"></a>定义字典类型</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建字典的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dictionay</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 字典属性</span></span><br><span class="line">    <span class="keyword">this</span>.items = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字典操作方法</span></span><br><span class="line">    <span class="comment">// 在字典中添加键值对</span></span><br><span class="line">    Dictionay.prototype.set = <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.items[key] = value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断字典中是否有某个key</span></span><br><span class="line">    Dictionay.prototype.has = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items.hasOwnProperty(key)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从字典中移除元素</span></span><br><span class="line">    Dictionay.prototype.remove = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 1.判断字典中是否有这个key</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.has(key)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.从字典中删除key</span></span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>.items[key]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据key去获取value</span></span><br><span class="line">    Dictionay.prototype.get = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.has(key) ? <span class="keyword">this</span>.items[key] : <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取所有的keys</span></span><br><span class="line">    Dictionay.prototype.keys = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.items)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取所有的value</span></span><br><span class="line">    Dictionay.prototype.values = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.values(<span class="keyword">this</span>.items)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// size方法</span></span><br><span class="line">    Dictionay.prototype.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.keys().length</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear方法</span></span><br><span class="line">    Dictionay.prototype.clear = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.items = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建图类"><a href="#创建图类" class="headerlink" title="创建图类"></a>创建图类</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Graph</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="keyword">this</span>.vertexes = [] <span class="comment">// 存储顶点</span></span><br><span class="line">    <span class="keyword">this</span>.adjList = <span class="keyword">new</span> Dictionay() <span class="comment">// 存储边（自定义的字典类型）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加点的方法</span></span><br><span class="line">Graph.prototype.addVertex = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.vertexes.push(v) <span class="comment">// 顶点加到顶点数组中</span></span><br><span class="line">    <span class="keyword">this</span>.adjList.set(v, [])<span class="comment">// 存储这个顶点的边的字典（默认边数组为空，没有边）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加边的方法</span></span><br><span class="line">Graph.prototype.addEdge = <span class="function"><span class="keyword">function</span> (<span class="params">v, w</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.adjList.get(v).push(w) <span class="comment">// 取出顶点v的边数组，并且把点w放到数组中</span></span><br><span class="line">    <span class="keyword">this</span>.adjList.get(w).push(v)<span class="comment">// 无向图也需要把v放到w中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">var</span> graph = <span class="keyword">new</span> Graph()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加顶点</span></span><br><span class="line"><span class="keyword">var</span> myVertexes = [<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; myVertexes.length; i++) &#123;</span><br><span class="line">    graph.addVertex(myVertexes[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加边</span></span><br><span class="line">graph.addEdge(<span class="string">'A'</span>, <span class="string">'B'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'A'</span>, <span class="string">'C'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'A'</span>, <span class="string">'D'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'C'</span>, <span class="string">'D'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'C'</span>, <span class="string">'G'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'D'</span>, <span class="string">'G'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'D'</span>, <span class="string">'H'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'B'</span>, <span class="string">'E'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'B'</span>, <span class="string">'F'</span>);</span><br><span class="line">graph.addEdge(<span class="string">'E'</span>, <span class="string">'I'</span>);</span><br></pre></td></tr></table></figure>

<h2 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// toString方法（alert的时候会找toString方法，如果不写就去原型链找，就是[Object,Object]）</span></span><br><span class="line">Graph.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> resultStr = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.vertexes.length; i++) &#123;</span><br><span class="line">        resultStr += <span class="keyword">this</span>.vertexes[i] + <span class="string">"-&gt;"</span></span><br><span class="line">        <span class="keyword">var</span> adj = <span class="keyword">this</span>.adjList.get(<span class="keyword">this</span>.vertexes[i])</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; adj.length; j++) &#123;</span><br><span class="line">            resultStr += adj[j] + <span class="string">" "</span></span><br><span class="line">        &#125;</span><br><span class="line">        resultStr += <span class="string">"\n"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultStr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><ul>
<li>两种算法的思想:<ul>
<li>广度优先: 基于队列, 出队列的时候记录.</li>
<li>深度优先: 基于栈/队列, 入栈/队列时候记录</li>
</ul>
</li>
<li>为了记录顶点是否被访问过, 我们使用三种颜色来反应它们的状态<ul>
<li>白色: 表示该顶点还没有被访问.</li>
<li>灰色: 表示该顶点被访问过, 但并未被探索过.</li>
<li>黑色: 表示该顶点被访问过且被完全探索过.</li>
</ul>
</li>
</ul>
<h3 id="初始化颜色代码"><a href="#初始化颜色代码" class="headerlink" title="初始化颜色代码"></a>初始化颜色代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 广度优先算法</span></span><br><span class="line">Graph.prototype.initializeColor = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> colors = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.vertexes.length; i++) &#123;</span><br><span class="line">        colors[<span class="keyword">this</span>.vertexes[i]] = <span class="string">"white"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> colors</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="广度优先"><a href="#广度优先" class="headerlink" title="广度优先"></a>广度优先</h3><ul>
<li>创建一个队列Q.</li>
<li>将v标注为被发现的(灰色), 并将v将入队列Q</li>
<li>如果Q非空, 执行下面的步骤:<ul>
<li>将v从Q中取出队列.</li>
<li>将v标注为被发现的灰色.</li>
<li>将v所有的未被访问过的邻接点(白色), 加入到队列中.</li>
<li>将v标志为黑色.</li>
</ul>
</li>
</ul>
<p><img src="./11.png" alt="广度优先"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 广度优先算法（v：起始点，从哪里开始遍历；handler：处理方法）</span></span><br><span class="line">Graph.prototype.bfs = <span class="function"><span class="keyword">function</span> (<span class="params">v, handler</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.初始化颜色</span></span><br><span class="line">    <span class="keyword">var</span> color = <span class="keyword">this</span>.initializeColor()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建队列（利用队列先进先出）</span></span><br><span class="line">    <span class="keyword">var</span> queue = <span class="keyword">new</span> Queue()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.将传入的顶点放入队列中</span></span><br><span class="line">    queue.enqueue(v) <span class="comment">// 起始点放入到队列中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.从队列中依次取出和放入数据</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 4.1.从队列中取出数据</span></span><br><span class="line">        <span class="keyword">var</span> qv = queue.dequeue()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.2.获取qv相邻的所有顶点（是个list）</span></span><br><span class="line">        <span class="keyword">var</span> qAdj = <span class="keyword">this</span>.adjList.get(qv)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.3.将qv的颜色设置成灰色</span></span><br><span class="line">        color[qv] = <span class="string">"gray"</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.4.将qAdj关联的所有顶点依次压入队列中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; qAdj.length; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> a = qAdj[i]</span><br><span class="line">            <span class="comment">// 只有是白色才放入队列（防止如果两个父节点同时指向一个子节点，这个子节点被重复放入）</span></span><br><span class="line">            <span class="keyword">if</span> (color[a] === <span class="string">"white"</span>) &#123;</span><br><span class="line">                color[a] = <span class="string">"gray"</span></span><br><span class="line">                queue.enqueue(a)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.5.因为qv已经探测完毕, 将qv设置成黑色</span></span><br><span class="line">        color[qv] = <span class="string">"black"</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.6.处理qv</span></span><br><span class="line">        <span class="keyword">if</span> (handler) &#123;</span><br><span class="line">            handler(qv)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="深度优先"><a href="#深度优先" class="headerlink" title="深度优先"></a>深度优先</h3><ul>
<li>遍历A的相邻节点BCD</li>
<li>遍历B的时候递归遍历B的子节点EF</li>
<li>所以C要等到B遍历后才能开始遍历C</li>
</ul>
<p><img src="./10.png" alt="深度优先"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 深度优先搜索</span></span><br><span class="line">Graph.prototype.dfs = <span class="function"><span class="keyword">function</span> (<span class="params">handler</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.初始化颜色</span></span><br><span class="line">    <span class="keyword">var</span> color = <span class="keyword">this</span>.initializeColor()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.遍历所有的顶点, 开始访问</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.vertexes.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (color[<span class="keyword">this</span>.vertexes[i]] === <span class="string">"white"</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.dfsVisit(<span class="keyword">this</span>.vertexes[i], color, handler)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dfs的递归调用方法</span></span><br><span class="line">Graph.prototype.dfsVisit = <span class="function"><span class="keyword">function</span> (<span class="params">u, color, handler</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.将u的颜色设置为灰色</span></span><br><span class="line">    color[u] = <span class="string">"gray"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.处理u顶点</span></span><br><span class="line">    <span class="keyword">if</span> (handler) &#123;</span><br><span class="line">        handler(u)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.u的所有邻接顶点的访问</span></span><br><span class="line">    <span class="keyword">var</span> uAdj = <span class="keyword">this</span>.adjList.get(u)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; uAdj.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> w = uAdj[i]</span><br><span class="line">        <span class="keyword">if</span> (color[w] === <span class="string">"white"</span>) &#123; <span class="comment">// 递归调用所有u相邻的节点</span></span><br><span class="line">            <span class="keyword">this</span>.dfsVisit(w, color, handler)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.将u设置为黑色</span></span><br><span class="line">    color[u] = <span class="string">"black"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>高级排序</title>
    <url>/2020/07/07/01%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/01%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/04%E7%AE%97%E6%B3%95/02%E9%AB%98%E7%BA%A7%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><blockquote>
<p>希尔排序是插入排序的一种高效的改进版, 并且效率比插入排序要更快.</p>
</blockquote>
<h2 id="插入排序的问题"><a href="#插入排序的问题" class="headerlink" title="插入排序的问题"></a>插入排序的问题</h2><ul>
<li>假设一个很小的数据项在很靠近右端的位置上, 这里本来应该是较大的数据项的位置.</li>
<li>把这个小数据项移动到左边的正确位置, 所有的中间数据项都必须向右移动一位</li>
<li>如果每个步骤对数据项都进行N次复制, 平均下来是移动N/2, N个元素就是 N*N/2 = N²/2.</li>
<li>所以我们通常认为插入排序的效率是O(N²)</li>
<li>如果有某种方式, 不需要一个个移动所有中间的数据项, 就能把较小的数据项移动到左边, 那么这个算法的执行效率就会有很大的改进.</li>
</ul>
<h2 id="希尔排序的做法"><a href="#希尔排序的做法" class="headerlink" title="希尔排序的做法"></a>希尔排序的做法</h2><ul>
<li>比如下面的数字, 81, 94, 11, 96, 12, 35, 17, 95, 28, 58, 41, 75, 15.</li>
<li>我们先让间隔为5, 进行排序. (35, 81), (94, 17), (11, 95), (96, 28), (12, 58), (35, 41), (17, 75), (95, 15)</li>
<li>排序后的新序列, 一定可以让数字离自己的正确位置更近一步.</li>
</ul>
<p><img src="./01.png" alt="希尔排序的做法"></p>
<ul>
<li>选择合适的增量<ul>
<li>在希尔排序的原稿中, 他建议的初始间距是N / 2, 简单的把每趟排序分成两半</li>
<li>也就是说, 对于N = 100的数组, 增量间隔序列为: 50, 25, 12, 6, 3, 1</li>
</ul>
</li>
</ul>
<h2 id="希尔排序的实现"><a href="#希尔排序的实现" class="headerlink" title="希尔排序的实现"></a>希尔排序的实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 希尔排序</span></span><br><span class="line">ArrayList.prototype.shellSort = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.获取数组的长度</span></span><br><span class="line">    <span class="keyword">var</span> length = <span class="keyword">this</span>.array.length</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.根据长度计算增量（向下取整）</span></span><br><span class="line">    <span class="keyword">var</span> gap = <span class="built_in">Math</span>.floor(length / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.增量不断变量小, 大于0就继续排序</span></span><br><span class="line">    <span class="keyword">while</span> (gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 4.实现插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = gap; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">// 4.1.保存临时变量</span></span><br><span class="line">            <span class="keyword">var</span> j = i</span><br><span class="line">            <span class="keyword">var</span> temp = <span class="keyword">this</span>.array[i]</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.2.插入排序的内存循环</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; gap - <span class="number">1</span> &amp;&amp; <span class="keyword">this</span>.array[j - gap] &gt; temp) &#123;</span><br><span class="line">                <span class="keyword">this</span>.array[j] = <span class="keyword">this</span>.array[j - gap]</span><br><span class="line">                j -= gap</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.3.将选出的j位置设置为temp</span></span><br><span class="line">            <span class="keyword">this</span>.array[j] = temp</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.重新计算新的间隔</span></span><br><span class="line">        gap = <span class="built_in">Math</span>.floor(gap / <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="希尔排序的效率"><a href="#希尔排序的效率" class="headerlink" title="希尔排序的效率"></a>希尔排序的效率</h2><ul>
<li>希尔排序的效率很增量是有关系的</li>
<li>它的效率证明非常困难, 甚至某些增量的效率到目前依然没有被证明出来</li>
<li>经过统计, 希尔排序使用原始增量, 最坏的情况下时间复杂度为O(N²), 通常情况下都要好于O(N²)</li>
</ul>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><blockquote>
<p>快速排序几乎可以说是目前所有排序算法中, 最快的一种排序算法.</p>
</blockquote>
<h2 id="快速排序的思想"><a href="#快速排序的思想" class="headerlink" title="快速排序的思想"></a>快速排序的思想</h2><ul>
<li>快速排序是什么<ul>
<li>希尔排序相当于插入排序的升级版, 快速排序其实是我们学习过的最慢的冒泡排序的升级版</li>
<li>冒泡排序需要经过很多次交换, 才能在一次循环中, 将最大值放在正确的位置</li>
<li>快速排序可以在一次循环中(其实是递归调用)找出某个元素的正确位置, 并且该元素之后不需要任何移动.</li>
</ul>
</li>
<li>快速排序的思想<ul>
<li>快速排序最重要的思想是分而治之</li>
<li>假设我们有一组数字需要排序(13 81 92 43 65 31 57 26 75 0):<ul>
<li>第一步: 从其中选出了65. (其实可以是选出任意的数字, 我们以65举个栗子)</li>
<li>第二步: 我们通过算法: 将所有小于65的数字放在65的左边, 将所有大于65的数字放在65的右边.</li>
<li>第三步: 递归的处理左边的数据.(比如你选择31来处理左侧), 递归的处理右边的数据.(比如选择75来处理右侧)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="./02.png" alt="快速排序的思想"></p>
<h2 id="快速排序的枢纽"><a href="#快速排序的枢纽" class="headerlink" title="快速排序的枢纽"></a>快速排序的枢纽</h2><h3 id="如何选则合适枢纽"><a href="#如何选则合适枢纽" class="headerlink" title="如何选则合适枢纽"></a>如何选则合适枢纽</h3><ul>
<li>一种方案是直接选择第一个元素作为枢纽<ul>
<li>但第一个作为枢纽在某些情况下, 效率并不是特别高.</li>
</ul>
</li>
<li>另一种方案是使用随机数<ul>
<li>随机取 pivot？但是随即函数本身就是一个耗性能的操作.</li>
</ul>
</li>
<li>另一种比较优秀的解决方案: 取头、中、尾的中位数<ul>
<li>例如 8、12、3的中位数就是8</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 选择枢纽</span></span><br><span class="line">ArrayList.prototype.median = <span class="function"><span class="keyword">function</span> (<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.求出中间的位置</span></span><br><span class="line">    <span class="keyword">var</span> center = <span class="built_in">Math</span>.floor((left + right) / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.判断并且进行交换</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.array[left] &gt; <span class="keyword">this</span>.array[center]) &#123;</span><br><span class="line">        <span class="keyword">this</span>.swap(left, center)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.array[center] &gt; <span class="keyword">this</span>.array[right]) &#123;</span><br><span class="line">        <span class="keyword">this</span>.swap(center, right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.array[left] &gt; <span class="keyword">this</span>.array[right]) &#123;</span><br><span class="line">        <span class="keyword">this</span>.swap(left, right)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.巧妙的操作: 将center移动到right - 1的位置.</span></span><br><span class="line">    <span class="keyword">this</span>.swap(center, right - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.返回pivot</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.array[right - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交互数组中的两个数据位置</span></span><br><span class="line">ArrayList.prototype.swap = <span class="function"><span class="keyword">function</span> (<span class="params">m, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temp = <span class="keyword">this</span>.array[m]</span><br><span class="line">    <span class="keyword">this</span>.array[m] = <span class="keyword">this</span>.array[n]</span><br><span class="line">    <span class="keyword">this</span>.array[n] = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们封装了一个函数, 该函数用于选择出来合适的枢纽.</li>
<li>该函数要求传入left和right, 这样可以根据left和right求出一个center, 在选择它们三者的中位数.<ul>
<li>代码序号1: 根据left/right求出center.</li>
<li>代码序号2: 将left放在最前面, 将center放在中间, 将right放在右边.</li>
<li>代码序号3: 这里有一个巧妙的操作, 我们将pivot值放在了right的紧挨着的左边, 为什么这样操作呢?<ul>
<li>这样操作的目的是在之后交换的时候, pivot的值不需要移动来移动去.</li>
<li>可以在最后选定位置后, 直接再交换到正确的位置即可(也是最终的位置).</li>
</ul>
</li>
<li>代码序号4: 返回选择出来的枢纽</li>
</ul>
</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快速排序实现</span></span><br><span class="line">ArrayList.prototype.quickSort = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.quickSortRec(<span class="number">0</span>, <span class="keyword">this</span>.array.length - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ArrayList.prototype.quickSortRec = <span class="function"><span class="keyword">function</span> (<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 0.递归结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.获取枢纽</span></span><br><span class="line">    <span class="keyword">var</span> pivot = <span class="keyword">this</span>.median(left, right)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.开始进行交换</span></span><br><span class="line">    <span class="keyword">var</span> i = left</span><br><span class="line">    <span class="keyword">var</span> j = right - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">this</span>.array[++i] &lt; pivot) &#123; &#125; <span class="comment">// 为了让i++  这个值大于枢纽的时候停止</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">this</span>.array[--j] &gt; pivot) &#123; &#125; <span class="comment">// 为了让j--  这个值小于枢纽的时候停止</span></span><br><span class="line">        <span class="comment">// 如果i和j没碰面则一直找，并且交换两个数的位置</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">this</span>.swap(i, j)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果i和j相遇或相遇过了就跳出循环</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.将枢纽放在正确的位置</span></span><br><span class="line">    <span class="keyword">this</span>.swap(i, right - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.递归调用左边和右面</span></span><br><span class="line">    <span class="keyword">this</span>.quickSortRec(left, i - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">this</span>.quickSortRec(i + <span class="number">1</span>, right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里有两个函数: quickSort和quickSortRec.<ul>
<li>外部调用时, 会调用quickSort</li>
<li>内部递归时, 会调用quickSortRec</li>
</ul>
</li>
<li>我们这里主要讲解一下quickSortRec方法.<ul>
<li>代码序号0: 是递归的结束条件. 可以回头再来看这个函数.</li>
<li>代码序号1: 从三个数中获取枢纽值, 这个方法我们在上一节中已经讲过, 这里不再累述.</li>
<li>代码序号2: 我们的重点代码<ul>
<li>代码序号2.1: 循环交换合适位置的数值.</li>
<li>代码序号2.2: 使用两个while循环, 递归的查找合适的i(大于枢纽的值)和合适的j(小于枢纽的值).</li>
<li>代码序号2.3: 交换i和j位置的值.</li>
<li>代码序号2.4: 当i&lt;j的时候, 两边查找到了同一个位置, 这个时候停止循环.</li>
</ul>
</li>
<li>代码序号3: 刚才我们查找到的i位置正是pivot应该所在的位置, 和pivot替换即可.<ul>
<li>为什么将i位置可以换到最后呢? 万一它比pivot小呢?</li>
<li>这是因为我们在while (this.array[++i] &lt; pivot)先使用的是i, 而不是j. 但是这意味着什么呢?</li>
<li>意味着i找到的一个值, 现在停下来的, 必然是大于pivot. 而j会超过i的位置向后找了一个小于pivot.</li>
<li>但是, 这个时候已经不需要继续进行交换了, 直接退出即可.</li>
<li>而退出后, i位置的数值是大于pivot, 所以可以将其换到后面.</li>
</ul>
</li>
<li>代码序号4: 递归调用该函数, 将left, i - 1传入就是左边排序, 将i + 1, right就是右边排序</li>
</ul>
</li>
</ul>
<h2 id="快速排序的效率"><a href="#快速排序的效率" class="headerlink" title="快速排序的效率"></a>快速排序的效率</h2><ul>
<li>快速排序的平均效率:<ul>
<li>快速排序的平均效率是O(N * logN).</li>
<li>虽然其他某些算法的效率也可以达到O(N * logN), 但是快速排序是最好的.</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>B和B+树</title>
    <url>/2020/07/07/01%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/01%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/03%E6%A0%91/04B%E5%92%8CB+%E6%A0%91/</url>
    <content><![CDATA[<h1 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h1><h2 id="红黑树缺点"><a href="#红黑树缺点" class="headerlink" title="红黑树缺点"></a>红黑树缺点</h2><ul>
<li>如果是Mysql的存储需要把数据存储在磁盘上</li>
<li>二叉树层级太深，每一层都是一次磁盘读写</li>
<li>二叉树每个节点只保存一个值造成资源浪费</li>
<li>B 树是为磁盘等存储设备设计的一种平衡查找树</li>
</ul>
<h2 id="B树特点"><a href="#B树特点" class="headerlink" title="B树特点"></a>B树特点</h2><ul>
<li>每个节点存储多个元素</li>
<li>摒弃二叉树结构，采用多叉树</li>
<li>每个节点至多可以拥有M棵子树(M为阶)</li>
<li>每个节点有M-1个key，并且以升序排列</li>
<li>根节点至少有1个key</li>
</ul>
<h2 id="B树插入"><a href="#B树插入" class="headerlink" title="B树插入"></a>B树插入</h2><p><img src="./03.gif" alt="B树插入"></p>
<h2 id="B树删除"><a href="#B树删除" class="headerlink" title="B树删除"></a>B树删除</h2><p><img src="./04.gif" alt="B树插入"></p>
<h2 id="B树插入案例1"><a href="#B树插入案例1" class="headerlink" title="B树插入案例1"></a>B树插入案例1</h2><p>往B树中依次插入6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4</p>
<p><img src="./01.png" alt="B树插入"></p>
<h2 id="B树插入案例2"><a href="#B树插入案例2" class="headerlink" title="B树插入案例2"></a>B树插入案例2</h2><p>往B树中依次插入6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4</p>
<p><img src="./01.gif" alt="B树插入"></p>
<h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1><h2 id="B树问题"><a href="#B树问题" class="headerlink" title="B树问题"></a>B树问题</h2><ul>
<li>读取key为“66”与“73”的数据</li>
<li>从根节点“50”开始，“66”大于“50”，找右孩子，即到“60 70 120”的节点，再锁定到“64 66”的节点，找到key为“66”的数据</li>
<li>然后读“73”的数据，再重新从根开始往下寻找key为“73”的数据</li>
<li>数据量一多，性能就很糟糕</li>
<li>在经过路径上的非叶子节点也会被读出（60，70，120），但实际上这部分数据我是不需要的，这样又占用了没有必要的内存空间</li>
</ul>
<p><img src="./02.png" alt="B树问题"></p>
<h2 id="B-树特点"><a href="#B-树特点" class="headerlink" title="B+树特点"></a>B+树特点</h2><ul>
<li>有 k 个子节点的节点必然有 k 个key；</li>
<li>非叶子节点仅具有索引作用，跟记录有关的信息均存放在叶子节点中。</li>
<li>树的所有叶子节点构成一个有序链表，可以按照key排序的次序遍历全部记录。</li>
</ul>
<p><img src="./03.png" alt="B+树特点"></p>
<blockquote>
<p>B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可<br>B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针</p>
</blockquote>
<h2 id="B-树插入"><a href="#B-树插入" class="headerlink" title="B+树插入"></a>B+树插入</h2><p>往B+树中依次插入6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4</p>
<p><img src="./02.gif" alt="B+树插入"></p>
]]></content>
  </entry>
  <entry>
    <title>对象</title>
    <url>/2020/07/29/01%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/02%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01%E5%9F%BA%E7%A1%80%E5%B7%A5%E4%BD%9C/01%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class初始化方法</span></span><br><span class="line">    <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name <span class="comment">//类的属性</span></span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    eat() &#123; <span class="comment">// 类的方法</span></span><br><span class="line">        alert(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> eat something`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    speak() &#123;</span><br><span class="line">        alert(<span class="string">`My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>, age <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个对象实例</span></span><br><span class="line"><span class="keyword">let</span> zhang = <span class="keyword">new</span> People(<span class="string">'zhang'</span>, <span class="number">20</span>)</span><br><span class="line">zhang.eat()</span><br><span class="line">zhang.speak()</span><br><span class="line"><span class="comment">// 创建另外一个对象实例</span></span><br><span class="line"><span class="keyword">let</span> wang = <span class="keyword">new</span> People(<span class="string">'wang'</span>, <span class="number">21</span>)</span><br><span class="line">wang.eat()</span><br><span class="line">wang.speak()</span><br></pre></td></tr></table></figure>

<h2 id="面向对象三要素"><a href="#面向对象三要素" class="headerlink" title="面向对象三要素"></a>面向对象三要素</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li>父类<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, age) &#123; <span class="comment">//父类属性，所有子类继承父类也都有这个属性</span></span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    eat() &#123; <span class="comment">//父类方法，所有子类继承父类也都有这个方法</span></span><br><span class="line">        alert(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> eat something`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    speak() &#123; <span class="comment">//父类方法，所有子类继承父类也都有这个方法</span></span><br><span class="line">        alert(<span class="string">`My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>, age <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>子类<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义子类继承父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, age, number) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age)</span><br><span class="line">        <span class="keyword">this</span>.number = number <span class="comment">//子类自己的属性</span></span><br><span class="line">    &#125;</span><br><span class="line">    study() &#123; <span class="comment">// 子类自己的方法</span></span><br><span class="line">        alert(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> study`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建子类对象</span></span><br><span class="line"><span class="keyword">let</span> xiaoming = <span class="keyword">new</span> Student(<span class="string">'xiaoming'</span>, <span class="number">10</span>, <span class="string">'A1'</span>)</span><br><span class="line">xiaoming.study()</span><br><span class="line"><span class="built_in">console</span>.log(xiaoming.number)</span><br><span class="line"><span class="keyword">let</span> xiaohong = <span class="keyword">new</span> Student(<span class="string">'xiaohong'</span>, <span class="number">11</span>, <span class="string">'A2'</span>)</span><br><span class="line">xiaohong.study()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul>
<li>关键字<ul>
<li>public完全开放</li>
<li>protected对子类开放</li>
<li>private对自己开放</li>
</ul>
</li>
<li>ES6尚不支持，TS可以支持</li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>子类实现自己的父类方法</p>
<ul>
<li>父类<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    saySomething() &#123; <span class="comment">// 子类都会有这个，但是子类可以运行自己的这个方法</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>子类1<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name)</span><br><span class="line">    &#125;</span><br><span class="line">    saySomething() &#123; <span class="comment">// 子类实现自己的saySomething方法</span></span><br><span class="line">        alert(<span class="string">'I am A'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>子类2<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name)</span><br><span class="line">    &#125;</span><br><span class="line">    saySomething() &#123;<span class="comment">// 子类实现自己的saySomething方法</span></span><br><span class="line">        alert(<span class="string">'I am B'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>测试<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> A(<span class="string">'a'</span>)</span><br><span class="line">a.saySomething()</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B(<span class="string">'b'</span>)</span><br><span class="line">b.saySomething()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h1><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul>
<li>Visio  微软提供的工具</li>
<li><a href="https://www.processon.com/" target="_blank" rel="noopener">https://www.processon.com/</a> 在线的可以使用免费版绘制工具</li>
<li>draw.ioDesktop谷歌浏览器应用程序</li>
</ul>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ul>
<li>UML中，可见性分为4级<br> 1 public 公用的 ：用+ 前缀表示 ，该属性对所有类可见<br> 2 protected 受保护的：用 # 前缀表示，对该类的子孙可见<br> 3 private 私有的：用- 前缀表示，只对该类本身可见<br> 4 package 包的：用 ~ 前缀表示，只对同一包声明的其他类可见</li>
</ul>
<p><img src="./01.png" alt="基本语法"></p>
<p><img src="./02.png" alt="基本语法"></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/ 父类</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name,house) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        <span class="keyword">this</span>.house = house</span><br><span class="line">    &#125;</span><br><span class="line">    saySomething() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name,house) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name,house)</span><br><span class="line">    &#125;</span><br><span class="line">    saySomething() &#123; <span class="comment">// 子类实现自己的saySomething方法</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'I am A'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name,house) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name,house)</span><br><span class="line">    &#125;</span><br><span class="line">    saySomething() &#123;<span class="comment">// 子类实现自己的saySomething方法</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'I am B'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(city) &#123;</span><br><span class="line">        <span class="keyword">this</span>.city = city</span><br><span class="line">    &#125;</span><br><span class="line">    showCity() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`house in <span class="subst">$&#123;<span class="keyword">this</span>.city&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> aHouse = <span class="keyword">new</span> House(<span class="string">'北京'</span>);</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> A(<span class="string">"aaa"</span>,aHouse);</span><br><span class="line"><span class="keyword">let</span> bHouse = <span class="keyword">new</span> House(<span class="string">'上海'</span>);</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> A(<span class="string">"bbb"</span>,bHouse);</span><br></pre></td></tr></table></figure>

<p><img src="./03.png" alt="示例"></p>
]]></content>
  </entry>
  <entry>
    <title>树结构</title>
    <url>/2020/07/01/01%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/01%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/03%E6%A0%91/01%E6%A0%91%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="树是什么"><a href="#树是什么" class="headerlink" title="树是什么"></a>树是什么</h1><h2 id="生活中的树"><a href="#生活中的树" class="headerlink" title="生活中的树"></a>生活中的树</h2><p><img src="./01.png" alt="生活中的树"></p>
<ul>
<li>树的特点<ul>
<li>树通常有一个根. 连接着根的是树干</li>
<li>树干到上面之后会进行分叉成树枝, 树枝还会分叉成更小的树枝</li>
<li>在树枝的最后是叶子</li>
</ul>
</li>
</ul>
<h2 id="模拟树结构"><a href="#模拟树结构" class="headerlink" title="模拟树结构"></a>模拟树结构</h2><ul>
<li>公司组织架构</li>
</ul>
<p><img src="./02.png" alt="公司组织架构"></p>
<ul>
<li>我们再将里面的数据移除, 仅仅抽象出来结构, 就是树结构</li>
</ul>
<p><img src="./03.png" alt="抽象树"></p>
<h2 id="树的优点"><a href="#树的优点" class="headerlink" title="树的优点"></a>树的优点</h2><ul>
<li>数组:<ul>
<li>优点:<ul>
<li>数组的主要优点是根据下标值访问效率会很高.</li>
</ul>
</li>
<li>缺点:<ul>
<li>需要先对数组进行排序, 生成有序数组, 才能提高查找效率.</li>
<li>数组在插入和删除数据时, 需要有大量的位移操作(插入到首位或者中间位置的时候), 效率很低.</li>
</ul>
</li>
</ul>
</li>
<li>链表:<ul>
<li>优点:<ul>
<li>链表的插入和删除操作效率都很高.</li>
</ul>
</li>
<li>缺点:<ul>
<li>查找效率很低, 需要从头开始依次访问链表中的每个数据项, 直到找到.</li>
<li>即使插入和删除操作效率很高, 但是如果要插入和删除中间位置的数据, 还是需要重头先找到对应的数据.<br>哈希表:</li>
</ul>
</li>
<li>优点:<ul>
<li>哈希表的插入/查询/删除效率都是非常高的</li>
</ul>
</li>
<li>缺点:<ul>
<li>空间利用率不高, 底层使用的是数组, 并且某些单元是没有被利用的.</li>
<li>哈希表中的元素是无序的, 不能按照固定的顺序来遍历哈希表中的元素.</li>
<li>不能快速的找出哈希表中的最大值或者最小值这些特殊的值.<br>树结构:</li>
</ul>
</li>
<li>不能说树结构比其他结构都要好, 因为每种数据结构都有自己特定的应用场景.</li>
<li>树综合了上面的数据结构的优点(当然优点不足于盖过其他数据结构, 比如效率一般情况下没有哈希表高), 并且也弥补了上面数据结构的缺点.</li>
<li>而且为了模拟某些场景, 我们使用树结构会更加方便. 比如文件的目录结构.</li>
</ul>
</li>
</ul>
<h2 id="树的术语"><a href="#树的术语" class="headerlink" title="树的术语"></a>树的术语</h2><ul>
<li>树<ul>
<li>当n=0时，称为空树</li>
<li>一棵N个结点的树有N-1条边(除了根节点以外，其他每个节点都有指向父节点的边)</li>
<li>除了根结点外，每个结点有且仅有一个父结点</li>
</ul>
</li>
<li>结点的度<ul>
<li>结点拥有子结点的数量（有几个孩子）</li>
</ul>
</li>
<li>树的度<ul>
<li>树中各结点度的最大值.</li>
</ul>
</li>
<li>叶结点<ul>
<li>度为0的结点. (也称为叶子结点)</li>
</ul>
</li>
<li>父结点<ul>
<li>有子树的结点是其子树的根结点的父结点</li>
</ul>
</li>
<li>子结点<ul>
<li>若A结点是B结点的父结点，则称B结点是A结点的子结点；子结点也称孩子结点。</li>
</ul>
</li>
<li>兄弟结点<ul>
<li>具有同一父结点的各结点彼此是兄弟结点。</li>
</ul>
</li>
<li>路径和路径长度<ul>
<li>从一个节点到另一个节点需要经过的节点叫路径，从一个节点到另一个节点的边数叫路径长度</li>
</ul>
</li>
<li>结点的层次<ul>
<li>规定根结点在1层，其它任一结点的层数是其父结点的层数加1。</li>
</ul>
</li>
<li>树的深度<ul>
<li>树中所有结点中的最大层次是这棵树的深度。 </li>
</ul>
</li>
</ul>
<h1 id="树的表示"><a href="#树的表示" class="headerlink" title="树的表示"></a>树的表示</h1><ul>
<li>普通的表示方式</li>
</ul>
<p><img src="./04.png" alt="普通的表示方式"></p>
<ul>
<li>儿子-兄弟表示法</li>
</ul>
<p><img src="./05.png" alt="兄弟表示法"></p>
<ul>
<li>儿子-兄弟表示法旋转</li>
</ul>
<p><img src="./06.png" alt="兄弟表示法旋转"></p>
<ul>
<li>其实所有的树本质上都可以使用二叉树模拟出来</li>
</ul>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><blockquote>
<p>如果树中每个节点最多只能有两个子节点, 这样的树就成为”二叉树”.</p>
</blockquote>
<h2 id="二叉树的概念"><a href="#二叉树的概念" class="headerlink" title="二叉树的概念"></a>二叉树的概念</h2><ul>
<li>二叉树的定义<ul>
<li>二叉树可以为空, 也就是没有结点</li>
<li>若不为空，则它是由根结点和称为其左子树TL和右子树TR的两个不相交的二叉树组成</li>
</ul>
</li>
<li>二叉树有五种形态</li>
</ul>
<p><img src="./07.png" alt="五种形态"></p>
<h2 id="二叉树的特性"><a href="#二叉树的特性" class="headerlink" title="二叉树的特性"></a>二叉树的特性</h2><ul>
<li>一个二叉树第 i 层的最大结点数为：2^(i-1),其中i&gt;=1</li>
<li>深度为k的二叉树有最大结点总数为： 2^k - 1，其中k&gt;=1</li>
<li>对任何非空二叉树 T，若n0表示叶结点的个数、n2是度为2的非叶结点个数，那么两者满足关系n0 = n2 + 1</li>
</ul>
<p><img src="./08.png" alt="二叉树的特性"></p>
<h1 id="特殊的二叉树"><a href="#特殊的二叉树" class="headerlink" title="特殊的二叉树"></a>特殊的二叉树</h1><h2 id="完美二叉树"><a href="#完美二叉树" class="headerlink" title="完美二叉树"></a>完美二叉树</h2><ul>
<li>完美二叉树(Perfect Binary Tree) , 也称为满二叉树(Full Binary Tree）</li>
<li>在二叉树中, 除了最下一层的叶结点外, 每层节点都有2个子结点, 就构成了满二叉树</li>
</ul>
<p><img src="./09.png" alt="完美二叉树"></p>
<h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><ul>
<li>除二叉树最后一层外, 其他各层的节点数都达到最大个数</li>
<li>且最后一层从左向右的叶结点连续存在, 只缺右侧若干节点</li>
<li>完美二叉树是特殊的完全二叉树</li>
</ul>
<p><img src="./10.png" alt="完全二叉树"></p>
<h1 id="二叉树的存储"><a href="#二叉树的存储" class="headerlink" title="二叉树的存储"></a>二叉树的存储</h1><ul>
<li>二叉树的存储常见的方式是数组和链表</li>
</ul>
<h2 id="使用数组存储"><a href="#使用数组存储" class="headerlink" title="使用数组存储"></a>使用数组存储</h2><ul>
<li>完全二叉树: 按从上至下、从左到右顺序存储<ul>
<li>左孩子节点的坐标为父节点的2倍</li>
<li>右孩子节点的坐标为父节点的2倍+1</li>
</ul>
</li>
</ul>
<p><img src="./11.png" alt="使用数组存储"></p>
<ul>
<li>非完全二叉树<ul>
<li>非完全二叉树要转成完全二叉树才可以按照上面的方案存储</li>
<li>但是会造成很大的空间浪费</li>
</ul>
</li>
</ul>
<p><img src="./12.png" alt="非完全二叉树"></p>
<h2 id="链表存储"><a href="#链表存储" class="headerlink" title="链表存储"></a>链表存储</h2><ul>
<li>二叉树最常见的方式还是使用链表存储</li>
<li>每个结点封装成一个Node, Node中包含存储的数据, 左结点的引用, 右结点的引用</li>
</ul>
<p><img src="./13.png" alt="链表存储"></p>
]]></content>
  </entry>
  <entry>
    <title>设计原则</title>
    <url>/2020/07/30/01%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/02%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01%E5%9F%BA%E7%A1%80%E5%B7%A5%E4%BD%9C/02%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h1 id="基本设计原则"><a href="#基本设计原则" class="headerlink" title="基本设计原则"></a>基本设计原则</h1><ul>
<li>单一职责原则 SRP<ul>
<li>也就是说，一个对象只做一件事</li>
<li>优点<ul>
<li>降低单个类（方法、对象）的复杂度，提高可读性和可维护性，功能之间的界限更清晰；</li>
<li>类（方法、对象）之间根据功能被分为更小的粒度，有助于代码的复用；</li>
</ul>
</li>
<li>缺点<ul>
<li>增加系统中类（方法、对象）的个数，实际上也增加了这些对象之间相互联系的难度，同时也引入了额外的复杂度。</li>
</ul>
</li>
</ul>
</li>
<li>开放封闭原则 OCP<ul>
<li>对扩展开放，对修改封闭</li>
<li>优点<ul>
<li>增加可维护性，避免因为修改给系统带来的不稳定性</li>
<li>增加需求时，扩展新代码，而非修改已有代码</li>
</ul>
</li>
</ul>
</li>
<li>最少知识原则LKP<ul>
<li>类的内部如何实现、如何复杂都与调用者或者依赖者没关系</li>
<li>优点<ul>
<li>降低类（方法、对象）之间不必要的依赖，减少耦合</li>
</ul>
</li>
<li>缺点<ul>
<li>类（方法、对象）之间不直接通信也会经过一个第三者来通信，那么就要权衡引入第三者带来的复杂度是否值得</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="模式分类"><a href="#模式分类" class="headerlink" title="模式分类"></a>模式分类</h1><ul>
<li>创建型<ul>
<li>工厂模式（工厂方法模式，抽象工厂模式，创造者模式）</li>
<li>单例模式</li>
<li>原型模式</li>
</ul>
</li>
<li>结构型<ul>
<li>适配器模式</li>
<li>装饰器模式</li>
<li>代理模式</li>
<li>外观模式</li>
<li>桥接模式</li>
<li>组合模式</li>
<li>享元模式</li>
</ul>
</li>
<li>行为型<ul>
<li>策略模式</li>
<li>模板方法模式</li>
<li>观察者模式</li>
<li>迭代器模式</li>
<li>职责链模式</li>
<li>命令模式</li>
<li>备忘录模式</li>
<li>状态模式</li>
<li>访问者模式</li>
<li>中介者模式</li>
<li>解释器模式</li>
</ul>
</li>
</ul>
<h1 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h1><h2 id="题目和解题思路"><a href="#题目和解题思路" class="headerlink" title="题目和解题思路"></a>题目和解题思路</h2><ul>
<li>题目<ul>
<li>打车时，可以选择专车或者快车。任何车都有车牌号和名称</li>
<li>不同车价格不同，快车每公里1元，专车每公里2元</li>
<li>行程开始，显示车辆信息</li>
<li>行程结束，显示打车金额（假定行程就5公里）</li>
<li>画出UML类图，用ES6语法写出该示例</li>
</ul>
</li>
<li>解题思路<ul>
<li>任何车都有车牌号和名称====说明有一个父类</li>
<li>选择专车或者快车====说明时父类的子类</li>
<li>快车每公里1元，专车每公里2元====说明子类有自己的属性1元和2元</li>
<li>行程开始，显示车辆信息====说明行程和父类有关系，什么车都有信息</li>
</ul>
</li>
</ul>
<h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><p><img src="./01.png" alt="示例1"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 车父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(number,name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 快车子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Kuaiche</span> <span class="keyword">extends</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(number,name)&#123;</span><br><span class="line">        <span class="keyword">super</span>(number,name);</span><br><span class="line">        <span class="keyword">this</span>.price = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 专车子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zhuanche</span> <span class="keyword">extends</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(number,name)&#123;</span><br><span class="line">        <span class="keyword">super</span>(number,name);</span><br><span class="line">        <span class="keyword">this</span>.price = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 行程类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trip</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(car)&#123;</span><br><span class="line">        <span class="keyword">this</span>.car = car;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开始行程方法</span></span><br><span class="line">    start()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`行程开始，名称：<span class="subst">$&#123;<span class="keyword">this</span>.car.name&#125;</span></span></span><br><span class="line"><span class="string">        ,车牌号：<span class="subst">$&#123;<span class="keyword">this</span>.car.price&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结束行程方法</span></span><br><span class="line">    end()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`行程结束，价格：<span class="subst">$&#123;(<span class="keyword">this</span>.car.price * <span class="number">5</span>)&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> car = <span class="keyword">new</span> Kuaiche(<span class="number">100</span>,<span class="string">"奔驰"</span>);</span><br><span class="line"><span class="keyword">let</span> trip = <span class="keyword">new</span> Trip(car);</span><br><span class="line">trip.start();</span><br><span class="line">trip.end();</span><br></pre></td></tr></table></figure>

<h1 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h1><h2 id="题目和解题思路-1"><a href="#题目和解题思路-1" class="headerlink" title="题目和解题思路"></a>题目和解题思路</h2><ul>
<li>题目<ul>
<li>某停车场，分3层，每层100车位</li>
<li>每个车位都能监控到车辆的驶入和离开</li>
<li>车辆进入前，显示每层的空余车位数量</li>
<li>车辆进入时，摄像头可识别车牌号和时间</li>
<li>车辆出来时，出口显示器显示车牌号和停车时长</li>
<li>画出UML类图</li>
</ul>
</li>
<li>解题思路<ul>
<li>某停车场，分3层，每层100车位 ======》分为三个类，停车场，层，车位</li>
<li>车位都能监控到车辆的驶入和离开 ====》 车位这个Class有两个方法驶入和离开，并且有个属性车位有没有车，这两个方法可以切换这个属性</li>
<li>车辆进入前，显示每层的空余车位数量 ====》停车场要有个方法显示每层空余数量，具体的方法还要交给层，层显示每层的空余数量</li>
<li>车辆进入时，摄像头可识别车牌号和时间 ===》摄像头Class，摄像头输入的是车辆输出的是车牌号和时间</li>
<li>车辆出来时，出口显示器显示车牌号和停车时长 ====》显示器Class，方法是显示车牌号和时差长</li>
</ul>
</li>
</ul>
<h2 id="UML图-1"><a href="#UML图-1" class="headerlink" title="UML图"></a>UML图</h2><p><img src="./02.png" alt="示例2"></p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 车辆</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(num)&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 摄像头</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Camera</span></span>&#123;</span><br><span class="line">    shot(car)&#123; <span class="comment">// 拍摄方法返回车牌号和驶入时间</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            num:car.num,</span><br><span class="line">            inTime: <span class="keyword">new</span> <span class="built_in">Date</span>.now()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 出口显示器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> </span>&#123;</span><br><span class="line">    show(car, inTime) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'车牌号'</span>, car.num)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'停车时间'</span>, <span class="built_in">Date</span>.now() - inTime)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 停车场</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Park</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(floors)&#123;</span><br><span class="line">        <span class="keyword">this</span>.floors = floors || [];</span><br><span class="line">        <span class="keyword">this</span>.camera = <span class="keyword">new</span> Camera();</span><br><span class="line">        <span class="keyword">this</span>.screen = <span class="keyword">new</span> Screen()</span><br><span class="line">        <span class="keyword">this</span>.carList = &#123;&#125; <span class="comment">// 存储摄像头拍摄的车辆返回信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">in</span>(car) &#123;</span><br><span class="line">        <span class="comment">// 获取摄像头的信息：号码 时间</span></span><br><span class="line">        <span class="keyword">const</span> info = <span class="keyword">this</span>.camera.shot(car)</span><br><span class="line">        <span class="comment">// 停到某个车位</span></span><br><span class="line">        <span class="keyword">const</span> i = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">100</span> % <span class="number">100</span>)</span><br><span class="line">        <span class="keyword">const</span> place = <span class="keyword">this</span>.floors[<span class="number">0</span>].places[i]</span><br><span class="line">        place.in()</span><br><span class="line">        info.place = place</span><br><span class="line">        <span class="comment">// 记录信息</span></span><br><span class="line">        <span class="keyword">this</span>.carList[car.num] = info</span><br><span class="line">    &#125;</span><br><span class="line">    out(car) &#123;</span><br><span class="line">        <span class="comment">// 获取信息</span></span><br><span class="line">        <span class="keyword">const</span> info = <span class="keyword">this</span>.carList[car.num]</span><br><span class="line">        <span class="keyword">const</span> place = info.place</span><br><span class="line">        place.out()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示时间</span></span><br><span class="line">        <span class="keyword">this</span>.screen.show(car, info.inTime)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除信息存储</span></span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>.carList[car.num]</span><br><span class="line">    &#125;</span><br><span class="line">    emtpyNum()&#123; <span class="comment">// 剩余车位</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.floors.map(<span class="function"><span class="params">floor</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;floor.index&#125;</span> 层还有 <span class="subst">$&#123;floor.emptyPlaceNum()&#125;</span> 个空余车位`</span></span><br><span class="line">        &#125;).join(<span class="string">'\n'</span>) <span class="comment">// 把返回的数组变成字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 层</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Floor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(index,places)&#123;</span><br><span class="line">        <span class="keyword">this</span>.index = index; <span class="comment">//第几层</span></span><br><span class="line">        <span class="keyword">this</span>.places = places || []; <span class="comment">// 车位数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这一层有多少空车位</span></span><br><span class="line">    emptyPlaceNum()&#123;</span><br><span class="line">        <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.places.forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123; <span class="comment">// 循环遍历车位看是否为空</span></span><br><span class="line">            <span class="keyword">if</span>(item.empty)&#123;</span><br><span class="line">                num = num + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 车位</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Place</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.empty = <span class="literal">true</span>; <span class="comment">// 初始化车位为空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">in</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.empty = <span class="literal">false</span>; <span class="comment">// 车辆驶入车位不为空</span></span><br><span class="line">    &#125;</span><br><span class="line">    out()&#123;</span><br><span class="line">        <span class="keyword">this</span>.empty = <span class="literal">true</span>; <span class="comment">// 车辆离开车位为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码------------------------------</span></span><br><span class="line"><span class="comment">// 初始化停车场</span></span><br><span class="line"><span class="keyword">const</span> floors = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> places = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">        places[j] = <span class="keyword">new</span> Place()</span><br><span class="line">    &#125;</span><br><span class="line">    floors[i] = <span class="keyword">new</span> Floor(i + <span class="number">1</span>, places)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> park = <span class="keyword">new</span> Park(floors)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化车辆</span></span><br><span class="line"><span class="keyword">const</span> car1 = <span class="keyword">new</span> Car(<span class="string">'A1'</span>)</span><br><span class="line"><span class="keyword">const</span> car2 = <span class="keyword">new</span> Car(<span class="string">'A2'</span>)</span><br><span class="line"><span class="keyword">const</span> car3 = <span class="keyword">new</span> Car(<span class="string">'A3'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'第一辆车进入'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(park.emptyNum())</span><br><span class="line">park.in(car1)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'第二辆车进入'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(park.emptyNum())</span><br><span class="line">park.in(car2)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'第一辆车离开'</span>)</span><br><span class="line">park.out(car1)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'第二辆车离开'</span>)</span><br><span class="line">park.out(car2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'第三辆车进入'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(park.emptyNum())</span><br><span class="line">park.in(car3)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'第三辆车离开'</span>)</span><br><span class="line">park.out(car3)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>简单排序</title>
    <url>/2020/07/07/01%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/01%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/04%E7%AE%97%E6%B3%95/01%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><h2 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h2><ul>
<li>大O表示法是描述性能和复杂度的一种表示方法.</li>
<li>推导大O表示法通常我们会使用如下规则<ul>
<li>用常量1取代运行时间中的所有加法常量</li>
<li>在修改后的运行次数函数中, 只保留最高阶项</li>
<li>如果最高阶项存在并且不是1, 则去除与这个项相乘的常数</li>
</ul>
</li>
</ul>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装ArrayList</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.array = []</span><br><span class="line"></span><br><span class="line">    ArrayList.prototype.insert = <span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array.push(item)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ArrayList.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.array.join()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交互数组中的两个数据位置</span></span><br><span class="line">    ArrayList.prototype.swap = <span class="function"><span class="keyword">function</span> (<span class="params">m, n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> temp = <span class="keyword">this</span>.array[m]</span><br><span class="line">        <span class="keyword">this</span>.array[m] = <span class="keyword">this</span>.array[n]</span><br><span class="line">        <span class="keyword">this</span>.array[n] = temp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化数据项</span></span><br><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> ArrayList()</span><br><span class="line"></span><br><span class="line">list.insert(<span class="number">3</span>)</span><br><span class="line">list.insert(<span class="number">6</span>)</span><br><span class="line">list.insert(<span class="number">4</span>)</span><br><span class="line">list.insert(<span class="number">2</span>)</span><br><span class="line">list.insert(<span class="number">11</span>)</span><br><span class="line">list.insert(<span class="number">10</span>)</span><br><span class="line">list.insert(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">alert(list)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>所有排序的序列为：3 5 4 2 11 10 5</p>
</blockquote>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>冒泡排序算法相对其他排序运行效率较低, 但是在概念上它是排序算法中最简单的.</p>
<h2 id="冒泡排序的思路"><a href="#冒泡排序的思路" class="headerlink" title="冒泡排序的思路"></a>冒泡排序的思路</h2><ul>
<li>对未排序的各元素从头到尾依次比较相邻的两个元素大小关系</li>
<li>如果左边的队员高, 则两队员交换位置</li>
<li>向右移动一个位置, 比较下面两个队员</li>
<li>当走到最右端时, 最高的队员一定被放在了最右边</li>
<li>按照这个思路, 从最左端重新开始, 这次走到倒数第二个位置的队员即可.</li>
<li>依次类推, 就可以将数据排序完成</li>
</ul>
<p><img src="./01.png" alt="冒泡排序的思路"></p>
<h2 id="冒泡排序的实现"><a href="#冒泡排序的实现" class="headerlink" title="冒泡排序的实现"></a>冒泡排序的实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序 3 5 4 2 11 10 5</span></span><br><span class="line">ArrayList.prototype.bubbleSort = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.获取数组的长度</span></span><br><span class="line">    <span class="keyword">var</span> length = <span class="keyword">this</span>.array.length</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.反向循环, 因此次数越来越少</span></span><br><span class="line">    <span class="comment">// 第一次：通过最后一个位置数据进行比较，比较到倒数第一个之前</span></span><br><span class="line">    <span class="comment">// 第一次：通过倒数第二个位置数据进行比较，比较到倒数第二个之前</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 3.根据i的次数, 比较循环到i位置</span></span><br><span class="line">        <span class="comment">// 被比较的不比较第i个</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="comment">// 4.如果j位置比j+1位置的数据大, 那么就交换</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.array[j] &gt; <span class="keyword">this</span>.array[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 交换</span></span><br><span class="line">                <span class="keyword">this</span>.swap(j, j+<span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="./02.png" alt="冒泡排序的实现"></p>
<h2 id="冒泡排序的效率"><a href="#冒泡排序的效率" class="headerlink" title="冒泡排序的效率"></a>冒泡排序的效率</h2><ul>
<li>第一次循环6次比较, 第二次5次比较, 第三次4次比较….直到最后一趟进行了一次比较.</li>
<li>对于7个数据项比较次数: 6 + 5 + 4 + 3 + 2 + 1</li>
<li>对于N个数据项呢? (N - 1) + (N - 2) + (N - 3) + … + 1 = N * (N - 1) / 2</li>
<li>比较次数<ul>
<li>(N - 1) / 2 = N²/2 - N/2,根据规则2, 只保留最高阶项, 编程N² / 2</li>
<li>N² / 2, 根据规则3, 去除常量, 编程N²</li>
<li>因此冒泡排序的大O表示法为O(N²)</li>
</ul>
</li>
<li>交换次数<ul>
<li>如果有两次比较才需要交换一次(不可能每次比较都交换一次.), 那么交换次数为N² / 4</li>
<li>交换次数的大O表示也是O(N²)</li>
</ul>
</li>
</ul>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="选择排序的思路"><a href="#选择排序的思路" class="headerlink" title="选择排序的思路"></a>选择排序的思路</h2><ul>
<li>选定第一个索引位置，然后和后面元素依次比较</li>
<li>如果后面的队员, 小于第一个索引位置的队员, 则交换位置</li>
<li>经过一轮的比较后, 可以确定第一个位置是最小的</li>
<li>然后使用同样的方法把剩下的元素逐个比较即可</li>
<li>可以看出选择排序，第一轮会选出最小值，第二轮会选出第二小的值，直到最后</li>
</ul>
<p><img src="./03.png" alt="选择排序的思路"></p>
<ul>
<li>选择排序第一次将第0位置的人取出, 和后面的人(1, 2, 3…)依次比较, 如果后面的人更小, 那么就交换.</li>
<li>这样经过一轮之后, 第一个肯定是最小的人.</li>
<li>第二次将第1位置的人取出, 和后面的人(2, 3, 4…)依次比较, 如果后面的人更小, 那么就交换.</li>
<li>这样经过第二轮后, 第二个肯定是次小的人.</li>
</ul>
<h2 id="选择排序的实现"><a href="#选择排序的实现" class="headerlink" title="选择排序的实现"></a>选择排序的实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 选则排序</span></span><br><span class="line"><span class="comment">// 第一次：选则出list中最小的值放到第一个位置</span></span><br><span class="line"><span class="comment">// 第二次：选则出list-1中最小的值放到第二个位置</span></span><br><span class="line">ArrayList.prototype.selectionSort = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.获取数组的长度</span></span><br><span class="line">    <span class="keyword">var</span> length = <span class="keyword">this</span>.array.length</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.外层循环: 从0位置开始取出数据, 直到length-2位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 3.内层循环: 从i+1位置开始, 和后面的内容比较</span></span><br><span class="line">        <span class="keyword">var</span> min = i</span><br><span class="line">        <span class="comment">// 选则出最小的数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = min + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">            <span class="comment">// 4.如果i位置的数据大于j位置的数据, 记录最小的位置</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.array[min] &gt; <span class="keyword">this</span>.array[j]) &#123;</span><br><span class="line">                min = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换最小的值到i位置</span></span><br><span class="line">        <span class="keyword">this</span>.swap(min, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="./04.png" alt="冒泡排序的实现"></p>
<h2 id="选择排序的效率"><a href="#选择排序的效率" class="headerlink" title="选择排序的效率"></a>选择排序的效率</h2><ul>
<li>比较次数<ul>
<li>选择排序和冒泡排序的比较次数都是N*(N-1)/2, 也就是O(N²).</li>
</ul>
</li>
<li>交换次数<ul>
<li>选择排序的交换次数只有N-1次, 用大O表示法就是O(N)</li>
<li>比较完后面所有的值才交换（冒泡是比较一次可能交换一次）</li>
</ul>
</li>
</ul>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><ul>
<li>插入排序是简单排序中效率最好的一种</li>
<li>插入排序也是学习其他高级排序的基础</li>
</ul>
<h2 id="插入排序的思路"><a href="#插入排序的思路" class="headerlink" title="插入排序的思路"></a>插入排序的思路</h2><ul>
<li>插入排序思想的核心是局部有序</li>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>
<li>重复上一个步骤，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后, 重复上面的步骤.</li>
</ul>
<p><img src="./05.png" alt="插入排序的思路"></p>
<ul>
<li>插入排序应该从下标值1开始(因为0位置默认可以被认为是有序的)</li>
<li>从1位置开始取出元素, 并且判断该元素的大小和0位置进行比较, 如果1位置元素小于0位置元素, 那么交换, 否则不交换.</li>
<li>上面步骤执行完成后, 0 - 1位置已经排序好.<ul>
<li>取出2位置的元素, 和1位置进行比较:</li>
<li>如果2位置元素大于1位置元素, 说明2位置不需要任何动作. 0 - 1 - 2已经排序好.</li>
<li>如果2位置元素小于1位置元素, 那么将1移动到2的位置, 并且2继续和0进行比较.</li>
<li>如果2位置元素大于0位置的元素, 那么将2位置放置在1的位置, 排序完成. 0 - 2 - 1搞定.</li>
<li>如果2位置元素小于0位置的元素, 那么将0位置的元素移动到1位置, 并且将2位置的元素放在0位置, 2 - 0 - 1搞定.</li>
<li>按照上面的步骤, 依次找到最后一个元素, 整个数组排序完成.</li>
</ul>
</li>
</ul>
<h2 id="插入排序的实现"><a href="#插入排序的实现" class="headerlink" title="插入排序的实现"></a>插入排序的实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line">ArrayList.prototype.insertionSort = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.获取数组的长度</span></span><br><span class="line">    <span class="keyword">var</span> length = <span class="keyword">this</span>.array.length</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.外层循环: 外层循环是从1位置开始, 依次遍历到最后</span></span><br><span class="line">    <span class="comment">// 第一次：前面的list是空，后面的list是n</span></span><br><span class="line">    <span class="comment">// 第二次：前面的list是1，后面的list是n-1</span></span><br><span class="line">    <span class="comment">// 第三次：前面的list是2，后面的list是n-2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="comment">// 3.记录选出的元素, 放在变量temp中</span></span><br><span class="line">        <span class="keyword">var</span> j = i <span class="comment">// 位置</span></span><br><span class="line">        <span class="keyword">var</span> temp = <span class="keyword">this</span>.array[i] <span class="comment">//值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.内层循环: 内层循环不确定循环的次数, 最好使用while循环</span></span><br><span class="line">        <span class="comment">// 循环前面的list（有序数列） 从后往前，最大的数到最小的数循环</span></span><br><span class="line">        <span class="comment">// 只要是this.array[j-1]值大于temp（当前要插入的值），那么有序列中所有的值都向后移位（list长度从j-1变为j）</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.array[j<span class="number">-1</span>] &gt; temp) &#123;</span><br><span class="line">            <span class="keyword">this</span>.array[j] = <span class="keyword">this</span>.array[j<span class="number">-1</span>] <span class="comment">//向后移位</span></span><br><span class="line">            j--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.将选出的j位置, 放入temp元素</span></span><br><span class="line">        <span class="keyword">this</span>.array[j] = temp</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>代码序号1: 获取数组的长度.</li>
<li>代码序号2: 外层循环, 从1位置开始, 因为0位置可以默认看成是有序的了.</li>
<li>代码序号3: 记录选出的i位置的元素, 保存在变量temp中. i默认等于j</li>
<li>代码序号4: 内层循环<ul>
<li>内层循环的判断j - 1位置的元素和temp比较, 并且j &gt; 0.</li>
<li>那么就将j-1位置的元素放在j位置.</li>
<li>j位置向前移.</li>
</ul>
</li>
<li>代码序号5: 将目前选出的j位置放置temp元素.</li>
</ul>
<h2 id="插入排序的效率"><a href="#插入排序的效率" class="headerlink" title="插入排序的效率"></a>插入排序的效率</h2><ul>
<li>比较次数<ul>
<li>第一趟时, 需要的最多次数是1, 第二趟最多次数是2, 依次类推, 最后一趟是N-1次</li>
<li>因此是1 + 2 + 3 + … + N - 1 = N * (N - 1) / 2</li>
<li>每趟发现插入点之前, 平均只有全体数据项的一半需要进行比较</li>
<li>我们可以除以2得到 N * (N - 1) / 4. 所以相对于选择排序, 其他比较次数是少了一半的</li>
</ul>
</li>
<li>插入排序的复制次数<ul>
<li>第一趟时, 需要的最多复制次数是1, 第二趟最多次数是2, 依次类推, 最后一趟是N-1次.</li>
<li>因此是1 + 2 + 3 + … + N - 1 = N * (N - 1) / 2.</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/2020/07/30/01%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/02%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="./02.png" alt="举例"><br><img src="./03.png" alt="举例"></p>
<h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><p>今天你的老同学找你来玩，你决定下个馆子（因为不会做饭），于是你来到了小区门口的饭店，跟老板说，来一份鱼香肉丝，一份宫保鸡丁。等会儿菜就烧好端到你的面前，不用管菜烧出来的过程，你只要负责吃就行了</p>
<p><img src="./01.png" alt="例1"></p>
<p>老板相当于工厂，负责生产产品，访问者通过老板就可以拿到想要的产品。<br>在类似场景中，这些例子有以下特点：<br>访问者只需要知道产品名，就可以从工厂获得对应实例；<br>访问者不关心实例创建过程；</p>
<h1 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h1><ul>
<li>饭店方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Restaurant</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> getMenu(menu) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (menu) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'鱼香肉丝'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> YuXiangRouSi()</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'宫保鸡丁'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> GongBaoJiDin()</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'这个菜本店没有 -。-'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>鱼香肉丝类</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YuXiangRouSi</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123; <span class="keyword">this</span>.type = <span class="string">'鱼香肉丝'</span> &#125;</span><br><span class="line"></span><br><span class="line">    eat() &#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.type + <span class="string">' 真香~'</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>宫保鸡丁类</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GongBaoJiDin</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123; <span class="keyword">this</span>.type = <span class="string">'宫保鸡丁'</span> &#125;</span><br><span class="line"></span><br><span class="line">    eat() &#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.type + <span class="string">' 让我想起了外婆做的菜~'</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dish1 = Restaurant.getMenu(<span class="string">'鱼香肉丝'</span>)</span><br><span class="line">dish1.eat()                                   <span class="comment">// 输出: 鱼香肉丝 真香~</span></span><br><span class="line"><span class="keyword">const</span> dish2 = Restaurant.getMenu(<span class="string">'红烧排骨'</span>)   </span><br><span class="line">dish1.eat()                                   <span class="comment">// 输出: Error 这个菜本店没有 -。-</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2020/08/06/01%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/02%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/03%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="./01.jpg" alt="举例"></p>
<h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><p>当我们在电脑上玩经营类的游戏，经过一番眼花缭乱的骚操作好不容易走上正轨，夜深了我们去休息，<br>第二天打开电脑，发现要从头玩，立马就把电脑扔窗外了，所以一般希望从前一天的进度接着打，这里就用到了存档。<br>每次玩这游戏的时候，我们都希望拿到同一个存档接着玩，这就是属于单例模式的一个实例。</p>
<p>Jquery被引用到windows中时，就是一个单例模式</p>
<h1 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Singleton = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _instance = <span class="literal">null</span>        <span class="comment">// 存储单例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Singleton = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_instance) <span class="keyword">return</span> _instance     <span class="comment">// 判断是否已有单例</span></span><br><span class="line">        _instance = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">this</span>.init()                         <span class="comment">// 初始化操作</span></span><br><span class="line">        <span class="keyword">return</span> _instance</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Singleton.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.foo = <span class="string">'Singleton Pattern'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Singleton</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> visitor1 = <span class="keyword">new</span> Singleton()</span><br><span class="line"><span class="keyword">const</span> visitor2 = <span class="keyword">new</span> Singleton()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(visitor1 === visitor2)	<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h1 id="惰性单例、懒汉式-饿汉式"><a href="#惰性单例、懒汉式-饿汉式" class="headerlink" title="惰性单例、懒汉式-饿汉式"></a>惰性单例、懒汉式-饿汉式</h1><ul>
<li>懒汉式单例是在使用时才实例化</li>
<li>懒汉式单例是在使用时才实例化</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FuncClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123; <span class="keyword">this</span>.bar = <span class="string">'bar'</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 饿汉式</span></span><br><span class="line"><span class="keyword">const</span> HungrySingleton = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> _instance = <span class="keyword">new</span> FuncClass()</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _instance</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// 懒汉式</span></span><br><span class="line"><span class="keyword">const</span> LazySingleton = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _instance = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _instance || (_instance = <span class="keyword">new</span> FuncClass())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="keyword">const</span> visitor1 = <span class="keyword">new</span> HungrySingleton()</span><br><span class="line"><span class="keyword">const</span> visitor2 = <span class="keyword">new</span> HungrySingleton()</span><br><span class="line"><span class="keyword">const</span> visitor3 = <span class="keyword">new</span> LazySingleton()</span><br><span class="line"><span class="keyword">const</span> visitor4 = <span class="keyword">new</span> LazySingleton()</span><br><span class="line"><span class="built_in">console</span>.log(visitor1 === visitor2) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(visitor3 === visitor4) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>抽象工厂模式</title>
    <url>/2020/07/30/01%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/02%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="./01.png" alt="抽象工厂模式"></p>
<ul>
<li>Factory ：工厂，负责返回产品实例；</li>
<li>AbstractFactory ：虚拟工厂，制定工厂实例的结构；</li>
<li>Product ：产品，访问者从工厂中拿到的产品实例，实现抽象类；</li>
<li>AbstractProduct ：产品抽象类，由具体产品实现，制定产品实例的结构；</li>
</ul>
<h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><p>你再次来到了小区的饭店，跟老板说来一份鱼香肉丝，来一份宫保鸡丁，来一份番茄鸡蛋汤，来一份排骨汤。<br>无论什么样的菜，还是什么样的汤，他们都具有同样的属性，比如菜都可以吃，汤都可以喝。<br>所以我们不论拿到什么菜，都可以吃，而不论拿到什么汤，都可以喝。<br>对于饭店也一样，这个饭店可以做菜做汤，另一个饭店也可以，那么这两个饭店就具有同样的功能结构。<br>菜类属于抽象产品类，制定具体产品菜类所具备的属性，而饭店和之前的工厂模式一样，负责具体生产产品实例，访问者通过老板获取想拿的产品。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>我们知道 JavaScript 并不强面向对象，也没有提供抽象类（至少目前没有提供），但是可以模拟抽象类。<br>用对 new.target 来判断 new 的类，在父类方法中 throw new Error()，如果子类中没有实现这个方法就会抛错，这样来模拟抽象类：</p>
<ul>
<li>饭店方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Restaurant</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> orderDish(type) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'鱼香肉丝'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> YuXiangRouSi()</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'宫保鸡丁'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> GongBaoJiDin()</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'本店没有这个 -。-'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>菜品抽象类</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dish</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span>.target === Dish) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'抽象类不能直接实例化!'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.kind = <span class="string">'菜'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 抽象方法 */</span></span><br><span class="line">    eat() &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'抽象方法不能调用!'</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>鱼香肉丝类</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YuXiangRouSi</span> <span class="keyword">extends</span> <span class="title">Dish</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>()</span><br><span class="line">        <span class="keyword">this</span>.type = <span class="string">'鱼香肉丝'</span></span><br><span class="line">    &#125;</span><br><span class="line">    eat() &#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.kind + <span class="string">' - '</span> + <span class="keyword">this</span>.type + <span class="string">' 真香~'</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>宫保鸡丁类</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GongBaoJiDin</span> <span class="keyword">extends</span> <span class="title">Dish</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>()</span><br><span class="line">        <span class="keyword">this</span>.type = <span class="string">'宫保鸡丁'</span></span><br><span class="line">    &#125;</span><br><span class="line">    eat() &#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.kind + <span class="string">' - '</span> + <span class="keyword">this</span>.type + <span class="string">' 让我想起了外婆做的菜~'</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dish0 = <span class="keyword">new</span> Dish()                              <span class="comment">// 输出: Error 抽象方法不能调用!</span></span><br><span class="line"><span class="keyword">const</span> dish1 = Restaurant.orderDish(<span class="string">'鱼香肉丝'</span>)</span><br><span class="line">dish1.eat()                                                       <span class="comment">// 输出: 菜 - 鱼香肉丝 真香~</span></span><br><span class="line"><span class="keyword">const</span> dish2 = Restaurant.orderDish(<span class="string">'红烧排骨'</span>) </span><br><span class="line">dish1.eat()   <span class="comment">// 输出: Error 本店没有这个 -。-</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>装饰器模式</title>
    <url>/2020/08/06/01%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/02%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/05%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="./01.png" alt="举例"></p>
<h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><p>手机壳<br>手机壳装饰手机，在不影响手机正常使用的情况下，给手机提供额外的保护功能</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    draw(circle)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"画一个圆"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(circle)&#123;</span><br><span class="line">    <span class="keyword">this</span>.circle = circle;</span><br><span class="line">  &#125;</span><br><span class="line">  draw()&#123;</span><br><span class="line">    <span class="keyword">this</span>.circle.draw();</span><br><span class="line">    <span class="keyword">this</span>.setRedBorder();</span><br><span class="line">  &#125;</span><br><span class="line">  setRedBorder()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"设置红色边框"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">let</span>  circle = <span class="keyword">new</span> Circle();</span><br><span class="line">circle.draw();<span class="comment">// 画一个圆</span></span><br><span class="line"><span class="keyword">let</span> dec = <span class="keyword">new</span> Decorator(circle);</span><br><span class="line">dec.draw();<span class="comment">// 画一个圆 设置红色边框</span></span><br></pre></td></tr></table></figure>

<h1 id="ES7解析环境"><a href="#ES7解析环境" class="headerlink" title="ES7解析环境"></a>ES7解析环境</h1><ul>
<li>Webpack环境略；</li>
<li>安装bable解释器</li>
</ul>
<blockquote>
<p>transform-decorators-legacy</p>
</blockquote>
<ul>
<li>配置bable</li>
</ul>
<p><img src="./02.png" alt="配置bable"></p>
<h1 id="ES7中类装饰器代码"><a href="#ES7中类装饰器代码" class="headerlink" title="ES7中类装饰器代码"></a>ES7中类装饰器代码</h1><p>装饰器代码最后返回的都是函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@testDec</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testDec</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    target.isDec = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Demo.isDec); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>@其实就是把类用装饰器又嵌套了一层</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@decorator</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line">A = decorator(A) || A;</span><br></pre></td></tr></table></figure>

<h1 id="装饰器类带参数"><a href="#装饰器类带参数" class="headerlink" title="装饰器类带参数"></a>装饰器类带参数</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testDes</span>(<span class="params">isDec</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">        target.isDec = isDec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@testDes(<span class="literal">false</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Demo.isDec); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h1 id="装饰器给类新增方法"><a href="#装饰器给类新增方法" class="headerlink" title="装饰器给类新增方法"></a>装饰器给类新增方法</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixins</span>(<span class="params">...list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">Object</span>.assign(target.prototype, ...list) <span class="comment">// 把...list枚举出深度拷贝到target原型链上</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">    foo() &#123; <span class="built_in">console</span>.log(<span class="string">'foo'</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line">@mixins(Foo)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.foo() <span class="comment">// 'foo'</span></span><br></pre></td></tr></table></figure>

<h1 id="装饰方法-只读"><a href="#装饰方法-只读" class="headerlink" title="装饰方法(只读)"></a>装饰方法(只读)</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readonly</span>(<span class="params">target,name,descriptor</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// descriptor 属性描述对象（Object.descriptor 中会用到）&#123;</span></span><br><span class="line">    <span class="comment">// value:specifiedFunction // 值</span></span><br><span class="line">    <span class="comment">// enumerable:false // enumerable 属性是否会出现在for in 或者 Object.keys()的遍历中</span></span><br><span class="line">    <span class="comment">// configurable:true // 是否可删除</span></span><br><span class="line">    <span class="comment">// writable:true // 是否可以改变</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    descriptor.writable = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = <span class="string">"A"</span>;</span><br><span class="line">        <span class="keyword">this</span>.last = <span class="string">"B"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 装饰方法</span></span><br><span class="line">    @readonly</span><br><span class="line">    name()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.first&#125;</span>+<span class="subst">$&#123;<span class="keyword">this</span>.last&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(p.name()); <span class="comment">// A+B</span></span><br><span class="line">p.name = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  <span class="comment">// 这里会报错</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">123</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="装饰方法-日志"><a href="#装饰方法-日志" class="headerlink" title="装饰方法(日志)"></a>装饰方法(日志)</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> oldValue = descriptor.value; <span class="comment">// 获取原本的函数</span></span><br><span class="line"></span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Calling <span class="subst">$&#123;name&#125;</span> with <span class="subst">$&#123;<span class="built_in">arguments</span>[<span class="number">0</span>]&#125;</span> + <span class="subst">$&#123;<span class="built_in">arguments</span>[<span class="number">1</span>]&#125;</span>`</span>, ); <span class="comment">// arguments系统自带的参数</span></span><br><span class="line">        <span class="keyword">return</span> oldValue.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 执行原本的函数，oldValue指向this，传参为arguments（apply和call类似）</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Math</span></span>&#123;</span><br><span class="line">    <span class="comment">// 装饰方法</span></span><br><span class="line">    @log</span><br><span class="line">    add(a,b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> math = <span class="keyword">new</span> <span class="built_in">Math</span>();</span><br><span class="line"><span class="keyword">const</span> result = math.add(<span class="number">2</span>,<span class="number">4</span>);<span class="comment">// 执行add方法会自动打印日志，因为@log的存在</span></span><br></pre></td></tr></table></figure>

<h1 id="装饰器第三方库"><a href="#装饰器第三方库" class="headerlink" title="装饰器第三方库"></a>装饰器第三方库</h1><p><a href="https://www.npmjs.com/package/core-decorators" target="_blank" rel="noopener">core-decorators</a></p>
]]></content>
  </entry>
  <entry>
    <title>适配器模式</title>
    <url>/2020/08/06/01%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/02%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/04%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="./01.png" alt="举例"></p>
<h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><p>比如德国的电子设备在中国无法使用，所以需要一个转换器来把国内的电压转换成能给德国电子设备提供电</p>
<h1 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span></span>&#123;</span><br><span class="line">    specificRequest() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"德国标准插头"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee = <span class="keyword">new</span> Adaptee();</span><br><span class="line">    &#125;</span><br><span class="line">    request()&#123;</span><br><span class="line">        <span class="keyword">let</span> info = <span class="keyword">this</span>.adaptee.specificRequest();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;info&#125;</span> - 转换器 —— 中国标准插头`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">let</span> target = <span class="keyword">new</span> Target();</span><br><span class="line"><span class="keyword">let</span> res = target.request();</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br></pre></td></tr></table></figure>

<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>有的使用 jQuery 的老项目使用 $.ajax 来发送请求，<br>现在的新项目一般使用 Axios，<br>那么现在有个老项目的代码中全是 $.ajax，<br>如果你挨个修改，那么 bug 可能就跟地鼠一样到处冒出来让你焦头烂额，<br>这时可以采用适配器模式来将老的使用形式适配到新的技术栈上：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax2AxiosAdapter</span>(<span class="params">ajaxOptions</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> axios(&#123;</span><br><span class="line">        url: ajaxOptions.url,</span><br><span class="line">        method: ajaxOptions.type,</span><br><span class="line">        responseType: ajaxOptions.dataType,</span><br><span class="line">        data: ajaxOptions.data</span><br><span class="line">    &#125;)</span><br><span class="line">        .then(ajaxOptions.success)</span><br><span class="line">        .catch(ajaxOptions.error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 经过适配器包装 */</span></span><br><span class="line">$.ajax = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ajax2AxiosAdapter(options)</span><br><span class="line">&#125;</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">'/demo-url'</span>,</span><br><span class="line">    type: <span class="string">'POST'</span>,</span><br><span class="line">    dataType: <span class="string">'json'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        name: <span class="string">'张三'</span>,</span><br><span class="line">        id: <span class="string">'2345'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'访问成功！'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    error: <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.err(<span class="string">'访问失败～'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/2020/08/06/01%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/02%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/06%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="./01.png" alt="举例"></p>
<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>当详情某明星代言时，我们并不能联系到明星需要找明星经纪人谈，我们获取的联系方式也都是经纪人的联系方式，<br>通过联系经纪人来实现和明星的沟通。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>ES6 原生提供了 Proxy 构造函数，这个构造函数让我们可以很方便地创建代理对象</p>
<blockquote>
<p>var proxy = new Proxy(target, handler);</p>
</blockquote>
<ul>
<li>参数中 target 是被代理对象</li>
<li>handler 用来设置代理行为</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 明星</span></span><br><span class="line"><span class="keyword">let</span> star = &#123;</span><br><span class="line">    name: <span class="string">'张XX'</span>,</span><br><span class="line">    age: <span class="number">25</span>,</span><br><span class="line">    phone: <span class="string">'13910733521'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 经纪人</span></span><br><span class="line"><span class="keyword">let</span> agent = <span class="keyword">new</span> <span class="built_in">Proxy</span>(star, &#123;</span><br><span class="line">    <span class="keyword">get</span>: function (target, key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key === <span class="string">'phone'</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回经纪人自己的手机号</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">'18611112222'</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key === <span class="string">'price'</span>) &#123;</span><br><span class="line">            <span class="comment">// 明星不报价，经纪人报价</span></span><br><span class="line">            <span class="comment">// 明星对象上没有钱属性</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">120000</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其他的姓名和年龄都可以从明星对象中获取</span></span><br><span class="line">        <span class="keyword">return</span> target[key]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function (target, key, val) &#123;</span><br><span class="line">        <span class="comment">// 讨价还价</span></span><br><span class="line">        <span class="keyword">if</span> (key === <span class="string">'customPrice'</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果价格低于1000000则直接报错</span></span><br><span class="line">            <span class="keyword">if</span> (val &lt; <span class="number">100000</span>) &#123;</span><br><span class="line">                <span class="comment">// 最低 10w</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'价格太低'</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 修改</span></span><br><span class="line">                target[key] = val</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 主办方</span></span><br><span class="line"><span class="built_in">console</span>.log(agent.name)</span><br><span class="line"><span class="built_in">console</span>.log(agent.age)</span><br><span class="line"><span class="built_in">console</span>.log(agent.phone)</span><br><span class="line"><span class="built_in">console</span>.log(agent.price)</span><br><span class="line"><span class="comment">// 想自己提供报价（砍价，或者高价争抢）</span></span><br><span class="line">agent.customPrice = <span class="number">150000</span></span><br><span class="line"><span class="comment">// agent.customPrice = 90000  // 报错：价格太低</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'customPrice'</span>, agent.customPrice)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>外观模式</title>
    <url>/2020/08/06/01%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/02%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/07%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>如果用户需要把每种旋翼的控制原理弄清楚，那么门槛就太高了，所以无人机厂商会把具体旋翼控制的细节封装起来，用户所要接触的只是手上的遥控器，无论什么类型的无人机，遥控器的控制方式都一样，前后左右上下和左转右转</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> uav = &#123;</span><br><span class="line">    <span class="comment">/* 电子调速器 */</span></span><br><span class="line">    diantiao1: &#123;</span><br><span class="line">        up() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'电调1发送指令：电机1增大转速'</span>)</span><br><span class="line">            uav.dianji1.up()</span><br><span class="line">        &#125;,</span><br><span class="line">        down() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'电调1发送指令：电机1减小转速'</span>)</span><br><span class="line">            uav.dianji1.up()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    diantiao2: &#123;</span><br><span class="line">        up() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'电调2发送指令：电机2增大转速'</span>)</span><br><span class="line">            uav.dianji2.up()</span><br><span class="line">        &#125;,</span><br><span class="line">        down() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'电调2发送指令：电机2减小转速'</span>)</span><br><span class="line">            uav.dianji2.down()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    diantiao3: &#123;</span><br><span class="line">        up() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'电调3发送指令：电机3增大转速'</span>)</span><br><span class="line">            uav.dianji3.up()</span><br><span class="line">        &#125;,</span><br><span class="line">        down() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'电调3发送指令：电机3减小转速'</span>)</span><br><span class="line">            uav.dianji3.down()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    diantiao4: &#123;</span><br><span class="line">        up() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'电调4发送指令：电机4增大转速'</span>)</span><br><span class="line">            uav.dianji4.up()</span><br><span class="line">        &#125;,</span><br><span class="line">        down() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'电调4发送指令：电机4减小转速'</span>)</span><br><span class="line">            uav.dianji4.down()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/* 电机 */</span></span><br><span class="line">    dianji1: &#123;</span><br><span class="line">        up() &#123; <span class="built_in">console</span>.log(<span class="string">'电机1增大转速'</span>) &#125;,</span><br><span class="line">        down() &#123; <span class="built_in">console</span>.log(<span class="string">'电机1减小转速'</span>) &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    dianji2: &#123;</span><br><span class="line">        up() &#123; <span class="built_in">console</span>.log(<span class="string">'电机2增大转速'</span>) &#125;,</span><br><span class="line">        down() &#123; <span class="built_in">console</span>.log(<span class="string">'电机2减小转速'</span>) &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    dianji3: &#123;</span><br><span class="line">        up() &#123; <span class="built_in">console</span>.log(<span class="string">'电机3增大转速'</span>) &#125;,</span><br><span class="line">        down() &#123; <span class="built_in">console</span>.log(<span class="string">'电机3减小转速'</span>) &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    dianji4: &#123;</span><br><span class="line">        up() &#123; <span class="built_in">console</span>.log(<span class="string">'电机4增大转速'</span>) &#125;,</span><br><span class="line">        down() &#123; <span class="built_in">console</span>.log(<span class="string">'电机4减小转速'</span>) &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/* 遥控器 */</span></span><br><span class="line">    controller: &#123;</span><br><span class="line">        <span class="comment">/* 上升 */</span></span><br><span class="line">        up() &#123;</span><br><span class="line">            uav.diantiao1.up()</span><br><span class="line">            uav.diantiao2.up()</span><br><span class="line">            uav.diantiao3.up()</span><br><span class="line">            uav.diantiao4.up()</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">/* 前进 */</span></span><br><span class="line">        forward() &#123;</span><br><span class="line">            uav.diantiao1.down()</span><br><span class="line">            uav.diantiao2.down()</span><br><span class="line">            uav.diantiao3.up()</span><br><span class="line">            uav.diantiao4.up()</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">/* 下降 */</span></span><br><span class="line">        down() &#123;</span><br><span class="line">            uav.diantiao1.down()</span><br><span class="line">            uav.diantiao2.down()</span><br><span class="line">            uav.diantiao3.down()</span><br><span class="line">            uav.diantiao4.down()</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">/* 左转 */</span></span><br><span class="line">        left() &#123;</span><br><span class="line">            uav.diantiao1.up()</span><br><span class="line">            uav.diantiao2.down()</span><br><span class="line">            uav.diantiao3.up()</span><br><span class="line">            uav.diantiao4.down()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 操纵无人机 */</span></span><br><span class="line">uav.controller.down()    <span class="comment">// 发送下降指令</span></span><br><span class="line">uav.controller.left()    <span class="comment">// 发送左转指令</span></span><br></pre></td></tr></table></figure>

<h1 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数参数重载</span></span><br><span class="line"><span class="comment">// 有一种情况，比如某个函数有多个参数，其中一个参数可以传递也可以不传递，</span></span><br><span class="line"><span class="comment">// 你当然可以直接弄两个接口，但是使用函数参数重载的方式，可以让使用者获得更大的自由度，让两个使用上基本类似的方法获得统一的外观。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">domBindEvent</span>(<span class="params">nodes, type, selector, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fn === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        fn = selector</span><br><span class="line">        selector = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 剩下相关逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">domBindEvent(nodes, <span class="string">'click'</span>, <span class="string">'#div1'</span>, fn)</span><br><span class="line">domBindEvent(nodes, <span class="string">'click'</span>, fn)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>迭代器模式</title>
    <url>/2020/08/12/01%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/02%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/09%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>银行里的点钞机就是一个迭代器，<br>放入点钞机的钞票里有不同版次的人民币，每张钞票的冠字号也不一样，但当一沓钞票被放入点钞机中，<br>使用者并不关心这些差别，只关心钞票的数量，以及是否有假币。</p>
<p>这里我们使用 JavaScript 的方式来点一下钞：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bills = [<span class="string">'MCK013840031'</span>, <span class="string">'MCK013840032'</span>, <span class="string">'MCK013840033'</span>, <span class="string">'MCK013840034'</span>, <span class="string">'MCK013840035'</span>]</span><br><span class="line"></span><br><span class="line">bills.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">bill</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'当前钞票的冠字号为 '</span> + bill)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><h2 id="生成器对象Generator"><a href="#生成器对象Generator" class="headerlink" title="生成器对象Generator"></a>生成器对象Generator</h2><p>function* 这种声明方式(function关键字后跟一个星号）会定义一个生成器函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = gen(); <span class="comment">// "Generator &#123; &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()) <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="function"><a href="#function" class="headerlink" title="function*"></a>function*</h2><p>function* 这种声明方式(function关键字后跟一个星号）会定义一个生成器函数 (generator function)，它返回一个  Generator  对象。</p>
<blockquote>
<p>function* name([param[, param[, … param]]]) { statements }</p>
</blockquote>
<ul>
<li>name:函数名</li>
<li>param:要传递给函数的一个参数的名称</li>
<li>statements: 普通JS语句</li>
</ul>
<h3 id="使用迭代器遍历二维数组并转换成一维数组"><a href="#使用迭代器遍历二维数组并转换成一维数组" class="headerlink" title="使用迭代器遍历二维数组并转换成一维数组"></a>使用迭代器遍历二维数组并转换成一维数组</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">iterArr</span>(<span class="params">arr</span>) </span>&#123;            <span class="comment">//迭代器返回一个迭代器对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(arr)) &#123;         <span class="comment">// 内节点</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">          <span class="keyword">yield</span>* iterArr(arr[i]);   <span class="comment">// (*)递归</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;                          <span class="comment">// 离开     </span></span><br><span class="line">      <span class="keyword">yield</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 for-of 遍历:</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, [<span class="string">'b'</span>, <span class="string">'c'</span>], [<span class="string">'d'</span>, <span class="string">'e'</span>]];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> x <span class="keyword">of</span> iterArr(arr)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x);               <span class="comment">// a  b  c  d  e</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者直接将迭代器展开:</span></span><br><span class="line"><span class="keyword">var</span> arr = [ <span class="string">'a'</span>, [<span class="string">'b'</span>,[ <span class="string">'c'</span>, [<span class="string">'d'</span>, <span class="string">'e'</span>]]]];</span><br><span class="line"><span class="keyword">var</span> gen = iterArr(arr);</span><br><span class="line">arr = [...gen];                        <span class="comment">// ["a", "b", "c", "d", "e"]</span></span><br></pre></td></tr></table></figure>

<h3 id="调用其他迭代对象"><a href="#调用其他迭代对象" class="headerlink" title="调用其他迭代对象"></a>调用其他迭代对象</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">anotherGenerator</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> i + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> i + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> i + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generator</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> i;</span><br><span class="line">  <span class="keyword">yield</span>* anotherGenerator(i);<span class="comment">// 移交执行权</span></span><br><span class="line">  <span class="keyword">yield</span> i + <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = generator(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 13</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p><a target="view_window" href = "https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator">Symbol.iterator 为每一个对象定义了默认的迭代器</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myIterable = &#123;&#125;</span><br><span class="line">myIterable[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log([...myIterable]) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> nodeList = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'p'</span>)</span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">m.set(<span class="string">'a'</span>, <span class="number">100</span>)</span><br><span class="line">m.set(<span class="string">'b'</span>, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">each</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 生成遍历器</span></span><br><span class="line">    <span class="keyword">let</span> iterator = data[<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// console.log(iterator.next())  // 有数据时返回 &#123;value: 1, done: false&#125;</span></span><br><span class="line">    <span class="comment">// console.log(iterator.next())</span></span><br><span class="line">    <span class="comment">// console.log(iterator.next())</span></span><br><span class="line">    <span class="comment">// console.log(iterator.next())</span></span><br><span class="line">    <span class="comment">// console.log(iterator.next())  // 没有数据时返回 &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> item = &#123;<span class="attr">done</span>: <span class="literal">false</span>&#125; <span class="comment">// 起始循环为false</span></span><br><span class="line">    <span class="comment">// 循环遍历</span></span><br><span class="line">    <span class="keyword">while</span> (!item.done) &#123;</span><br><span class="line">        item = iterator.next() <span class="comment">// 赋值成下一个</span></span><br><span class="line">        <span class="keyword">if</span> (!item.done) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(item.value) <span class="comment">// 输出值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">each(arr)</span><br><span class="line">each(nodeList)</span><br><span class="line">each(m)</span><br></pre></td></tr></table></figure>

<h1 id="ES6中的迭代器（ES6-Interator）"><a href="#ES6中的迭代器（ES6-Interator）" class="headerlink" title="ES6中的迭代器（ES6 Interator）"></a>ES6中的迭代器（ES6 Interator）</h1><p>JS 中表示集合的数据结构：对象、数组、Map、Set。<br>iterator: 遍历器，为各种不同的数据结构提供统一的访问机制。任何数据结构，只要部署 iterator 接口就能进行遍历操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只要给对象添加[Symbol.iterator]属性就可以使用for of循环</span></span><br><span class="line"><span class="keyword">var</span> bar = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> valArr = [</span><br><span class="line">            &#123; <span class="attr">value</span>: <span class="string">'hello'</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">            &#123; <span class="attr">value</span>: <span class="string">'world'</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">            &#123; <span class="attr">value</span>: <span class="string">'!'</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">            &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">        ]</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> valArr.shift() <span class="comment">//把数组的第一个元素从其中删除，并返回第一个元素的值。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(bar.a) <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">of</span> bar) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出： hello</span></span><br><span class="line"><span class="comment">// 输出： world</span></span><br><span class="line"><span class="comment">// 输出： !</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/2020/08/12/01%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/02%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/08%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="./01.png" alt="举例"></p>
<h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><p>比如当我们进入一个聊天室/群，<br>如果有人在聊天室发言，那么这个聊天室里的所有人都会收到这个人的发言。<br>这是一个典型的发布-订阅模式，当我们加入了这个群，相当于订阅了在这个聊天室发送的消息，当有新的消息产生，聊天室会负责将消息发布给所有聊天室的订阅者。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主题，接收状态变化，触发每个观察者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="number">0</span> <span class="comment">// 状态</span></span><br><span class="line">        <span class="keyword">this</span>.observers = [] <span class="comment">// 存储订阅者</span></span><br><span class="line">    &#125;</span><br><span class="line">    getState() &#123; <span class="comment">// 获取状态方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.state</span><br><span class="line">    &#125;</span><br><span class="line">    setState(state) &#123;  <span class="comment">// 修改状态</span></span><br><span class="line">        <span class="keyword">this</span>.state = state</span><br><span class="line">        <span class="keyword">this</span>.notifyAllObservers() <span class="comment">// 触发所有监听者</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加监听者</span></span><br><span class="line">    attach(observer) &#123;</span><br><span class="line">        <span class="keyword">this</span>.observers.push(observer)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知监听者</span></span><br><span class="line">    notifyAllObservers() &#123;</span><br><span class="line">        <span class="comment">// 遍历所有监听者，调用监听者的update方法</span></span><br><span class="line">        <span class="keyword">this</span>.observers.forEach(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">            observer.update()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者，等待被触发</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, subject) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        <span class="keyword">this</span>.subject = subject  <span class="comment">// 初始化的时候就传入订阅者</span></span><br><span class="line">        <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>)  <span class="comment">// 订阅（把自己添加到订阅者里）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 观察者的更新方法</span></span><br><span class="line">    update() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> update, state: <span class="subst">$&#123;<span class="keyword">this</span>.subject.getState()&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Subject()</span><br><span class="line"><span class="keyword">let</span> o1 = <span class="keyword">new</span> Observer(<span class="string">'o1'</span>, s)</span><br><span class="line"><span class="keyword">let</span> o2 = <span class="keyword">new</span> Observer(<span class="string">'o2'</span>, s)</span><br><span class="line"><span class="keyword">let</span> o3 = <span class="keyword">new</span> Observer(<span class="string">'o3'</span>, s)</span><br><span class="line"></span><br><span class="line">s.setState(<span class="number">1</span>)</span><br><span class="line">s.setState(<span class="number">2</span>)</span><br><span class="line">s.setState(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn1"</span>&gt;</span>btu<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 这就是一个观察者模式，当button标签创建后并不会马上触发，并且按钮可以绑定多个方法，当点击按钮会触发所有订阅者</span></span></span><br><span class="line"><span class="javascript">    $(<span class="string">"#btn1"</span>).click(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    $(<span class="string">"#btn1"</span>).click(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="number">2</span>);</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    $(<span class="string">"#btn1"</span>).click(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="number">3</span>);</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>旋转动画</title>
    <url>/2020/06/29/02web/ThreeJS/01%E5%85%A5%E9%97%A8/02%E6%97%8B%E8%BD%AC%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<h1 id="requestAnimationFrame-比起-setTimeout、setInterval"><a href="#requestAnimationFrame-比起-setTimeout、setInterval" class="headerlink" title="requestAnimationFrame 比起 setTimeout、setInterval"></a>requestAnimationFrame 比起 setTimeout、setInterval</h1><ul>
<li>requestAnimationFrame()调用一个函数不是立即调用而是向浏览器发起一个执行某函数的请求， 什么时候会执行由浏览器决定<ul>
<li>浏览器可以优化并行的动画动作，更合理的重新排列动作序列</li>
<li>通过requestAnimationFrame()，JS动画能够和CSS动画/变换或SVG SMIL动画同步发生</li>
</ul>
</li>
<li>在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的的cpu，gpu和内存使用量<ul>
<li>如果在一个浏览器标签页里运行一个动画，当这个标签页不可见时，浏览器会暂停它，这会减少CPU，内存的压力，节省电池电量。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"animation"</span>);</span><br><span class="line">  <span class="built_in">window</span>.requestAnimationFrame(animate);</span><br><span class="line"> &#125;</span><br><span class="line">animate();</span><br></pre></td></tr></table></figure>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    body &#123;</span><br><span class="line">      margin: 0;</span><br><span class="line">      overflow: hidden;</span><br><span class="line"><span class="css">      <span class="comment">/* 隐藏body窗口区域滚动条 */</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--引入three.js三维引擎--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./three.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    /**</span><br><span class="line">     * 创建场景对象Scene</span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> scene = <span class="keyword">new</span> THREE.Scene();</span></span><br><span class="line">    /**</span><br><span class="line">     * 创建网格模型</span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>); <span class="comment">//创建一个立方体几何对象Geometry</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span></span><br><span class="line">      color: 0x0000ff</span><br><span class="line"><span class="actionscript">    &#125;); <span class="comment">//材质对象Material</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型对象Mesh</span></span></span><br><span class="line"><span class="actionscript">    scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span></span><br><span class="line">    /**</span><br><span class="line">     * 光源设置</span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    <span class="comment">//点光源</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> point = <span class="keyword">new</span> THREE.PointLight(<span class="number">0xffffff</span>);</span></span><br><span class="line"><span class="actionscript">    point.position.set(<span class="number">400</span>, <span class="number">200</span>, <span class="number">300</span>); <span class="comment">//点光源位置</span></span></span><br><span class="line"><span class="actionscript">    scene.add(point); <span class="comment">//点光源添加到场景中</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//环境光</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> ambient = <span class="keyword">new</span> THREE.AmbientLight(<span class="number">0x444444</span>);</span></span><br><span class="line">    scene.add(ambient);</span><br><span class="line">    /**</span><br><span class="line">     * 相机设置</span><br><span class="line">     */</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> width = <span class="built_in">window</span>.innerWidth; <span class="comment">//窗口宽度</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> height = <span class="built_in">window</span>.innerHeight; <span class="comment">//窗口高度</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> k = width / height; <span class="comment">//窗口宽高比</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> s = <span class="number">200</span>; <span class="comment">//三维场景显示范围控制系数，系数越大，显示的范围越大</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//创建相机对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> camera = <span class="keyword">new</span> THREE.OrthographicCamera(-s * k, s * k, s, -s, <span class="number">1</span>, <span class="number">1000</span>);</span></span><br><span class="line"><span class="actionscript">    camera.position.set(<span class="number">200</span>, <span class="number">300</span>, <span class="number">200</span>); <span class="comment">//设置相机位置</span></span></span><br><span class="line"><span class="actionscript">    camera.lookAt(scene.position); <span class="comment">//设置相机方向(指向的场景对象)</span></span></span><br><span class="line">    /**</span><br><span class="line">     * 创建渲染器对象</span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer();</span></span><br><span class="line"><span class="actionscript">    renderer.setSize(width, height);<span class="comment">//设置渲染区域尺寸</span></span></span><br><span class="line"><span class="actionscript">    renderer.setClearColor(<span class="number">0xb9d3ff</span>, <span class="number">1</span>); <span class="comment">//设置背景颜色</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.appendChild(renderer.domElement); <span class="comment">//body元素中插入canvas对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 渲染函数</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">render</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        renderer.render(scene,camera);<span class="comment">//执行渲染操作</span></span></span><br><span class="line"><span class="actionscript">        mesh.rotateY(<span class="number">0.01</span>);<span class="comment">//每次绕y轴旋转0.01弧度</span></span></span><br><span class="line"><span class="actionscript">        requestAnimationFrame(render);<span class="comment">//请求再次执行渲染函数render，渲染下一帧</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    render();</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>与之前代码相比较，只是封装了渲染过程和旋转</p>
<h2 id="渲染过程"><a href="#渲染过程" class="headerlink" title="渲染过程"></a>渲染过程</h2><p>通过requestAnimationFrame()进行渲染</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 渲染函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    renderer.render(scene,camera);<span class="comment">//执行渲染操作</span></span><br><span class="line">    mesh.rotateY(<span class="number">0.01</span>);<span class="comment">//每次绕y轴旋转0.01弧度</span></span><br><span class="line">    requestAnimationFrame(render);<span class="comment">//请求再次执行渲染函数render，渲染下一帧</span></span><br><span class="line">&#125;</span><br><span class="line">render();</span><br></pre></td></tr></table></figure>

<h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>通过 mesh.rotateY(0.01) 进行绕Y周旋转</p>
]]></content>
  </entry>
  <entry>
    <title>HelloWorld</title>
    <url>/2020/06/29/02web/ThreeJS/01%E5%85%A5%E9%97%A8/01HelloWorld/</url>
    <content><![CDATA[<h1 id="什么是ThreeJS"><a href="#什么是ThreeJS" class="headerlink" title="什么是ThreeJS"></a>什么是ThreeJS</h1><ul>
<li>three.js是JavaScript编写的WebGL第三方库</li>
<li>WebGL（全写Web Graphics Library）是一种3D绘图协议，这种绘图技术标准允许把JavaScript和OpenGL ES 2.0结合在一起，通过增加OpenGL ES 2.0的一个JavaScript绑定，WebGL可以为HTML5 Canvas提供硬件3D加速渲染</li>
</ul>
<h2 id="整体代码"><a href="#整体代码" class="headerlink" title="整体代码"></a>整体代码</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    body &#123;</span><br><span class="line">      margin: 0;</span><br><span class="line">      overflow: hidden;</span><br><span class="line"><span class="css">      <span class="comment">/* 隐藏body窗口区域滚动条 */</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--引入three.js三维引擎--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./three.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    /**</span><br><span class="line">     * 创建场景对象Scene</span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> scene = <span class="keyword">new</span> THREE.Scene();</span></span><br><span class="line">    /**</span><br><span class="line">     * 创建网格模型</span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    <span class="comment">// var geometry = new THREE.SphereGeometry(60, 40, 40); //创建一个球体几何对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>); <span class="comment">//创建一个立方体几何对象Geometry</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span></span><br><span class="line">      color: 0x0000ff</span><br><span class="line"><span class="actionscript">    &#125;); <span class="comment">//材质对象Material</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型对象Mesh</span></span></span><br><span class="line"><span class="actionscript">    scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span></span><br><span class="line">    /**</span><br><span class="line">     * 光源设置</span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    <span class="comment">//点光源</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> point = <span class="keyword">new</span> THREE.PointLight(<span class="number">0xffffff</span>);</span></span><br><span class="line"><span class="actionscript">    point.position.set(<span class="number">400</span>, <span class="number">200</span>, <span class="number">300</span>); <span class="comment">//点光源位置</span></span></span><br><span class="line"><span class="actionscript">    scene.add(point); <span class="comment">//点光源添加到场景中</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//环境光</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> ambient = <span class="keyword">new</span> THREE.AmbientLight(<span class="number">0x444444</span>);</span></span><br><span class="line">    scene.add(ambient);</span><br><span class="line">    /**</span><br><span class="line">     * 相机设置</span><br><span class="line">     */</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> width = <span class="built_in">window</span>.innerWidth; <span class="comment">//窗口宽度</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> height = <span class="built_in">window</span>.innerHeight; <span class="comment">//窗口高度</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> k = width / height; <span class="comment">//窗口宽高比</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> s = <span class="number">200</span>; <span class="comment">//三维场景显示范围控制系数，系数越大，显示的范围越大</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//创建相机对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> camera = <span class="keyword">new</span> THREE.OrthographicCamera(-s * k, s * k, s, -s, <span class="number">1</span>, <span class="number">1000</span>);</span></span><br><span class="line"><span class="actionscript">    camera.position.set(<span class="number">200</span>, <span class="number">300</span>, <span class="number">200</span>); <span class="comment">//设置相机位置</span></span></span><br><span class="line"><span class="actionscript">    camera.lookAt(scene.position); <span class="comment">//设置相机方向(指向的场景对象)</span></span></span><br><span class="line">    /**</span><br><span class="line">     * 创建渲染器对象</span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer();</span></span><br><span class="line"><span class="actionscript">    renderer.setSize(width, height);<span class="comment">//设置渲染区域尺寸</span></span></span><br><span class="line"><span class="actionscript">    renderer.setClearColor(<span class="number">0xb9d3ff</span>, <span class="number">1</span>); <span class="comment">//设置背景颜色</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.appendChild(renderer.domElement); <span class="comment">//body元素中插入canvas对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//执行渲染操作   指定场景、相机作为参数</span></span></span><br><span class="line">    renderer.render(scene, camera);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="代码说明及四要素"><a href="#代码说明及四要素" class="headerlink" title="代码说明及四要素"></a>代码说明及四要素</h1><h2 id="引入js引擎"><a href="#引入js引擎" class="headerlink" title="引入js引擎"></a>引入js引擎</h2><p>在.html文件中引入three.js就像前端经常使用的jquery.js一样引入即可。</p>
<ul>
<li>可以通过本地文件加载</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--相对地址加载--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./three.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>*也可以通过URL地址去加载</p>
<h2 id="几何体Geometry"><a href="#几何体Geometry" class="headerlink" title="几何体Geometry"></a>几何体Geometry</h2><p>通过构造函数THREE.BoxGeometry()创建了一个长宽高都是100的立方体</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个立方体几何对象Geometry</span></span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<h2 id="材质Material"><a href="#材质Material" class="headerlink" title="材质Material"></a>材质Material</h2><p>通过构造函数THREE.MeshLambertMaterial()创建了一个可以用于立方体的材质对象， 构造函数的参数是一个对象，对象包含了颜色、透明度等属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">      color: <span class="number">0x0000ff</span></span><br><span class="line">    &#125;); <span class="comment">//材质对象Material</span></span><br></pre></td></tr></table></figure>

<h2 id="光源Light"><a href="#光源Light" class="headerlink" title="光源Light"></a>光源Light</h2><p>通过构造函数THREE.PointLight()创建了一个点光源对象，参数0xffffff定义的是光照强度</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//点光源</span></span><br><span class="line"><span class="keyword">var</span> point = <span class="keyword">new</span> THREE.PointLight(<span class="number">0xffffff</span>);</span><br></pre></td></tr></table></figure>

<h2 id="相机Camera"><a href="#相机Camera" class="headerlink" title="相机Camera"></a>相机Camera</h2><p>通过构造函数THREE.OrthographicCamera()创建了一个正射投影相机对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建相机对象</span></span><br><span class="line"><span class="keyword">var</span> camera = <span class="keyword">new</span> THREE.OrthographicCamera(-s * k, s * k, s, -s, <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">camera.position.set(<span class="number">200</span>, <span class="number">300</span>, <span class="number">200</span>); <span class="comment">//设置相机位置</span></span><br><span class="line">camera.lookAt(scene.position); <span class="comment">//设置相机方向(指向的场景对象)</span></span><br></pre></td></tr></table></figure>
<h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><p><img src="./01.png" alt="程序结构"></p>
]]></content>
  </entry>
  <entry>
    <title>插入多个集合体</title>
    <url>/2020/06/29/02web/ThreeJS/01%E5%85%A5%E9%97%A8/04%E6%8F%92%E5%85%A5%E5%A4%9A%E4%B8%AA%E5%87%A0%E4%BD%95%E4%BD%93/</url>
    <content><![CDATA[<h1 id="几何体"><a href="#几何体" class="headerlink" title="几何体"></a>几何体</h1><h2 id="SphereGeometry圆球"><a href="#SphereGeometry圆球" class="headerlink" title="SphereGeometry圆球"></a>SphereGeometry圆球</h2><blockquote>
<p>SphereGeometry(radius, widthSegments, heightSegments)</p>
</blockquote>
<ul>
<li>第一个参数radius约束的是球的大小</li>
<li>widthSegments、heightSegments约束的是球面的精度，球体你可以理解为正多面体，就像圆一样是正多边形，当分割的边足够多的时候，正多边形就会无限接近于圆</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td>radius</td>
<td align="center">球体半径</td>
</tr>
<tr>
<td>widthSegments</td>
<td align="center">控制球面精度，水平细分数</td>
</tr>
</tbody></table>
<h2 id="更多几何体"><a href="#更多几何体" class="headerlink" title="更多几何体"></a>更多几何体</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//长方体 参数：长，宽，高</span></span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"><span class="comment">// 球体 参数：半径60  经纬度细分数40,40</span></span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.SphereGeometry(<span class="number">60</span>, <span class="number">40</span>, <span class="number">40</span>);</span><br><span class="line"><span class="comment">// 圆柱  参数：圆柱面顶部、底部直径50,50   高度100  圆周分段数</span></span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.CylinderGeometry( <span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">25</span> );</span><br><span class="line"><span class="comment">// 正八面体</span></span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.OctahedronGeometry(<span class="number">50</span>);</span><br><span class="line"><span class="comment">// 正十二面体</span></span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.DodecahedronGeometry(<span class="number">50</span>);</span><br><span class="line"><span class="comment">// 正二十面体</span></span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.IcosahedronGeometry(<span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<h2 id="辅助三维坐标系AxisHelper"><a href="#辅助三维坐标系AxisHelper" class="headerlink" title="辅助三维坐标系AxisHelper"></a>辅助三维坐标系AxisHelper</h2><p>为了方便调试预览threejs提供了一个辅助三维坐标系AxisHelper，可以直接调用THREE.AxisHelper创建一个三维坐标系，然后通过.add()方法插入到场景中即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 辅助坐标系  参数250表示坐标系大小，可以根据场景大小去设置</span></span><br><span class="line"><span class="keyword">var</span> axisHelper = <span class="keyword">new</span> THREE.AxisHelper(<span class="number">250</span>);</span><br><span class="line">scene.add(axisHelper);</span><br></pre></td></tr></table></figure>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    body &#123;</span><br><span class="line">      margin: 0;</span><br><span class="line">      overflow: hidden;</span><br><span class="line"><span class="css">      <span class="comment">/* 隐藏body窗口区域滚动条 */</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--引入three.js三维引擎--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./three.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入threejs扩展控件OrbitControls.js --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./OrbitControls.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    /**</span><br><span class="line">     * 创建场景对象Scene</span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> scene = <span class="keyword">new</span> THREE.Scene();</span></span><br><span class="line">    /**</span><br><span class="line">     * 创建网格模型</span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    <span class="comment">// 立方体网格模型</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> geometry1 = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> material1 = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span></span><br><span class="line">      color: 0x0000ff</span><br><span class="line"><span class="actionscript">    &#125;); <span class="comment">//材质对象Material</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> mesh1 = <span class="keyword">new</span> THREE.Mesh(geometry1, material1); <span class="comment">//网格模型对象Mesh</span></span></span><br><span class="line"><span class="actionscript">    scene.add(mesh1); <span class="comment">//网格模型添加到场景中</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 球体网格模型</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> geometry2 = <span class="keyword">new</span> THREE.SphereGeometry(<span class="number">60</span>, <span class="number">40</span>, <span class="number">40</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> material2 = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span></span><br><span class="line">      color: 0xff00ff</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> mesh2 = <span class="keyword">new</span> THREE.Mesh(geometry2, material2); <span class="comment">//网格模型对象Mesh</span></span></span><br><span class="line"><span class="actionscript">    mesh2.translateY(<span class="number">120</span>); <span class="comment">//球体网格模型沿Y轴正方向平移120</span></span></span><br><span class="line">    scene.add(mesh2);</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 圆柱网格模型</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> geometry3 = <span class="keyword">new</span> THREE.CylinderGeometry(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">25</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> material3 = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span></span><br><span class="line">      color: 0xffff00</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> mesh3 = <span class="keyword">new</span> THREE.Mesh(geometry3, material3); <span class="comment">//网格模型对象Mesh</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// mesh3.translateX(120); //球体网格模型沿Y轴正方向平移120</span></span></span><br><span class="line"><span class="actionscript">    mesh3.position.set(<span class="number">120</span>,<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//设置mesh3模型对象的xyz坐标为120,0,0</span></span></span><br><span class="line"><span class="actionscript">    scene.add(mesh3); <span class="comment">//</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 辅助坐标系</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> axisHelper = <span class="keyword">new</span> THREE.AxisHelper(<span class="number">250</span>);</span></span><br><span class="line">    scene.add(axisHelper);</span><br><span class="line">    /**</span><br><span class="line">     * 光源设置</span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    <span class="comment">//点光源</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> point = <span class="keyword">new</span> THREE.PointLight(<span class="number">0xffffff</span>);</span></span><br><span class="line"><span class="actionscript">    point.position.set(<span class="number">400</span>, <span class="number">200</span>, <span class="number">300</span>); <span class="comment">//点光源位置</span></span></span><br><span class="line"><span class="actionscript">    scene.add(point); <span class="comment">//点光源添加到场景中</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//环境光</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> ambient = <span class="keyword">new</span> THREE.AmbientLight(<span class="number">0x444444</span>);</span></span><br><span class="line">    scene.add(ambient);</span><br><span class="line">    /**</span><br><span class="line">     * 相机设置</span><br><span class="line">     */</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> width = <span class="built_in">window</span>.innerWidth; <span class="comment">//窗口宽度</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> height = <span class="built_in">window</span>.innerHeight; <span class="comment">//窗口高度</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> k = width / height; <span class="comment">//窗口宽高比</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> s = <span class="number">150</span>; <span class="comment">//三维场景显示范围控制系数，系数越大，显示的范围越大</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//创建相机对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> camera = <span class="keyword">new</span> THREE.OrthographicCamera(-s * k, s * k, s, -s, <span class="number">1</span>, <span class="number">1000</span>);</span></span><br><span class="line"><span class="actionscript">    camera.position.set(<span class="number">200</span>, <span class="number">300</span>, <span class="number">200</span>); <span class="comment">//设置相机位置</span></span></span><br><span class="line"><span class="actionscript">    camera.lookAt(scene.position); <span class="comment">//设置相机方向(指向的场景对象)</span></span></span><br><span class="line">    /**</span><br><span class="line">     * 创建渲染器对象</span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer();</span></span><br><span class="line"><span class="actionscript">    renderer.setSize(width, height); <span class="comment">//设置渲染区域尺寸</span></span></span><br><span class="line"><span class="actionscript">    renderer.setClearColor(<span class="number">0x666666</span>, <span class="number">1</span>); <span class="comment">//设置背景颜色</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.appendChild(renderer.domElement); <span class="comment">//body元素中插入canvas对象</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 渲染函数</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">render</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">      renderer.render(scene, camera); <span class="comment">//执行渲染操作</span></span></span><br><span class="line"><span class="actionscript">      requestAnimationFrame(render); <span class="comment">//请求再次执行渲染函数render，渲染下一帧</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    render();</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> controls = <span class="keyword">new</span> THREE.OrbitControls(camera,renderer.domElement); <span class="comment">//创建控件对象</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>鼠标操作</title>
    <url>/2020/06/29/02web/ThreeJS/01%E5%85%A5%E9%97%A8/03%E9%BC%A0%E6%A0%87%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="OrbitControls-js"><a href="#OrbitControls-js" class="headerlink" title="OrbitControls.js"></a>OrbitControls.js</h1><p>为了使用鼠标操作三维场景，可以借助three.js众多控件之一OrbitControls.js，可以在下载的three.js-master文件中找到(three.js-master\examples\js\controls)。 然后和引入three.js文件一样在html文件中引入控件OrbitControls.js</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li>封装渲染为一个方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 渲染函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  renderer.render(scene, camera); <span class="comment">//执行渲染操作</span></span><br><span class="line">&#125;</span><br><span class="line">render();</span><br></pre></td></tr></table></figure>

<ul>
<li>调用控件方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建控件对象  相机对象camera作为参数   控件可以监听鼠标的变化，改变相机对象的属性</span></span><br><span class="line">    <span class="keyword">var</span> controls = <span class="keyword">new</span> THREE.OrbitControls(camera,renderer.domElement);</span><br></pre></td></tr></table></figure>

<ul>
<li>监听鼠标事件重新渲染</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//监听鼠标事件，触发渲染函数，更新canvas画布渲染效果</span></span><br><span class="line">controls.addEventListener(<span class="string">'change'</span>, render);</span><br></pre></td></tr></table></figure>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">      margin: <span class="number">0</span>;</span><br><span class="line">      overflow: hidden;</span><br><span class="line">      <span class="comment">/* 隐藏body窗口区域滚动条 */</span></span><br><span class="line">    &#125;</span><br><span class="line">  &lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">  &lt;!--引入three.js三维引擎--&gt;</span></span><br><span class="line"><span class="regexp">  &lt;script src="./</span>three.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">  &lt;!-- 引入threejs扩展控件OrbitControls.js --&gt;</span></span><br><span class="line"><span class="string">  &lt;script src="</span>./OrbitControls.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">  &lt;script&gt;</span></span><br><span class="line"><span class="string">    /**</span></span><br><span class="line"><span class="string">     * 创建场景对象Scene</span></span><br><span class="line"><span class="string">     */</span></span><br><span class="line"><span class="string">    var scene = new THREE.Scene();</span></span><br><span class="line"><span class="string">    /**</span></span><br><span class="line"><span class="string">     * 创建网格模型</span></span><br><span class="line"><span class="string">     */</span></span><br><span class="line"><span class="string">    var geometry = new THREE.BoxGeometry(100, 100, 100); //创建一个立方体几何对象Geometry</span></span><br><span class="line"><span class="string">    var material = new THREE.MeshLambertMaterial(&#123;</span></span><br><span class="line"><span class="string">      color: 0x0000ff</span></span><br><span class="line"><span class="string">    &#125;); //材质对象Material</span></span><br><span class="line"><span class="string">    var mesh = new THREE.Mesh(geometry, material); //网格模型对象Mesh</span></span><br><span class="line"><span class="string">    scene.add(mesh); //网格模型添加到场景中</span></span><br><span class="line"><span class="string">    /**</span></span><br><span class="line"><span class="string">     * 光源设置</span></span><br><span class="line"><span class="string">     */</span></span><br><span class="line"><span class="string">    //点光源</span></span><br><span class="line"><span class="string">    var point = new THREE.PointLight(0xffffff);</span></span><br><span class="line"><span class="string">    point.position.set(400, 200, 300); //点光源位置</span></span><br><span class="line"><span class="string">    scene.add(point); //点光源添加到场景中</span></span><br><span class="line"><span class="string">    //环境光</span></span><br><span class="line"><span class="string">    var ambient = new THREE.AmbientLight(0x444444);</span></span><br><span class="line"><span class="string">    scene.add(ambient);</span></span><br><span class="line"><span class="string">    /**</span></span><br><span class="line"><span class="string">     * 相机设置</span></span><br><span class="line"><span class="string">     */</span></span><br><span class="line"><span class="string">    var width = window.innerWidth; //窗口宽度</span></span><br><span class="line"><span class="string">    var height = window.innerHeight; //窗口高度</span></span><br><span class="line"><span class="string">    var k = width / height; //窗口宽高比</span></span><br><span class="line"><span class="string">    var s = 150; //三维场景显示范围控制系数，系数越大，显示的范围越大</span></span><br><span class="line"><span class="string">    //创建相机对象</span></span><br><span class="line"><span class="string">    var camera = new THREE.OrthographicCamera(-s * k, s * k, s, -s, 1, 1000);</span></span><br><span class="line"><span class="string">    camera.position.set(200, 300, 200); //设置相机位置</span></span><br><span class="line"><span class="string">    camera.lookAt(scene.position); //设置相机方向(指向的场景对象)</span></span><br><span class="line"><span class="string">    /**</span></span><br><span class="line"><span class="string">     * 创建渲染器对象</span></span><br><span class="line"><span class="string">     */</span></span><br><span class="line"><span class="string">    var renderer = new THREE.WebGLRenderer();</span></span><br><span class="line"><span class="string">    renderer.setSize(width, height); //设置渲染区域尺寸</span></span><br><span class="line"><span class="string">    renderer.setClearColor(0xb9d3ff, 1); //设置背景颜色</span></span><br><span class="line"><span class="string">    document.body.appendChild(renderer.domElement); //body元素中插入canvas对象</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // 渲染函数</span></span><br><span class="line"><span class="string">    function render() &#123;</span></span><br><span class="line"><span class="string">      renderer.render(scene, camera); //执行渲染操作</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    render();</span></span><br><span class="line"><span class="string">    //创建控件对象  相机对象camera作为参数   控件可以监听鼠标的变化，改变相机对象的属性</span></span><br><span class="line"><span class="string">    var controls = new THREE.OrbitControls(camera,renderer.domElement);</span></span><br><span class="line"><span class="string">    //监听鼠标事件，触发渲染函数，更新canvas画布渲染效果</span></span><br><span class="line"><span class="string">    controls.addEventListener('change', render);</span></span><br><span class="line"><span class="string">  &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>其他设计模式</title>
    <url>/2020/08/12/01%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/02%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/11%E5%85%B6%E4%BB%96%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><p>创建对象开销比较大时，我们通过clone一个存在的对象来创建新对象<br>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个原型对象</span></span><br><span class="line"><span class="keyword">let</span> prototype = &#123;</span><br><span class="line">    getName:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.first + <span class="string">""</span> + <span class="keyword">this</span>.last;</span><br><span class="line">    &#125;,</span><br><span class="line">    say:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      alert(<span class="string">"hello"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于原型创建x</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="built_in">Object</span>.create(prototype); <span class="comment">// 用Object.create来clone对象</span></span><br><span class="line">x.first = <span class="string">"A"</span>;</span><br><span class="line">x.last = <span class="string">"B"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x.getName());</span><br><span class="line">x.say();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于原型创建y</span></span><br><span class="line"><span class="keyword">let</span> y = <span class="built_in">Object</span>.create(prototype);</span><br><span class="line">y.first = <span class="string">"C"</span>;</span><br><span class="line">y.last = <span class="string">"D"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(y.getName());</span><br><span class="line">y.say();</span><br></pre></td></tr></table></figure>

<h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><p>在我们画图形，图形和颜色会有好多种组合，如果每个组合都创建一个对象会有好多类，这时候我们可以把图形和颜色抽离出来，变成两个类</p>
<p><img src="./01.png" alt="举例"><br><img src="./02.png" alt="举例"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 颜色类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图形类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name,color)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.color = color; <span class="comment">// 图形类接受颜色</span></span><br><span class="line">    &#125;</span><br><span class="line">    draw()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.color.name&#125;</span><span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>) <span class="comment">// 画图方法，拼接颜色和图形</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">let</span> red  = <span class="keyword">new</span> Color(<span class="string">"red"</span>);</span><br><span class="line"><span class="keyword">let</span> yellow  = <span class="keyword">new</span> Color(<span class="string">"yellow"</span>);</span><br><span class="line"><span class="keyword">let</span> circle  = <span class="keyword">new</span> Shape(<span class="string">"circle"</span>,red);</span><br><span class="line">circle.draw(); <span class="comment">// 画红色圆形</span></span><br><span class="line"><span class="keyword">let</span> triangle  = <span class="keyword">new</span> Shape(<span class="string">"triangle"</span>,yellow);</span><br><span class="line">triangle.draw();  <span class="comment">// 画黄色三角</span></span><br></pre></td></tr></table></figure>

<h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><p>组合模式 （Composite Pattern）又叫整体-部分模式，它允许你将对象组合成树形结构来表现整体-部分层次结构，让使用者可以以一致的方式处理组合对象以及部分对象。<br>虚拟DOM树就是一种组合模式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面对象的结构就是组合模式，处理父子节点可以用相同方法处理</span></span><br><span class="line"><span class="keyword">var</span> tree= &#123;</span><br><span class="line">    tag:<span class="string">"div"</span>,</span><br><span class="line">    attr:&#123;</span><br><span class="line">        id:<span class="string">"div1"</span>,</span><br><span class="line">        className:<span class="string">"container"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    children:[</span><br><span class="line">        &#123;</span><br><span class="line">            tar:<span class="string">"p"</span>,</span><br><span class="line">            attr:&#123;&#125;,</span><br><span class="line">            children:[<span class="string">"123"</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            tar:<span class="string">"p"</span>,</span><br><span class="line">            attr:&#123;&#125;,</span><br><span class="line">            children:[<span class="string">"456"</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>在本地一个「电影」文件夹下有两个子文件夹「漫威英雄电影」和「DC英雄电影」，<br>分别各自有一些电影文件，我们要做的就是在这个电影文件夹里找大于 2G 的电影文件，无论是在这个文件夹下还是在子文件夹下，并输出它的文件名和文件大小。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建文件夹 */</span></span><br><span class="line"><span class="keyword">var</span> createFolder = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        _children: [],</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 在文件夹下增加文件或文件夹 */</span></span><br><span class="line">        add(fileOrFolder) &#123;</span><br><span class="line">            <span class="keyword">this</span>._children.push(fileOrFolder)</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 扫描方法 */</span></span><br><span class="line">        scan(cb) &#123; <span class="comment">// cd是一个执行方法</span></span><br><span class="line">            <span class="keyword">this</span>._children.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">child</span>) </span>&#123;</span><br><span class="line">                child.scan(cb)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建文件 */</span></span><br><span class="line"><span class="keyword">var</span> createFile = <span class="function"><span class="keyword">function</span>(<span class="params">name, size</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        size: size,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 在文件下增加文件，应报错 */</span></span><br><span class="line">        add() &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'文件下面不能再添加文件'</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 执行扫描方法 */</span></span><br><span class="line">        scan(cb) &#123; <span class="comment">// cd是一个执行方法，this就是下面的item</span></span><br><span class="line">            cb(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foldMovies = createFolder(<span class="string">'电影'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建子文件夹，并放入根文件夹</span></span><br><span class="line"><span class="keyword">var</span> foldMarvelMovies = createFolder(<span class="string">'漫威英雄电影'</span>)</span><br><span class="line">foldMovies.add(foldMarvelMovies)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foldDCMovies = createFolder(<span class="string">'DC英雄电影'</span>)</span><br><span class="line">foldMovies.add(foldDCMovies)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为两个子文件夹分别添加电影</span></span><br><span class="line">foldMarvelMovies.add(createFile(<span class="string">'钢铁侠.mp4'</span>, <span class="number">1.9</span>))</span><br><span class="line">foldMarvelMovies.add(createFile(<span class="string">'蜘蛛侠.mp4'</span>, <span class="number">2.1</span>))</span><br><span class="line">foldMarvelMovies.add(createFile(<span class="string">'金刚狼.mp4'</span>, <span class="number">2.3</span>))</span><br><span class="line">foldMarvelMovies.add(createFile(<span class="string">'黑寡妇.mp4'</span>, <span class="number">1.9</span>))</span><br><span class="line">foldMarvelMovies.add(createFile(<span class="string">'美国队长.mp4'</span>, <span class="number">1.4</span>))</span><br><span class="line"></span><br><span class="line">foldDCMovies.add(createFile(<span class="string">'蝙蝠侠.mp4'</span>, <span class="number">2.4</span>))</span><br><span class="line">foldDCMovies.add(createFile(<span class="string">'超人.mp4'</span>, <span class="number">1.6</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'size 大于2G的文件有：'</span>)</span><br><span class="line">foldMovies.scan(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (item.size &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'name:'</span> + item.name + <span class="string">' size:'</span> + item.size + <span class="string">'GB'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// size 大于2G的文件有：</span></span><br><span class="line"><span class="comment">// name:蜘蛛侠.mp4 size:2.1GB</span></span><br><span class="line"><span class="comment">// name:金刚狼.mp4 size:2.3GB</span></span><br><span class="line"><span class="comment">// name:蝙蝠侠.mp4 size:2.4GB</span></span><br></pre></td></tr></table></figure>
<h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><p>给无限下拉列表绑定事件时，如果每一个标签都绑定事件则开销非常大，我们可以把绑定事件放到父级标签上</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--无限下拉列表，将事件代理到高层节点上--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--如果都绑定到a标签上，对内存开销太大--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">name</span>=<span class="string">"A"</span>&gt;</span>a1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>a1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>a1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>a1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">"div1"</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 所有a标签都共享一个click事件</span></span></span><br><span class="line"><span class="actionscript">    div1.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span> <span class="params">(e)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> target = e.target;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(target.name);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">if</span>(target.name === <span class="string">'A'</span>)&#123;</span></span><br><span class="line">            alert(target.innerHTML)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>超市购买物品时，会员，VIP以及普通用户购买物品价格不同，如果用if…else，如果再添加其他策略则又要增加if…else<br>这时候我们可以考虑使用策略模式<br>把一个User类抽离成3个类</p>
<ul>
<li>正常写法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(type)&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">    buy()&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.type === <span class="string">"ordinary"</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"普通用户购买"</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.type === <span class="string">"member"</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"会员购买"</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.type === <span class="string">"vip"</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"VIP用户购买"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> u1 = <span class="keyword">new</span> User(<span class="string">"ordinary"</span>);</span><br><span class="line">u1.buy();</span><br><span class="line"><span class="keyword">var</span> u2 = <span class="keyword">new</span> User(<span class="string">"member"</span>);</span><br><span class="line">u2.buy();</span><br><span class="line"><span class="keyword">var</span> u3 = <span class="keyword">new</span> User(<span class="string">"vip"</span>);</span><br><span class="line">u3.buy();</span><br></pre></td></tr></table></figure>

<ul>
<li>使用策略模式</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrdinaryUser</span> </span>&#123;</span><br><span class="line">    buy()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"普通用户购买"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemberUser</span> </span>&#123;</span><br><span class="line">    buy()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"会员用户购买"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VipUser</span> </span>&#123;</span><br><span class="line">    buy()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"vip用户购买"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> u1 = <span class="keyword">new</span> OrdinaryUser();</span><br><span class="line">u1.buy();</span><br><span class="line"><span class="keyword">var</span> u2 = <span class="keyword">new</span> MemberUser();</span><br><span class="line">u2.buy();</span><br><span class="line"><span class="keyword">var</span> u3 = <span class="keyword">new</span> VipUser();</span><br><span class="line">u3.buy();</span><br></pre></td></tr></table></figure>

<h1 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h1><ul>
<li>一步操作可能分为多个职责角色来完成</li>
<li>把这些角色都分开，然后用一个链串起来</li>
<li>将发起者和各个处理者进行隔离</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请假审批，需要组长审批，经理审批，最后总监审批</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Action</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.nextAction = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置下一级审批人</span></span><br><span class="line">    setNextAction(action)&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextAction = action; <span class="comment">// 赋值下一级审批人</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行审批方法</span></span><br><span class="line">    handle()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>审批`</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.nextAction != <span class="literal">null</span>)&#123; <span class="comment">// 如果有下一级审批人则下一级审批人执行审批</span></span><br><span class="line">            <span class="keyword">this</span>.nextAction.handle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> Action(<span class="string">"组长"</span>);</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Action(<span class="string">"经理"</span>);</span><br><span class="line"><span class="keyword">let</span> a3 = <span class="keyword">new</span> Action(<span class="string">"总监"</span>);</span><br><span class="line">a1.setNextAction(a2);</span><br><span class="line">a2.setNextAction(a3);</span><br><span class="line">a1.handle();</span><br></pre></td></tr></table></figure>

<p>职责链模式可能在真实的业务代码中见的不多，但是作用域链、原型链、DOM 事件流的事件冒泡，都有职责链模式的影子:</p>
<ul>
<li>作用域链： 查找变量时，先从当前上下文的变量对象中查找，如果没有找到，就会从父级执行上下文的变量对象中查找，一直找到全局上下文的变量对象。</li>
<li>原型链： 当读取实例的属性时，如果找不到，就会查找当前对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。</li>
<li>事件冒泡： 事件在 DOM 元素上触发后，会从最内层的元素开始发生，一直向外层元素传播，直到全局 document 对象。</li>
</ul>
<h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><p>命令模式 （Command Pattern）又称事务模式，将请求封装成对象，将命令的发送者和接受者解耦。本质上是对方法调用的封装</p>
<p><img src="./03.png" alt="举例"></p>
<ul>
<li>执行命令时，发布者和执行者分开</li>
<li>中间加入命令对象，作为中转站</li>
<li>将发起者和各个处理者进行隔离</li>
</ul>
<p>将军发布命令，将军会把命令传递给小号手进行传递，小号手把命令传递给士兵，士兵再去执行将军的命令</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 真正的执行者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span></span>&#123;</span><br><span class="line">    exec()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 命令对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Command</span></span>&#123;</span><br><span class="line">    <span class="comment">// 需要传递执行者</span></span><br><span class="line">    <span class="keyword">constructor</span>(receiver)&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 触发执行者执行命令</span></span><br><span class="line">    cmd()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"触发命令"</span>);</span><br><span class="line">        <span class="keyword">this</span>.receiver.exec(); <span class="comment">// 让执行者开始执行命令</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 触发者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invoker</span></span>&#123;</span><br><span class="line">    <span class="comment">// 需要传递执行命令</span></span><br><span class="line">    <span class="keyword">constructor</span>(command)&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = command</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 触发执行命令的命令</span></span><br><span class="line">    invoke()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"开始"</span>)</span><br><span class="line">        <span class="keyword">this</span>.command.cmd(); <span class="comment">// 执行命令下达</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 士兵</span></span><br><span class="line"><span class="keyword">let</span> soldier = <span class="keyword">new</span> Receiver();</span><br><span class="line"><span class="comment">// 小号手</span></span><br><span class="line"><span class="keyword">let</span> trumpeter = <span class="keyword">new</span> Command(soldier);</span><br><span class="line"><span class="comment">// 将军</span></span><br><span class="line"><span class="keyword">let</span> general = <span class="keyword">new</span> Invoker(trumpeter);</span><br><span class="line">general.invoke();</span><br></pre></td></tr></table></figure>

<h1 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h1><ul>
<li>随时记录一个对象的状态变化</li>
<li>随时可以回复之前的某个状态（比如撤销功能）<br>文本编辑器经常会有撤销功能，我们需要有一个容器（list）存储我们这些内容，在撤销到哪步时可以从list中直接获取</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 备忘录类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memento</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(content)&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取值</span></span><br><span class="line">    getContent()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.content</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 备忘录列表类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CareTaker</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给备忘列表添加备忘</span></span><br><span class="line">    add(memento)&#123;</span><br><span class="line">        <span class="keyword">this</span>.list.push(memento)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据list下标获取备忘</span></span><br><span class="line">    <span class="keyword">get</span>(index)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.list[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编辑器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Editor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输入内容</span></span><br><span class="line">    setContent(content)&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取内容</span></span><br><span class="line">    getContent()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.content</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把当前内容保存成备忘对象</span></span><br><span class="line">    saveContentToMemento()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Memento(<span class="keyword">this</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把当前内同变成从备忘对象中获取的内容</span></span><br><span class="line">    getContentFromMemento(memento)&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = memento.getContent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> editor = <span class="keyword">new</span> Editor();</span><br><span class="line"><span class="keyword">let</span> careTaker = <span class="keyword">new</span> CareTaker();</span><br><span class="line">editor.setContent(<span class="string">"111"</span>);</span><br><span class="line">editor.setContent(<span class="string">"222"</span>);</span><br><span class="line">careTaker.add(editor.saveContentToMemento())  <span class="comment">// 存储备忘录(备忘录列表中push进去一个备忘录对象)</span></span><br><span class="line">editor.setContent(<span class="string">"333"</span>);</span><br><span class="line">careTaker.add(editor.saveContentToMemento())  <span class="comment">// 存储备忘录</span></span><br><span class="line">editor.setContent(<span class="string">"444"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(editor.getContent());</span><br><span class="line">editor.getContentFromMemento(careTaker.get(<span class="number">1</span>)) <span class="comment">// 撤销(将当前内容赋值为从备忘录列表中取出的备忘录对象内容)</span></span><br><span class="line"><span class="built_in">console</span>.log(editor.getContent());</span><br><span class="line">editor.getContentFromMemento(careTaker.get(<span class="number">0</span>)) <span class="comment">// 撤销</span></span><br><span class="line"><span class="built_in">console</span>.log(editor.getContent());</span><br></pre></td></tr></table></figure>

<h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><p><img src="./04.png" alt="举例"><br><img src="./05.png" alt="举例"></p>
<p>房客和房东并不会当面交易，而是通过中介来进行交易。房东拿到的房租也是中介的报价，房客的房租也是中介的报价，二者不会直接接触</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中介者类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mediator</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(a,b)&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    setA()&#123; <span class="comment">// 中介者修改A</span></span><br><span class="line">        <span class="keyword">let</span> number = <span class="keyword">this</span>.b.number;</span><br><span class="line">        <span class="keyword">this</span>.a.setNumber(number * <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setB()&#123; <span class="comment">// 中介者修改B</span></span><br><span class="line">        <span class="keyword">let</span> number = <span class="keyword">this</span>.a.number;</span><br><span class="line">        <span class="keyword">this</span>.b.setNumber(number / <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setNumber(num,m)&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = num; <span class="comment">// 如果时中介者改值直接修改</span></span><br><span class="line">        <span class="keyword">if</span>(m)&#123; <span class="comment">// 非中介者修改值调用让中介者去修改</span></span><br><span class="line">            m.setB();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setNumber(num,m)&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = num; <span class="comment">// 如果时中介者改值直接修改</span></span><br><span class="line">        <span class="keyword">if</span>(m)&#123;<span class="comment">// 非中介者修改值调用让中介者去修改</span></span><br><span class="line">            m.setA();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> A();</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> Mediator(a,b);</span><br><span class="line">a.setNumber(<span class="number">100</span>,m);</span><br><span class="line"><span class="built_in">console</span>.log(a.number,b.number);</span><br><span class="line">b.setNumber(<span class="number">100</span>,m);</span><br><span class="line"><span class="built_in">console</span>.log(a.number,b.number);</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>材质</title>
    <url>/2020/06/29/02web/ThreeJS/01%E5%85%A5%E9%97%A8/05%E6%9D%90%E8%B4%A8/</url>
    <content><![CDATA[<h1 id="几种材质类型"><a href="#几种材质类型" class="headerlink" title="几种材质类型"></a>几种材质类型</h1><table>
<thead>
<tr>
<th>材质类型</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td>MeshBasicMaterial</td>
<td align="center">基础网格材质，不受光照影响的材质</td>
</tr>
<tr>
<td>MeshLambertMaterial</td>
<td align="center">Lambert网格材质，与光照有反应，漫反射</td>
</tr>
<tr>
<td>MeshPhongMaterial</td>
<td align="center">高光Phong材质,与光照有反应</td>
</tr>
<tr>
<td>MeshStandardMaterial</td>
<td align="center">PBR物理材质，相比较高光Phong材质可以更好的模拟金属、玻璃等效果</td>
</tr>
</tbody></table>
<h2 id="基础网格材质"><a href="#基础网格材质" class="headerlink" title="基础网格材质"></a>基础网格材质</h2><p>基础网格材质，不受光照影响的材质</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建圆球模型</span></span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.SphereGeometry(<span class="number">60</span>, <span class="number">40</span>, <span class="number">40</span>);</span><br><span class="line"><span class="comment">//基础网格材质对象   不受光照影响  没有棱角感</span></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x0000ff</span>,</span><br><span class="line">  wireframe:<span class="literal">true</span>,<span class="comment">//线条模式渲染</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span><br></pre></td></tr></table></figure>

<p><img src="./01.png" alt="基础网格材质"></p>
<h2 id="漫反射材质"><a href="#漫反射材质" class="headerlink" title="漫反射材质"></a>漫反射材质</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 立方体网格模型</span></span><br><span class="line"><span class="keyword">var</span> geometry1 = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">var</span> material1 = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x0000ff</span>,<span class="comment">//材质颜色</span></span><br><span class="line">  transparent:<span class="literal">true</span>,<span class="comment">//开启透明度</span></span><br><span class="line">  opacity:<span class="number">0.5</span>,<span class="comment">//设置透明度具体值</span></span><br><span class="line">&#125;); <span class="comment">//材质对象Material</span></span><br><span class="line"><span class="keyword">var</span> mesh1 = <span class="keyword">new</span> THREE.Mesh(geometry1, material1); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">scene.add(mesh1); <span class="comment">//网格模型添加到场景中</span></span><br></pre></td></tr></table></figure>

<h3 id="材质常见属性"><a href="#材质常见属性" class="headerlink" title="材质常见属性"></a>材质常见属性</h3><table>
<thead>
<tr>
<th>材质属性</th>
<th align="center">简介</th>
</tr>
</thead>
<tbody><tr>
<td>color</td>
<td align="center">材质颜色，比如蓝色0x0000ff</td>
</tr>
<tr>
<td>wireframe</td>
<td align="center">将几何图形渲染为线框。 默认值为false</td>
</tr>
<tr>
<td>opacity</td>
<td align="center">透明度设置，0表示完全透明，1表示完全不透明</td>
</tr>
<tr>
<td>transparent</td>
<td align="center">是否开启透明，默认false</td>
</tr>
</tbody></table>
<h2 id="高光效果"><a href="#高光效果" class="headerlink" title="高光效果"></a>高光效果</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 球体网格模型</span></span><br><span class="line"><span class="keyword">var</span> geometry2 = <span class="keyword">new</span> THREE.SphereGeometry(<span class="number">60</span>, <span class="number">40</span>, <span class="number">40</span>);</span><br><span class="line"><span class="keyword">var</span> material2 = <span class="keyword">new</span> THREE.MeshPhongMaterial(&#123;</span><br><span class="line">    color:<span class="number">0xff00f</span>,</span><br><span class="line">    specular:<span class="number">0x4488ee</span>,</span><br><span class="line">    shininess:<span class="number">12</span></span><br><span class="line">&#125;);<span class="comment">//材质对象</span></span><br><span class="line"><span class="keyword">var</span> mesh2 = <span class="keyword">new</span> THREE.Mesh(geometry2, material2); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">mesh2.translateY(<span class="number">120</span>); <span class="comment">//球体网格模型沿Y轴正方向平移100</span></span><br><span class="line">scene.add(mesh2);</span><br></pre></td></tr></table></figure>

<h2 id="金属材质"><a href="#金属材质" class="headerlink" title="金属材质"></a>金属材质</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 圆柱网格模型</span></span><br><span class="line"><span class="keyword">var</span> geometry3 = <span class="keyword">new</span> THREE.CylinderGeometry(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">25</span>);</span><br><span class="line"><span class="keyword">var</span> material3 = <span class="keyword">new</span> THREE.MeshStandardMaterial(&#123;</span><br><span class="line">  color: <span class="number">0xffff00</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> mesh3 = <span class="keyword">new</span> THREE.Mesh(geometry3, material3); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">mesh3.translateX(<span class="number">120</span>); <span class="comment">//球体网格模型沿Y轴正方向平移100</span></span><br><span class="line">scene.add(mesh3);</span><br></pre></td></tr></table></figure>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    body &#123;</span><br><span class="line">      margin: 0;</span><br><span class="line">      overflow: hidden;</span><br><span class="line"><span class="css">      <span class="comment">/* 隐藏body窗口区域滚动条 */</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--引入three.js三维引擎--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./three.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入threejs扩展控件OrbitControls.js --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./OrbitControls.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    /**</span><br><span class="line">     * 创建场景对象Scene</span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> scene = <span class="keyword">new</span> THREE.Scene();</span></span><br><span class="line">    /**</span><br><span class="line">     * 创建网格模型</span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    <span class="comment">// 立方体网格模型</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> geometry1 = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> material1 = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span></span><br><span class="line"><span class="actionscript">      color: <span class="number">0x0000ff</span>,<span class="comment">//材质颜色</span></span></span><br><span class="line"><span class="actionscript">      transparent:<span class="literal">true</span>,<span class="comment">//开启透明度</span></span></span><br><span class="line"><span class="actionscript">      opacity:<span class="number">0.5</span>,<span class="comment">//设置透明度具体值</span></span></span><br><span class="line"><span class="actionscript">    &#125;); <span class="comment">//材质对象Material</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> mesh1 = <span class="keyword">new</span> THREE.Mesh(geometry1, material1); <span class="comment">//网格模型对象Mesh</span></span></span><br><span class="line"><span class="actionscript">    scene.add(mesh1); <span class="comment">//网格模型添加到场景中</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 球体网格模型</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> geometry2 = <span class="keyword">new</span> THREE.SphereGeometry(<span class="number">60</span>, <span class="number">40</span>, <span class="number">40</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> material2 = <span class="keyword">new</span> THREE.MeshPhongMaterial(&#123;</span></span><br><span class="line">        color:0xff00f,</span><br><span class="line">        specular:0x4488ee,</span><br><span class="line">        shininess:12</span><br><span class="line"><span class="actionscript">    &#125;);<span class="comment">//材质对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> mesh2 = <span class="keyword">new</span> THREE.Mesh(geometry2, material2); <span class="comment">//网格模型对象Mesh</span></span></span><br><span class="line"><span class="actionscript">    mesh2.translateY(<span class="number">120</span>); <span class="comment">//球体网格模型沿Y轴正方向平移100</span></span></span><br><span class="line">    scene.add(mesh2);</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 圆柱网格模型</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> geometry3 = <span class="keyword">new</span> THREE.CylinderGeometry(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">25</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> material3 = <span class="keyword">new</span> THREE.MeshStandardMaterial(&#123;</span></span><br><span class="line">      color: 0xffff00</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> mesh3 = <span class="keyword">new</span> THREE.Mesh(geometry3, material3); <span class="comment">//网格模型对象Mesh</span></span></span><br><span class="line"><span class="actionscript">    mesh3.translateX(<span class="number">120</span>); <span class="comment">//球体网格模型沿Y轴正方向平移100</span></span></span><br><span class="line"><span class="actionscript">    scene.add(mesh3); <span class="comment">//</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 辅助坐标系</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> axisHelper = <span class="keyword">new</span> THREE.AxisHelper(<span class="number">250</span>);</span></span><br><span class="line">    scene.add(axisHelper);</span><br><span class="line">    /**</span><br><span class="line">     * 光源设置</span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    <span class="comment">//点光源</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> point = <span class="keyword">new</span> THREE.PointLight(<span class="number">0xffffff</span>);</span></span><br><span class="line"><span class="actionscript">    point.position.set(<span class="number">400</span>, <span class="number">200</span>, <span class="number">300</span>); <span class="comment">//点光源位置</span></span></span><br><span class="line"><span class="actionscript">    scene.add(point); <span class="comment">//点光源添加到场景中</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//环境光</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> ambient = <span class="keyword">new</span> THREE.AmbientLight(<span class="number">0x444444</span>);</span></span><br><span class="line">    scene.add(ambient);</span><br><span class="line">    /**</span><br><span class="line">     * 相机设置</span><br><span class="line">     */</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> width = <span class="built_in">window</span>.innerWidth; <span class="comment">//窗口宽度</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> height = <span class="built_in">window</span>.innerHeight; <span class="comment">//窗口高度</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> k = width / height; <span class="comment">//窗口宽高比</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> s = <span class="number">150</span>; <span class="comment">//三维场景显示范围控制系数，系数越大，显示的范围越大</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//创建相机对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> camera = <span class="keyword">new</span> THREE.OrthographicCamera(-s * k, s * k, s, -s, <span class="number">1</span>, <span class="number">1000</span>);</span></span><br><span class="line"><span class="actionscript">    camera.position.set(<span class="number">200</span>, <span class="number">300</span>, <span class="number">200</span>); <span class="comment">//设置相机位置</span></span></span><br><span class="line"><span class="actionscript">    camera.lookAt(scene.position); <span class="comment">//设置相机方向(指向的场景对象)</span></span></span><br><span class="line">    /**</span><br><span class="line">     * 创建渲染器对象</span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer();</span></span><br><span class="line"><span class="actionscript">    renderer.setSize(width, height); <span class="comment">//设置渲染区域尺寸</span></span></span><br><span class="line"><span class="actionscript">    renderer.setClearColor(<span class="number">0x666666</span>, <span class="number">1</span>); <span class="comment">//设置背景颜色</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.appendChild(renderer.domElement); <span class="comment">//body元素中插入canvas对象</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 渲染函数</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">render</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">      renderer.render(scene, camera); <span class="comment">//执行渲染操作</span></span></span><br><span class="line"><span class="actionscript">      requestAnimationFrame(render); <span class="comment">//请求再次执行渲染函数render，渲染下一帧</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    render();</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> controls = <span class="keyword">new</span> THREE.OrbitControls(camera,renderer.domElement); <span class="comment">//创建控件对象</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="./02.png" alt="材质"></p>
]]></content>
  </entry>
  <entry>
    <title>光照</title>
    <url>/2020/06/29/02web/ThreeJS/01%E5%85%A5%E9%97%A8/06%E5%85%89%E7%85%A7/</url>
    <content><![CDATA[<h1 id="光照"><a href="#光照" class="headerlink" title="光照"></a>光照</h1><h2 id="光照分类"><a href="#光照分类" class="headerlink" title="光照分类"></a>光照分类</h2><table>
<thead>
<tr>
<th>光源</th>
<th align="center">简介</th>
</tr>
</thead>
<tbody><tr>
<td>AmbientLight</td>
<td align="center">环境光</td>
</tr>
<tr>
<td>PointLight</td>
<td align="center">点光源</td>
</tr>
<tr>
<td>DirectionalLight</td>
<td align="center">平行光，比如太阳光</td>
</tr>
<tr>
<td>SpotLight</td>
<td align="center">聚光源</td>
</tr>
</tbody></table>
<h2 id="环境光创建"><a href="#环境光创建" class="headerlink" title="环境光创建"></a>环境光创建</h2><p>环境光是从四面八方而来，照射场景中所有事物，所以物体仅在环境光的条件下不会显示棱角</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//环境光    环境光颜色与网格模型的颜色进行RGB进行乘法运算</span></span><br><span class="line"><span class="keyword">var</span> ambient = <span class="keyword">new</span> THREE.AmbientLight(<span class="number">0x444444</span>);</span><br><span class="line">scene.add(ambient);</span><br></pre></td></tr></table></figure>

<h2 id="点光源创建"><a href="#点光源创建" class="headerlink" title="点光源创建"></a>点光源创建</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//点光源</span></span><br><span class="line"><span class="keyword">var</span> point = <span class="keyword">new</span> THREE.PointLight(<span class="number">0xffffff</span>);</span><br><span class="line">point.position.set(<span class="number">400</span>, <span class="number">200</span>, <span class="number">300</span>); <span class="comment">//点光源位置</span></span><br><span class="line"><span class="comment">// 通过add方法插入场景中，不插入的话，渲染的时候不会获取光源的信息进行光照计算</span></span><br><span class="line">scene.add(point); <span class="comment">//点光源添加到场景中</span></span><br></pre></td></tr></table></figure>

<h2 id="光源位置"><a href="#光源位置" class="headerlink" title="光源位置"></a>光源位置</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//点光源</span></span><br><span class="line"><span class="keyword">var</span> point = <span class="keyword">new</span> THREE.PointLight(<span class="number">0xffffff</span>);</span><br><span class="line">point.position.set(<span class="number">400</span>, <span class="number">200</span>, <span class="number">300</span>); <span class="comment">//点光源位置</span></span><br><span class="line">scene.add(point); <span class="comment">//点光源添加到场景中</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>顶点位置</title>
    <url>/2020/06/29/02web/ThreeJS/02%E9%A1%B6%E7%82%B9,%E5%87%A0%E4%BD%95%E4%BD%93%E7%BB%93%E6%9E%84/01%E9%A1%B6%E7%82%B9%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="两个重要函数"><a href="#两个重要函数" class="headerlink" title="两个重要函数"></a>两个重要函数</h1><h2 id="BufferGeometry"><a href="#BufferGeometry" class="headerlink" title="BufferGeometry"></a>BufferGeometry</h2><p>几何体对象的父类 </p>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><blockquote>
<p>BoxBufferGeometry(width : Float, height : Float, depth : Float, widthSegments : Integer, heightSegments : Integer, depthSegments : Integer)</p>
</blockquote>
<ul>
<li>width — X轴上面的宽度，默认值为1。</li>
<li>height — Y轴上面的高度，默认值为1。</li>
<li>depth — Z轴上面的深度，默认值为1。</li>
<li>widthSegments — （可选）宽度的分段数，默认值是1。</li>
<li>heightSegments — （可选）宽度的分段数，默认值是1。</li>
<li>depthSegments — （可选）宽度的分段数，默认值是1。</li>
</ul>
<h3 id="BufferGeometry和Geometry"><a href="#BufferGeometry和Geometry" class="headerlink" title="BufferGeometry和Geometry"></a>BufferGeometry和Geometry</h3><ul>
<li>BufferGeometry和Geometry可以实现同样的功能</li>
<li>BufferGeometry和Geometry两者的数据结构不同</li>
<li>缓冲类型几何体BufferGeometry相比普通几何体Geometry性能更好</li>
<li>Three.js的WebGL渲染器会把普通几何体对象Geometry转化为缓冲类型几何体对象BufferGeometry，然后再提取 BufferGeometry包含的顶点信息</li>
<li>使用BufferGeometry解析的时候相对Geometry少了一步，自然性能更高一些</li>
</ul>
<h2 id="BufferAttribute"><a href="#BufferAttribute" class="headerlink" title="BufferAttribute"></a>BufferAttribute</h2><ul>
<li>这个类用于存储与BufferGeometry相关联的 attribute（例如顶点位置向量，面片索引，法向量，颜色值，UV坐标以及任何自定义 attribute ）。</li>
<li>利用 BufferAttribute，可以更高效的向GPU传递数据</li>
</ul>
<h2 id="创建坐标点"><a href="#创建坐标点" class="headerlink" title="创建坐标点"></a>创建坐标点</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建网格模型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.BufferGeometry(); <span class="comment">//创建一个Buffer类型几何体对象</span></span><br><span class="line"><span class="comment">//类型数组创建顶点数据</span></span><br><span class="line"><span class="keyword">var</span> vertices = <span class="keyword">new</span> <span class="built_in">Float32Array</span>([</span><br><span class="line">  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点1坐标</span></span><br><span class="line">  <span class="number">50</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点2坐标</span></span><br><span class="line">  <span class="number">0</span>, <span class="number">100</span>, <span class="number">0</span>, <span class="comment">//顶点3坐标</span></span><br><span class="line">  <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="comment">//顶点4坐标</span></span><br><span class="line">  <span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="comment">//顶点5坐标</span></span><br><span class="line">  <span class="number">50</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="comment">//顶点6坐标</span></span><br><span class="line">]);</span><br><span class="line"><span class="comment">// 创建属性缓冲区对象</span></span><br><span class="line"><span class="keyword">var</span> attribue = <span class="keyword">new</span> THREE.BufferAttribute(vertices, <span class="number">3</span>); <span class="comment">//3个为一组，表示一个顶点的xyz坐标</span></span><br><span class="line"><span class="comment">// 设置几何体attributes属性的位置属性</span></span><br><span class="line">geometry.attributes.position = attribue;</span><br></pre></td></tr></table></figure>

<h1 id="渲染模式"><a href="#渲染模式" class="headerlink" title="渲染模式"></a>渲染模式</h1><h2 id="网格渲染模式"><a href="#网格渲染模式" class="headerlink" title="网格渲染模式"></a>网格渲染模式</h2><p>设置两面可见</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 三角面(网格)渲染模式</span></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x0000ff</span>, <span class="comment">//三角面颜色</span></span><br><span class="line">  side: THREE.DoubleSide, <span class="comment">//两面可见(FrontSide:正面可见,BackSide:背面可见)</span></span><br><span class="line">&#125;); <span class="comment">//材质对象</span></span><br><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span><br></pre></td></tr></table></figure>
<p><img src="./01.png" alt="网格渲染模式"></p>
<h2 id="点渲染模式"><a href="#点渲染模式" class="headerlink" title="点渲染模式"></a>点渲染模式</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.PointsMaterial(&#123;</span><br><span class="line">  color: <span class="number">0xff0000</span>,</span><br><span class="line">  size: <span class="number">5.0</span> <span class="comment">//点对象像素尺寸</span></span><br><span class="line">&#125;); <span class="comment">//材质对象</span></span><br><span class="line"><span class="keyword">var</span> points = <span class="keyword">new</span> THREE.Points(geometry, material); <span class="comment">//点模型对象</span></span><br><span class="line">scene.add(points); <span class="comment">//点对象添加到场景中</span></span><br></pre></td></tr></table></figure>

<p><img src="./02.png" alt="点渲染模式"></p>
<h2 id="线渲染模式"><a href="#线渲染模式" class="headerlink" title="线渲染模式"></a>线渲染模式</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> material=<span class="keyword">new</span> THREE.LineBasicMaterial(&#123;</span><br><span class="line">    color:<span class="number">0xff0000</span> <span class="comment">//线条颜色</span></span><br><span class="line">&#125;);<span class="comment">//材质对象</span></span><br><span class="line"><span class="keyword">var</span> line=<span class="keyword">new</span> THREE.Line(geometry,material);<span class="comment">//线条模型对象</span></span><br><span class="line">scene.add(line);<span class="comment">//线条对象添加到场景中</span></span><br></pre></td></tr></table></figure>

<p><img src="./03.png" alt="线渲染模式"></p>
<h1 id="几何体本质"><a href="#几何体本质" class="headerlink" title="几何体本质"></a>几何体本质</h1><ul>
<li>一个立方体网格模型，有6个面，每个面至少两个三角形拼成一个矩形平面，每个三角形三个顶点构成</li>
<li>对于球体网格模型而言，同样是通过三角形拼出来一个球面，三角形数量越多，网格模型表面越接近于球形</li>
</ul>
<p><img src="./04.jpg" alt="几何体本质"></p>
<h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    body &#123;</span><br><span class="line">      margin: 0;</span><br><span class="line">      overflow: hidden;</span><br><span class="line"><span class="css">      <span class="comment">/* 隐藏body窗口区域滚动条 */</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--引入three.js三维引擎--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./three.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入threejs扩展控件OrbitControls.js --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./OrbitControls.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    /**</span><br><span class="line">     * 创建场景对象Scene</span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> scene = <span class="keyword">new</span> THREE.Scene();</span></span><br><span class="line">    /**</span><br><span class="line">     * 创建网格模型</span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.BufferGeometry(); <span class="comment">//创建一个Buffer类型几何体对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//类型数组创建顶点数据</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vertices = <span class="keyword">new</span> <span class="built_in">Float32Array</span>([</span></span><br><span class="line"><span class="actionscript">      <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点1坐标</span></span></span><br><span class="line"><span class="actionscript">      <span class="number">50</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点2坐标</span></span></span><br><span class="line"><span class="actionscript">      <span class="number">0</span>, <span class="number">100</span>, <span class="number">0</span>, <span class="comment">//顶点3坐标</span></span></span><br><span class="line"><span class="actionscript">      <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="comment">//顶点4坐标</span></span></span><br><span class="line"><span class="actionscript">      <span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="comment">//顶点5坐标</span></span></span><br><span class="line"><span class="actionscript">      <span class="number">50</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="comment">//顶点6坐标</span></span></span><br><span class="line">    ]);</span><br><span class="line"><span class="actionscript">    <span class="comment">// 创建属性缓冲区对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> attribue = <span class="keyword">new</span> THREE.BufferAttribute(vertices, <span class="number">3</span>); <span class="comment">//3个为一组，表示一个顶点的xyz坐标</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 设置几何体attributes属性的位置属性</span></span></span><br><span class="line">    geometry.attributes.position = attribue;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 三角面(网格)渲染模式</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123;</span></span><br><span class="line"><span class="actionscript">      color: <span class="number">0x0000ff</span>, <span class="comment">//三角面颜色</span></span></span><br><span class="line"><span class="actionscript">      side: THREE.DoubleSide, <span class="comment">//两面可见(FrontSide:正面可见，BackSide:背面可见)</span></span></span><br><span class="line"><span class="actionscript">    &#125;); <span class="comment">//材质对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型对象Mesh</span></span></span><br><span class="line"><span class="actionscript">    scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 点渲染模式</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// var material = new THREE.PointsMaterial(&#123;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//   color: 0xff0000,</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//   size: 5.0 //点对象像素尺寸</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// &#125;); //材质对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// var points = new THREE.Points(geometry, material); //点模型对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// scene.add(points); //点对象添加到场景中</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 线条渲染模式</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// var material=new THREE.LineBasicMaterial(&#123;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//     color:0xff0000 //线条颜色</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// &#125;);//材质对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// var line=new THREE.Line(geometry,material);//线条模型对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// scene.add(line);//线条对象添加到场景中</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 辅助坐标系   老版本AxisHelper 新版本AxesHelper</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> axisHelper = <span class="keyword">new</span> THREE.AxisHelper(<span class="number">250</span>);</span></span><br><span class="line">    scene.add(axisHelper);</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 相机设置</span><br><span class="line">     */</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> width = <span class="built_in">window</span>.innerWidth; <span class="comment">//窗口宽度</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> height = <span class="built_in">window</span>.innerHeight; <span class="comment">//窗口高度</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> k = width / height; <span class="comment">//窗口宽高比</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> s = <span class="number">150</span>; <span class="comment">//三维场景显示范围控制系数，系数越大，显示的范围越大</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//创建相机对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> camera = <span class="keyword">new</span> THREE.OrthographicCamera(-s * k, s * k, s, -s, <span class="number">1</span>, <span class="number">1000</span>);</span></span><br><span class="line"><span class="actionscript">    camera.position.set(<span class="number">200</span>, <span class="number">300</span>, <span class="number">200</span>); <span class="comment">//设置相机位置</span></span></span><br><span class="line"><span class="actionscript">    camera.lookAt(scene.position); <span class="comment">//设置相机方向(指向的场景对象)</span></span></span><br><span class="line">    /**</span><br><span class="line">     * 创建渲染器对象</span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer();</span></span><br><span class="line"><span class="actionscript">    renderer.setSize(width, height); <span class="comment">//设置渲染区域尺寸</span></span></span><br><span class="line"><span class="actionscript">    renderer.setClearColor(<span class="number">0xb9d3ff</span>, <span class="number">1</span>); <span class="comment">//设置背景颜色</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.appendChild(renderer.domElement); <span class="comment">//body元素中插入canvas对象</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 渲染函数</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">render</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">      renderer.render(scene, camera); <span class="comment">//执行渲染操作</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    render();</span><br><span class="line"><span class="actionscript">    <span class="comment">//创建控件对象  相机对象camera作为参数   控件可以监听鼠标的变化，改变相机对象的属性</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> controls = <span class="keyword">new</span> THREE.OrbitControls(camera,renderer.domElement);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//监听鼠标事件，触发渲染函数，更新canvas画布渲染效果</span></span></span><br><span class="line"><span class="actionscript">    controls.addEventListener(<span class="string">'change'</span>, render);</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>顶点颜色</title>
    <url>/2020/06/29/02web/ThreeJS/02%E9%A1%B6%E7%82%B9,%E5%87%A0%E4%BD%95%E4%BD%93%E7%BB%93%E6%9E%84/02%E9%A1%B6%E7%82%B9%E9%A2%9C%E8%89%B2/</url>
    <content><![CDATA[<h1 id="设置点的颜色"><a href="#设置点的颜色" class="headerlink" title="设置点的颜色"></a>设置点的颜色</h1><ul>
<li>创建网格模型</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.BufferGeometry(); <span class="comment">//声明一个缓冲几何体对象</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过坐标设置位置</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类型数组创建顶点位置position数据</span></span><br><span class="line"><span class="keyword">var</span> vertices = <span class="keyword">new</span> <span class="built_in">Float32Array</span>([</span><br><span class="line">  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点1坐标</span></span><br><span class="line">  <span class="number">50</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点2坐标</span></span><br><span class="line">  <span class="number">0</span>, <span class="number">100</span>, <span class="number">0</span>, <span class="comment">//顶点3坐标</span></span><br><span class="line"></span><br><span class="line">  <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="comment">//顶点4坐标</span></span><br><span class="line">  <span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="comment">//顶点5坐标</span></span><br><span class="line">  <span class="number">50</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="comment">//顶点6坐标</span></span><br><span class="line">]);</span><br><span class="line"><span class="comment">// 创建属性缓冲区对象</span></span><br><span class="line"><span class="keyword">var</span> attribue = <span class="keyword">new</span> THREE.BufferAttribute(vertices, <span class="number">3</span>); <span class="comment">//3个为一组，作为一个顶点的xyz坐标</span></span><br><span class="line"><span class="comment">// 设置几何体attributes属性的位置position属性</span></span><br><span class="line">geometry.attributes.position = attribue;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过颜色数组设置颜色</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类型数组创建顶点颜色color数据</span></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Float32Array</span>([</span><br><span class="line">  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点1颜色</span></span><br><span class="line">  <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="comment">//顶点2颜色</span></span><br><span class="line">  <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="comment">//顶点3颜色</span></span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="comment">//顶点4颜色</span></span><br><span class="line">  <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="comment">//顶点5颜色</span></span><br><span class="line">  <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="comment">//顶点6颜色</span></span><br><span class="line">]);</span><br><span class="line"><span class="comment">// 设置几何体attributes属性的颜色color属性</span></span><br><span class="line">geometry.attributes.color = <span class="keyword">new</span> THREE.BufferAttribute(colors, <span class="number">3</span>); <span class="comment">//3个为一组,表示一个顶点的颜色数据RGB</span></span><br></pre></td></tr></table></figure>

<ul>
<li>设置材质颜色以顶点颜色为准</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//材质对象</span></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.PointsMaterial(&#123;</span><br><span class="line">  <span class="comment">// 使用顶点颜色数据渲染模型，不需要再定义color属性</span></span><br><span class="line">  <span class="comment">// color: 0xff0000,</span></span><br><span class="line">  vertexColors: THREE.VertexColors, <span class="comment">//以顶点颜色为准</span></span><br><span class="line">  size: <span class="number">10.0</span> <span class="comment">//点对象像素尺寸</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>点渲染模式</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 点渲染模式  点模型对象Points</span></span><br><span class="line"><span class="keyword">var</span> points = <span class="keyword">new</span> THREE.Points(geometry, material); <span class="comment">//点模型对象</span></span><br><span class="line">scene.add(points); <span class="comment">//点对象添加到场景中</span></span><br></pre></td></tr></table></figure>

<p><img src="./01.png" alt="点渲染模式"></p>
<ul>
<li>线条渲染模式</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线条渲染模式  线模型对象Line</span></span><br><span class="line"><span class="keyword">var</span> line = <span class="keyword">new</span> THREE.Line(geometry, material); <span class="comment">//点模型对象</span></span><br><span class="line">scene.add(line); <span class="comment">//点对象添加到场景中</span></span><br></pre></td></tr></table></figure>

<p><img src="./02.png" alt="线条渲染模式"></p>
<ul>
<li>面渲染</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 网格模型  三角面渲染模式</span></span><br><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型</span></span><br><span class="line">scene.add(mesh); <span class="comment">//点对象添加到场景中</span></span><br></pre></td></tr></table></figure>

<p><img src="./03.png" alt="面渲染"></p>
<h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    body &#123;</span><br><span class="line">      margin: 0;</span><br><span class="line">      overflow: hidden;</span><br><span class="line"><span class="css">      <span class="comment">/* 隐藏body窗口区域滚动条 */</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--引入three.js三维引擎--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./three.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入threejs扩展控件OrbitControls.js --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./OrbitControls.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    /**</span><br><span class="line">     * 创建场景对象Scene</span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> scene = <span class="keyword">new</span> THREE.Scene();</span></span><br><span class="line">    /**</span><br><span class="line">     * 创建网格模型</span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.BufferGeometry(); <span class="comment">//声明一个缓冲几何体对象</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">//类型数组创建顶点位置position数据</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vertices = <span class="keyword">new</span> <span class="built_in">Float32Array</span>([</span></span><br><span class="line"><span class="actionscript">      <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点1坐标</span></span></span><br><span class="line"><span class="actionscript">      <span class="number">50</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点2坐标</span></span></span><br><span class="line"><span class="actionscript">      <span class="number">0</span>, <span class="number">100</span>, <span class="number">0</span>, <span class="comment">//顶点3坐标</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">      <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="comment">//顶点4坐标</span></span></span><br><span class="line"><span class="actionscript">      <span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="comment">//顶点5坐标</span></span></span><br><span class="line"><span class="actionscript">      <span class="number">50</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="comment">//顶点6坐标</span></span></span><br><span class="line">    ]);</span><br><span class="line"><span class="actionscript">    <span class="comment">// 创建属性缓冲区对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> attribue = <span class="keyword">new</span> THREE.BufferAttribute(vertices, <span class="number">3</span>); <span class="comment">//3个为一组，作为一个顶点的xyz坐标</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 设置几何体attributes属性的位置position属性</span></span></span><br><span class="line">    geometry.attributes.position = attribue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">//类型数组创建顶点颜色color数据</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Float32Array</span>([</span></span><br><span class="line"><span class="actionscript">      <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点1颜色</span></span></span><br><span class="line"><span class="actionscript">      <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="comment">//顶点2颜色</span></span></span><br><span class="line"><span class="actionscript">      <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="comment">//顶点3颜色</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">      <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="comment">//顶点4颜色</span></span></span><br><span class="line"><span class="actionscript">      <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="comment">//顶点5颜色</span></span></span><br><span class="line"><span class="actionscript">      <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="comment">//顶点6颜色</span></span></span><br><span class="line">    ]);</span><br><span class="line"><span class="actionscript">    <span class="comment">// 设置几何体attributes属性的颜色color属性</span></span></span><br><span class="line"><span class="actionscript">    geometry.attributes.color = <span class="keyword">new</span> THREE.BufferAttribute(colors, <span class="number">3</span>); <span class="comment">//3个为一组,表示一个顶点的颜色数据RGB</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">//材质对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> material = <span class="keyword">new</span> THREE.PointsMaterial(&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="comment">// 使用顶点颜色数据渲染模型，不需要再定义color属性</span></span></span><br><span class="line"><span class="actionscript">      <span class="comment">// color: 0xff0000,</span></span></span><br><span class="line"><span class="actionscript">      vertexColors: THREE.VertexColors, <span class="comment">//以顶点颜色为准</span></span></span><br><span class="line"><span class="actionscript">      size: <span class="number">10.0</span> <span class="comment">//点对象像素尺寸</span></span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="actionscript">    <span class="comment">// 点渲染模式  点模型对象Points</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> points = <span class="keyword">new</span> THREE.Points(geometry, material); <span class="comment">//点模型对象</span></span></span><br><span class="line"><span class="actionscript">    scene.add(points); <span class="comment">//点对象添加到场景中</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 辅助坐标系</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> axisHelper = <span class="keyword">new</span> THREE.AxisHelper(<span class="number">250</span>);</span></span><br><span class="line">    scene.add(axisHelper);</span><br><span class="line">    /**</span><br><span class="line">     * 光源设置</span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    <span class="comment">//点光源</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> point = <span class="keyword">new</span> THREE.PointLight(<span class="number">0xffffff</span>);</span></span><br><span class="line"><span class="actionscript">    point.position.set(<span class="number">400</span>, <span class="number">200</span>, <span class="number">300</span>); <span class="comment">//点光源位置</span></span></span><br><span class="line"><span class="actionscript">    scene.add(point); <span class="comment">//点光源添加到场景中</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//环境光</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> ambient = <span class="keyword">new</span> THREE.AmbientLight(<span class="number">0x444444</span>);</span></span><br><span class="line">    scene.add(ambient);</span><br><span class="line">    /**</span><br><span class="line">     * 相机设置</span><br><span class="line">     */</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> width = <span class="built_in">window</span>.innerWidth; <span class="comment">//窗口宽度</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> height = <span class="built_in">window</span>.innerHeight; <span class="comment">//窗口高度</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> k = width / height; <span class="comment">//窗口宽高比</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> s = <span class="number">150</span>; <span class="comment">//三维场景显示范围控制系数，系数越大，显示的范围越大</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//创建相机对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> camera = <span class="keyword">new</span> THREE.OrthographicCamera(-s * k, s * k, s, -s, <span class="number">1</span>, <span class="number">1000</span>);</span></span><br><span class="line"><span class="actionscript">    camera.position.set(<span class="number">200</span>, <span class="number">300</span>, <span class="number">200</span>); <span class="comment">//设置相机位置</span></span></span><br><span class="line"><span class="actionscript">    camera.lookAt(scene.position); <span class="comment">//设置相机方向(指向的场景对象)</span></span></span><br><span class="line">    /**</span><br><span class="line">     * 创建渲染器对象</span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer();</span></span><br><span class="line"><span class="actionscript">    renderer.setSize(width, height); <span class="comment">//设置渲染区域尺寸</span></span></span><br><span class="line"><span class="actionscript">    renderer.setClearColor(<span class="number">0xb9d3ff</span>, <span class="number">1</span>); <span class="comment">//设置背景颜色</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.appendChild(renderer.domElement); <span class="comment">//body元素中插入canvas对象</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 渲染函数</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">render</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">      renderer.render(scene, camera); <span class="comment">//执行渲染操作</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    render();</span><br><span class="line"><span class="actionscript">    <span class="comment">//创建控件对象  相机对象camera作为参数   控件可以监听鼠标的变化，改变相机对象的属性</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> controls = <span class="keyword">new</span> THREE.OrbitControls(camera,renderer.domElement);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//监听鼠标事件，触发渲染函数，更新canvas画布渲染效果</span></span></span><br><span class="line"><span class="actionscript">    controls.addEventListener(<span class="string">'change'</span>, render);</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>状态模式</title>
    <url>/2020/08/12/01%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/02%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="./01.png" alt="举例"></p>
<h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><p>允许一个对象在其内部状态改变的时候改变它的行为，对象看起来似乎修改了它的类。<br>等红绿灯的时候，红绿灯的状态和行人汽车的通行逻辑是有关联的：</p>
<ol>
<li>红灯亮：行人通行，车辆等待；</li>
<li>绿灯亮：行人等待，车辆通行；</li>
<li>黄灯亮：行人等待，车辆等待；</li>
</ol>
<p><img src="./02.png" alt="举例"></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 状态(红灯，绿灯，黄灯)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(color)&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    handle(context) &#123;</span><br><span class="line">        context.setState(<span class="keyword">this</span>.color);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"切换成"</span> + <span class="keyword">this</span>.color + <span class="string">"灯"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 主体（相当于红绿灯设备）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    getState() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.state</span><br><span class="line">    &#125;</span><br><span class="line">    setState(state)&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">let</span> context = <span class="keyword">new</span> Context();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> green = <span class="keyword">new</span> State(<span class="string">"green"</span>);</span><br><span class="line"><span class="keyword">let</span> yellow = <span class="keyword">new</span> State(<span class="string">"yellow"</span>);</span><br><span class="line"><span class="keyword">let</span> red = <span class="keyword">new</span> State(<span class="string">"red"</span>);</span><br><span class="line"><span class="comment">// 绿灯亮了</span></span><br><span class="line">green.handle(context);</span><br><span class="line"><span class="built_in">console</span>.log(context.getState()); <span class="comment">// 打印状态</span></span><br><span class="line"><span class="comment">// 黄灯亮了</span></span><br><span class="line">yellow.handle(context);</span><br><span class="line"><span class="built_in">console</span>.log(context.getState()); <span class="comment">// 打印状态</span></span><br><span class="line"><span class="comment">// 红灯亮了</span></span><br><span class="line">red.handle(context);</span><br><span class="line"><span class="built_in">console</span>.log(context.getState()); <span class="comment">// 打印状态</span></span><br></pre></td></tr></table></figure>

<h2 id="有限状态机函数库Javascript-Finite-State-Machine"><a href="#有限状态机函数库Javascript-Finite-State-Machine" class="headerlink" title="有限状态机函数库Javascript Finite State Machine"></a>有限状态机函数库Javascript Finite State Machine</h2><p><a href="https://github.com/jakesgordon/javascript-state-machine" target="view_window">javascript-state-machine</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> StateMachine <span class="keyword">from</span> <span class="string">"javascript-state-machine"</span>;</span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">"jquery"</span>;</span><br><span class="line"><span class="comment">// 初始化状态机模型</span></span><br><span class="line"><span class="keyword">let</span> fsm = <span class="keyword">new</span> StateMachine(&#123;</span><br><span class="line">    init:<span class="string">"收藏"</span>, <span class="comment">// 初始化状态</span></span><br><span class="line">    transitions:[</span><br><span class="line">        &#123;</span><br><span class="line">            name:<span class="string">"doStore"</span>,</span><br><span class="line">            <span class="keyword">from</span>:<span class="string">"收藏"</span>,</span><br><span class="line">            to:<span class="string">"取消收藏"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            name:<span class="string">"deleteStore"</span>,</span><br><span class="line">            <span class="keyword">from</span>:<span class="string">"取消收藏"</span>,</span><br><span class="line">            to:<span class="string">"收藏"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    methods:&#123;</span><br><span class="line">        <span class="comment">// 监听执行收藏</span></span><br><span class="line">        onDoStore:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 和doStore名字对应</span></span><br><span class="line">            alert(<span class="string">"收藏成功"</span>)</span><br><span class="line">            updateText() <span class="comment">// 文案</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 监听取消收藏</span></span><br><span class="line">        onDeleteStore:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 和deleteStore名字对应</span></span><br><span class="line">            alert(<span class="string">"已经取消收藏"</span>)</span><br><span class="line">            updateText() <span class="comment">// 文案</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// let btn = document.getElementById("btn1");</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> $btn = $(<span class="string">"#btn1"</span>);</span><br><span class="line"><span class="comment">// 按钮点击事件</span></span><br><span class="line">$btn.click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fsm.is(<span class="string">"收藏"</span>))&#123;</span><br><span class="line">        fsm.doStore()</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        fsm.deleteStore()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新按钮文案</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateText</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $btn.text(fsm.state)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化文案</span></span><br><span class="line">updateText();</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>顶点颜色</title>
    <url>/2020/06/29/02web/ThreeJS/02%E9%A1%B6%E7%82%B9,%E5%87%A0%E4%BD%95%E4%BD%93%E7%BB%93%E6%9E%84/03%E9%A1%B6%E7%82%B9%E6%B3%95%E5%90%91%E9%87%8F/</url>
    <content><![CDATA[<h1 id="法向量的意义"><a href="#法向量的意义" class="headerlink" title="法向量的意义"></a>法向量的意义</h1><ul>
<li>太阳光照在一个物体表面，物体表面与光线夹角位置不同的区域明暗程度不同</li>
<li>WebGL中为了计算光线与物体表面入射角，首先要计算物体表面每个位置的法线方向</li>
<li>不设置法向量，物体颜色全部相同无法区分棱，与无点光源相同</li>
</ul>
<p><img src="./01.jpg" alt="法向量的意义"></p>
<h1 id="设置法向量"><a href="#设置法向量" class="headerlink" title="设置法向量"></a>设置法向量</h1><ul>
<li>设置几何体顶点</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.BufferGeometry(); <span class="comment">//声明一个空几何体对象</span></span><br><span class="line"><span class="comment">//类型数组创建顶点位置position数据</span></span><br><span class="line"><span class="keyword">var</span> vertices = <span class="keyword">new</span> <span class="built_in">Float32Array</span>([</span><br><span class="line">  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点1坐标</span></span><br><span class="line">  <span class="number">50</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点2坐标</span></span><br><span class="line">  <span class="number">0</span>, <span class="number">100</span>, <span class="number">0</span>, <span class="comment">//顶点3坐标</span></span><br><span class="line"></span><br><span class="line">  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点4坐标</span></span><br><span class="line">  <span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="comment">//顶点5坐标</span></span><br><span class="line">  <span class="number">50</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点6坐标</span></span><br><span class="line"></span><br><span class="line">]);</span><br><span class="line"><span class="comment">// 创建属性缓冲区对象</span></span><br><span class="line"><span class="keyword">var</span> attribue = <span class="keyword">new</span> THREE.BufferAttribute(vertices, <span class="number">3</span>); <span class="comment">//3个为一组</span></span><br></pre></td></tr></table></figure>

<ul>
<li>设置法向量</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建属性缓冲区对象</span></span><br><span class="line"><span class="keyword">var</span> attribue = <span class="keyword">new</span> THREE.BufferAttribute(vertices, <span class="number">3</span>); <span class="comment">//3个为一组</span></span><br><span class="line"><span class="comment">// 设置几何体attributes属性的位置position属性</span></span><br><span class="line">geometry.attributes.position = attribue</span><br><span class="line"><span class="keyword">var</span> normals = <span class="keyword">new</span> <span class="built_in">Float32Array</span>([</span><br><span class="line">  <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="comment">//顶点1法向量</span></span><br><span class="line">  <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="comment">//顶点2法向量</span></span><br><span class="line">  <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="comment">//顶点3法向量</span></span><br><span class="line"></span><br><span class="line">  <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="comment">//顶点4法向量</span></span><br><span class="line">  <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="comment">//顶点5法向量</span></span><br><span class="line">  <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="comment">//顶点6法向量</span></span><br><span class="line">]);</span><br><span class="line"><span class="comment">// 设置几何体attributes属性的位置normal属性</span></span><br><span class="line">geometry.attributes.normal = <span class="keyword">new</span> THREE.BufferAttribute(normals, <span class="number">3</span>); <span class="comment">//3个为一组,表示一个顶点的法向量数据</span></span><br></pre></td></tr></table></figure>

<ul>
<li>设置材质对象并用面渲染</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//材质对象</span></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x0000ff</span>, <span class="comment">//三角面颜色</span></span><br><span class="line">  side: THREE.DoubleSide <span class="comment">//两面可见</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span><br></pre></td></tr></table></figure>

<h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    body &#123;</span><br><span class="line">      margin: 0;</span><br><span class="line">      overflow: hidden;</span><br><span class="line"><span class="css">      <span class="comment">/* 隐藏body窗口区域滚动条 */</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--引入three.js三维引擎--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./three.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入threejs扩展控件OrbitControls.js --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./OrbitControls.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    /**</span><br><span class="line">     * 创建场景对象Scene</span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> scene = <span class="keyword">new</span> THREE.Scene();</span></span><br><span class="line">    /**</span><br><span class="line">     * 创建网格模型</span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.BufferGeometry(); <span class="comment">//声明一个空几何体对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//类型数组创建顶点位置position数据</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vertices = <span class="keyword">new</span> <span class="built_in">Float32Array</span>([</span></span><br><span class="line"><span class="actionscript">      <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点1坐标</span></span></span><br><span class="line"><span class="actionscript">      <span class="number">50</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点2坐标</span></span></span><br><span class="line"><span class="actionscript">      <span class="number">0</span>, <span class="number">100</span>, <span class="number">0</span>, <span class="comment">//顶点3坐标</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">      <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点4坐标</span></span></span><br><span class="line"><span class="actionscript">      <span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="comment">//顶点5坐标</span></span></span><br><span class="line"><span class="actionscript">      <span class="number">50</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点6坐标</span></span></span><br><span class="line"></span><br><span class="line">    ]);</span><br><span class="line"><span class="actionscript">    <span class="comment">// 创建属性缓冲区对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> attribue = <span class="keyword">new</span> THREE.BufferAttribute(vertices, <span class="number">3</span>); <span class="comment">//3个为一组</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 设置几何体attributes属性的位置position属性</span></span></span><br><span class="line">    geometry.attributes.position = attribue</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> normals = <span class="keyword">new</span> <span class="built_in">Float32Array</span>([</span></span><br><span class="line"><span class="actionscript">      <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="comment">//顶点1法向量</span></span></span><br><span class="line"><span class="actionscript">      <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="comment">//顶点2法向量</span></span></span><br><span class="line"><span class="actionscript">      <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="comment">//顶点3法向量</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">      <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="comment">//顶点4法向量</span></span></span><br><span class="line"><span class="actionscript">      <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="comment">//顶点5法向量</span></span></span><br><span class="line"><span class="actionscript">      <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="comment">//顶点6法向量</span></span></span><br><span class="line">    ]);</span><br><span class="line"><span class="actionscript">    <span class="comment">// 设置几何体attributes属性的位置normal属性</span></span></span><br><span class="line"><span class="actionscript">    geometry.attributes.normal = <span class="keyword">new</span> THREE.BufferAttribute(normals, <span class="number">3</span>); <span class="comment">//3个为一组,表示一个顶点的法向量数据</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">//材质对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span></span><br><span class="line"><span class="actionscript">      color: <span class="number">0x0000ff</span>, <span class="comment">//三角面颜色</span></span></span><br><span class="line"><span class="actionscript">      side: THREE.DoubleSide <span class="comment">//两面可见</span></span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型对象Mesh</span></span></span><br><span class="line"><span class="actionscript">    scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 辅助坐标系</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> axisHelper = <span class="keyword">new</span> THREE.AxisHelper(<span class="number">250</span>);</span></span><br><span class="line">    scene.add(axisHelper);</span><br><span class="line">    /**</span><br><span class="line">     * 光源设置</span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    <span class="comment">//点光源</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> point = <span class="keyword">new</span> THREE.PointLight(<span class="number">0xffffff</span>);</span></span><br><span class="line"><span class="actionscript">    point.position.set(<span class="number">400</span>, <span class="number">200</span>, <span class="number">300</span>); <span class="comment">//点光源位置</span></span></span><br><span class="line"><span class="actionscript">    scene.add(point); <span class="comment">//点光源添加到场景中</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//环境光</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> ambient = <span class="keyword">new</span> THREE.AmbientLight(<span class="number">0x444444</span>);</span></span><br><span class="line">    scene.add(ambient);</span><br><span class="line">    /**</span><br><span class="line">     * 相机设置</span><br><span class="line">     */</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> width = <span class="built_in">window</span>.innerWidth; <span class="comment">//窗口宽度</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> height = <span class="built_in">window</span>.innerHeight; <span class="comment">//窗口高度</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> k = width / height; <span class="comment">//窗口宽高比</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> s = <span class="number">150</span>; <span class="comment">//三维场景显示范围控制系数，系数越大，显示的范围越大</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//创建相机对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> camera = <span class="keyword">new</span> THREE.OrthographicCamera(-s * k, s * k, s, -s, <span class="number">1</span>, <span class="number">1000</span>);</span></span><br><span class="line"><span class="actionscript">    camera.position.set(<span class="number">200</span>, <span class="number">300</span>, <span class="number">200</span>); <span class="comment">//设置相机位置</span></span></span><br><span class="line"><span class="actionscript">    camera.lookAt(scene.position); <span class="comment">//设置相机方向(指向的场景对象)</span></span></span><br><span class="line">    /**</span><br><span class="line">     * 创建渲染器对象</span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer();</span></span><br><span class="line"><span class="actionscript">    renderer.setSize(width, height); <span class="comment">//设置渲染区域尺寸</span></span></span><br><span class="line"><span class="actionscript">    renderer.setClearColor(<span class="number">0xb9d3ff</span>, <span class="number">1</span>); <span class="comment">//设置背景颜色</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.appendChild(renderer.domElement); <span class="comment">//body元素中插入canvas对象</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 渲染函数</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">render</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">      renderer.render(scene, camera); <span class="comment">//执行渲染操作</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    render();</span><br><span class="line"><span class="actionscript">    <span class="comment">//创建控件对象  相机对象camera作为参数   控件可以监听鼠标的变化，改变相机对象的属性</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> controls = <span class="keyword">new</span> THREE.OrbitControls(camera,renderer.domElement);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//监听鼠标事件，触发渲染函数，更新canvas画布渲染效果</span></span></span><br><span class="line"><span class="actionscript">    controls.addEventListener(<span class="string">'change'</span>, render);</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="./02.png" alt="法向量"></p>
]]></content>
  </entry>
  <entry>
    <title>索引顶点复用</title>
    <url>/2020/06/30/02web/ThreeJS/02%E9%A1%B6%E7%82%B9,%E5%87%A0%E4%BD%95%E4%BD%93%E7%BB%93%E6%9E%84/04%E7%B4%A2%E5%BC%95%E5%A4%8D%E7%94%A8%E9%A1%B6%E7%82%B9%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="为什么要索引"><a href="#为什么要索引" class="headerlink" title="为什么要索引"></a>为什么要索引</h1><ul>
<li>一个矩形网格模型,至少需要两个三角形拼接而成</li>
<li>两个三角形，每个三角形有三个顶点，也就是说需要定义6个顶点位置数据</li>
<li>对于矩形网格模型而言，两个三角形有两个顶点位置是重合的</li>
<li>重复的位置可以定义一次，然后通过通过顶点数组的索引值获取这些顶点位置数据</li>
</ul>
<h1 id="索引使用"><a href="#索引使用" class="headerlink" title="索引使用"></a>索引使用</h1><ul>
<li>创建顶点数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建网格模型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.BufferGeometry(); <span class="comment">//声明一个空几何体对象</span></span><br><span class="line"><span class="comment">//类型数组创建顶点位置position数据</span></span><br><span class="line"><span class="keyword">var</span> vertices = <span class="keyword">new</span> <span class="built_in">Float32Array</span>([</span><br><span class="line">  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点1坐标</span></span><br><span class="line">  <span class="number">80</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点2坐标</span></span><br><span class="line">  <span class="number">80</span>, <span class="number">80</span>, <span class="number">0</span>, <span class="comment">//顶点3坐标</span></span><br><span class="line">  <span class="number">0</span>, <span class="number">80</span>, <span class="number">0</span>, <span class="comment">//顶点4坐标</span></span><br><span class="line">]);</span><br><span class="line"><span class="comment">// 创建属性缓冲区对象</span></span><br><span class="line"><span class="keyword">var</span> attribue = <span class="keyword">new</span> THREE.BufferAttribute(vertices, <span class="number">3</span>); <span class="comment">//3个为一组</span></span><br><span class="line"><span class="comment">// 设置几何体attributes属性的位置position属性</span></span><br><span class="line">geometry.attributes.position = attribue</span><br></pre></td></tr></table></figure>

<ul>
<li>创建法向量数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> normals = <span class="keyword">new</span> <span class="built_in">Float32Array</span>([</span><br><span class="line">  <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="comment">//顶点1法向量</span></span><br><span class="line">  <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="comment">//顶点2法向量</span></span><br><span class="line">  <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="comment">//顶点3法向量</span></span><br><span class="line">  <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="comment">//顶点4法向量</span></span><br><span class="line">]);</span><br><span class="line"><span class="comment">// 设置几何体attributes属性的位置normal属性</span></span><br><span class="line">geometry.attributes.normal = <span class="keyword">new</span> THREE.BufferAttribute(normals, <span class="number">3</span>); <span class="comment">//3个为一组,表示一个顶点的xyz坐标</span></span><br></pre></td></tr></table></figure>

<ul>
<li>创建索引数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Uint16Array类型数组创建顶点索引数据</span></span><br><span class="line"><span class="keyword">var</span> indexes = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>([</span><br><span class="line">  <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">])</span><br><span class="line"><span class="comment">// 索引数据赋值给几何体的index属性</span></span><br><span class="line">geometry.index = <span class="keyword">new</span> THREE.BufferAttribute(indexes, <span class="number">1</span>); <span class="comment">//1个为一组</span></span><br></pre></td></tr></table></figure>

<ul>
<li>创建材质对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//材质对象</span></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x0000ff</span>, <span class="comment">//三角面颜色</span></span><br><span class="line">  side: THREE.DoubleSide <span class="comment">//两面可见</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span><br></pre></td></tr></table></figure>

<h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    body &#123;</span><br><span class="line">      margin: 0;</span><br><span class="line">      overflow: hidden;</span><br><span class="line"><span class="css">      <span class="comment">/* 隐藏body窗口区域滚动条 */</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--引入three.js三维引擎--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./three.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入threejs扩展控件OrbitControls.js --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./OrbitControls.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    /**</span><br><span class="line">     * 创建场景对象Scene</span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> scene = <span class="keyword">new</span> THREE.Scene();</span></span><br><span class="line">    /**</span><br><span class="line">     * 创建网格模型</span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.BufferGeometry(); <span class="comment">//声明一个空几何体对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//类型数组创建顶点位置position数据</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vertices = <span class="keyword">new</span> <span class="built_in">Float32Array</span>([</span></span><br><span class="line"><span class="actionscript">      <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点1坐标</span></span></span><br><span class="line"><span class="actionscript">      <span class="number">80</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点2坐标</span></span></span><br><span class="line"><span class="actionscript">      <span class="number">80</span>, <span class="number">80</span>, <span class="number">0</span>, <span class="comment">//顶点3坐标</span></span></span><br><span class="line"><span class="actionscript">      <span class="number">0</span>, <span class="number">80</span>, <span class="number">0</span>, <span class="comment">//顶点4坐标</span></span></span><br><span class="line">    ]);</span><br><span class="line"><span class="actionscript">    <span class="comment">// 创建属性缓冲区对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> attribue = <span class="keyword">new</span> THREE.BufferAttribute(vertices, <span class="number">3</span>); <span class="comment">//3个为一组</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 设置几何体attributes属性的位置position属性</span></span></span><br><span class="line">    geometry.attributes.position = attribue</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> normals = <span class="keyword">new</span> <span class="built_in">Float32Array</span>([</span></span><br><span class="line"><span class="actionscript">      <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="comment">//顶点1法向量</span></span></span><br><span class="line"><span class="actionscript">      <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="comment">//顶点2法向量</span></span></span><br><span class="line"><span class="actionscript">      <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="comment">//顶点3法向量</span></span></span><br><span class="line"><span class="actionscript">      <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="comment">//顶点4法向量</span></span></span><br><span class="line">    ]);</span><br><span class="line"><span class="actionscript">    <span class="comment">// 设置几何体attributes属性的位置normal属性</span></span></span><br><span class="line"><span class="actionscript">    geometry.attributes.normal = <span class="keyword">new</span> THREE.BufferAttribute(normals, <span class="number">3</span>); <span class="comment">//3个为一组,表示一个顶点的xyz坐标</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// Uint16Array类型数组创建顶点索引数据</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> indexes = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>([</span></span><br><span class="line">      0, 1, 2, 0, 2, 3,</span><br><span class="line">    ])</span><br><span class="line"><span class="actionscript">    <span class="comment">// 索引数据赋值给几何体的index属性</span></span></span><br><span class="line"><span class="actionscript">    geometry.index = <span class="keyword">new</span> THREE.BufferAttribute(indexes, <span class="number">1</span>); <span class="comment">//1个为一组</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//材质对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span></span><br><span class="line"><span class="actionscript">      color: <span class="number">0x0000ff</span>, <span class="comment">//三角面颜色</span></span></span><br><span class="line"><span class="actionscript">      side: THREE.DoubleSide <span class="comment">//两面可见</span></span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型对象Mesh</span></span></span><br><span class="line"><span class="actionscript">    scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 辅助坐标系</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> axisHelper = <span class="keyword">new</span> THREE.AxisHelper(<span class="number">250</span>);</span></span><br><span class="line">    scene.add(axisHelper);</span><br><span class="line">    /**</span><br><span class="line">     * 光源设置</span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    <span class="comment">//点光源</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> point = <span class="keyword">new</span> THREE.PointLight(<span class="number">0xffffff</span>);</span></span><br><span class="line"><span class="actionscript">    point.position.set(<span class="number">400</span>, <span class="number">200</span>, <span class="number">300</span>); <span class="comment">//点光源位置</span></span></span><br><span class="line"><span class="actionscript">    scene.add(point); <span class="comment">//点光源添加到场景中</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//环境光</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> ambient = <span class="keyword">new</span> THREE.AmbientLight(<span class="number">0x444444</span>);</span></span><br><span class="line">    scene.add(ambient);</span><br><span class="line">    /**</span><br><span class="line">     * 相机设置</span><br><span class="line">     */</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> width = <span class="built_in">window</span>.innerWidth; <span class="comment">//窗口宽度</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> height = <span class="built_in">window</span>.innerHeight; <span class="comment">//窗口高度</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> k = width / height; <span class="comment">//窗口宽高比</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> s = <span class="number">150</span>; <span class="comment">//三维场景显示范围控制系数，系数越大，显示的范围越大</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//创建相机对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> camera = <span class="keyword">new</span> THREE.OrthographicCamera(-s * k, s * k, s, -s, <span class="number">1</span>, <span class="number">1000</span>);</span></span><br><span class="line"><span class="actionscript">    camera.position.set(<span class="number">200</span>, <span class="number">300</span>, <span class="number">200</span>); <span class="comment">//设置相机位置</span></span></span><br><span class="line"><span class="actionscript">    camera.lookAt(scene.position); <span class="comment">//设置相机方向(指向的场景对象)</span></span></span><br><span class="line">    /**</span><br><span class="line">     * 创建渲染器对象</span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer();</span></span><br><span class="line"><span class="actionscript">    renderer.setSize(width, height); <span class="comment">//设置渲染区域尺寸</span></span></span><br><span class="line"><span class="actionscript">    renderer.setClearColor(<span class="number">0xb9d3ff</span>, <span class="number">1</span>); <span class="comment">//设置背景颜色</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.appendChild(renderer.domElement); <span class="comment">//body元素中插入canvas对象</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 渲染函数</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">render</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">      renderer.render(scene, camera); <span class="comment">//执行渲染操作</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    render();</span><br><span class="line"><span class="actionscript">    <span class="comment">//创建控件对象  相机对象camera作为参数   控件可以监听鼠标的变化，改变相机对象的属性</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> controls = <span class="keyword">new</span> THREE.OrbitControls(camera,renderer.domElement);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//监听鼠标事件，触发渲染函数，更新canvas画布渲染效果</span></span></span><br><span class="line"><span class="actionscript">    controls.addEventListener(<span class="string">'change'</span>, render);</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="./01.png" alt="索引复用"></p>
]]></content>
  </entry>
  <entry>
    <title>索引顶点复用</title>
    <url>/2020/06/30/02web/ThreeJS/02%E9%A1%B6%E7%82%B9,%E5%87%A0%E4%BD%95%E4%BD%93%E7%BB%93%E6%9E%84/05Geometry%E9%A1%B6%E7%82%B9%E4%BD%8D%E7%BD%AE%E3%80%81%E9%A1%B6%E7%82%B9%E9%A2%9C%E8%89%B2/</url>
    <content><![CDATA[<h1 id="Geometry定义几何体"><a href="#Geometry定义几何体" class="headerlink" title="Geometry定义几何体"></a>Geometry定义几何体</h1><ul>
<li>之前用缓冲类型几何体BufferGeometry实现顶点位置、颜色、法向量、索引数据</li>
<li>之后用Geometry定义几何体</li>
</ul>
<h2 id="BufferGeometry和Geometry"><a href="#BufferGeometry和Geometry" class="headerlink" title="BufferGeometry和Geometry"></a>BufferGeometry和Geometry</h2><ul>
<li>BufferGeometry和Geometry可以实现同样的功能</li>
<li>BufferGeometry和Geometry两者的数据结构不同</li>
<li>缓冲类型几何体BufferGeometry相比普通几何体Geometry性能更好</li>
<li>Three.js的WebGL渲染器会把普通几何体对象Geometry转化为缓冲类型几何体对象BufferGeometry，然后再提取 BufferGeometry包含的顶点信息</li>
<li>使用BufferGeometry解析的时候相对Geometry少了一步，自然性能更高一些</li>
</ul>
<h2 id="Geometry定义步骤"><a href="#Geometry定义步骤" class="headerlink" title="Geometry定义步骤"></a>Geometry定义步骤</h2><ul>
<li>定义Geometry对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.Geometry(); <span class="comment">//声明一个几何体对象Geometry</span></span><br></pre></td></tr></table></figure>

<ul>
<li>定义顶点</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vector3向量对象表示顶点位置数据</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> THREE.Vector3(<span class="number">50</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//顶点1坐标</span></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> THREE.Vector3(<span class="number">0</span>, <span class="number">70</span>, <span class="number">0</span>); <span class="comment">//顶点2坐标</span></span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> THREE.Vector3(<span class="number">80</span>, <span class="number">70</span>, <span class="number">0</span>); <span class="comment">//顶点3坐标</span></span><br><span class="line"><span class="comment">//顶点坐标添加到geometry对象</span></span><br><span class="line">geometry.vertices.push(p1, p2, p3);</span><br></pre></td></tr></table></figure>

<ul>
<li>定义颜色</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Color对象表示顶点颜色数据</span></span><br><span class="line"><span class="keyword">var</span> color1 = <span class="keyword">new</span> THREE.Color(<span class="number">0x00ff00</span>); <span class="comment">//顶点1颜色——绿色</span></span><br><span class="line"><span class="keyword">var</span> color2 = <span class="keyword">new</span> THREE.Color(<span class="number">0xff0000</span>); <span class="comment">//顶点2颜色——红色</span></span><br><span class="line"><span class="keyword">var</span> color3 = <span class="keyword">new</span> THREE.Color(<span class="number">0x0000ff</span>); <span class="comment">//顶点3颜色——蓝色</span></span><br><span class="line"><span class="comment">//顶点颜色数据添加到geometry对象</span></span><br><span class="line">geometry.colors.push(color1, color2, color3);</span><br></pre></td></tr></table></figure>

<ul>
<li>材质对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//材质对象</span></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.LineBasicMaterial(&#123;</span><br><span class="line">  <span class="comment">// 使用顶点颜色数据渲染模型，不需要再定义color属性</span></span><br><span class="line">  <span class="comment">// color: 0xff0000,</span></span><br><span class="line">  vertexColors: THREE.VertexColors, <span class="comment">//以顶点颜色为准</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//线条模型对象</span></span><br><span class="line"><span class="keyword">var</span> line = <span class="keyword">new</span> THREE.Line(geometry, material);</span><br><span class="line">scene.add(line); <span class="comment">//线条对象添加到场景中</span></span><br></pre></td></tr></table></figure>

<h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    body &#123;</span><br><span class="line">      margin: 0;</span><br><span class="line">      overflow: hidden;</span><br><span class="line"><span class="css">      <span class="comment">/* 隐藏body窗口区域滚动条 */</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--引入three.js三维引擎--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./three.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入threejs扩展控件OrbitControls.js --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./OrbitControls.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    /**</span><br><span class="line">     * 创建场景对象Scene</span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> scene = <span class="keyword">new</span> THREE.Scene();</span></span><br><span class="line">    /**</span><br><span class="line">     * 创建网格模型</span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.Geometry(); <span class="comment">//声明一个几何体对象Geometry</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// Vector3向量对象表示顶点位置数据</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> THREE.Vector3(<span class="number">50</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//顶点1坐标</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> p2 = <span class="keyword">new</span> THREE.Vector3(<span class="number">0</span>, <span class="number">70</span>, <span class="number">0</span>); <span class="comment">//顶点2坐标</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> p3 = <span class="keyword">new</span> THREE.Vector3(<span class="number">80</span>, <span class="number">70</span>, <span class="number">0</span>); <span class="comment">//顶点3坐标</span></span></span><br><span class="line">    </span><br><span class="line"><span class="actionscript">    <span class="comment">//顶点坐标添加到geometry对象</span></span></span><br><span class="line">    geometry.vertices.push(p1, p2, p3);</span><br><span class="line"><span class="actionscript">    <span class="comment">// Color对象表示顶点颜色数据</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> color1 = <span class="keyword">new</span> THREE.Color(<span class="number">0x00ff00</span>); <span class="comment">//顶点1颜色——绿色</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> color2 = <span class="keyword">new</span> THREE.Color(<span class="number">0xff0000</span>); <span class="comment">//顶点2颜色——红色</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> color3 = <span class="keyword">new</span> THREE.Color(<span class="number">0x0000ff</span>); <span class="comment">//顶点3颜色——蓝色</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//顶点颜色数据添加到geometry对象</span></span></span><br><span class="line">    geometry.colors.push(color1, color2, color3);</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">//材质对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> material = <span class="keyword">new</span> THREE.LineBasicMaterial(&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="comment">// 使用顶点颜色数据渲染模型，不需要再定义color属性</span></span></span><br><span class="line"><span class="actionscript">      <span class="comment">// color: 0xff0000,</span></span></span><br><span class="line"><span class="actionscript">      vertexColors: THREE.VertexColors, <span class="comment">//以顶点颜色为准</span></span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="actionscript">    <span class="comment">//线条模型对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> line = <span class="keyword">new</span> THREE.Line(geometry, material);</span></span><br><span class="line"><span class="actionscript">    scene.add(line); <span class="comment">//线条对象添加到场景中</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 点渲染模式</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// var material = new THREE.PointsMaterial(&#123;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//   // 使用顶点颜色数据渲染模型，不需要再定义color属性</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//   // color: 0xff0000,</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//   vertexColors: THREE.VertexColors, //以顶点颜色为准</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//   size: 10.0 //点对象像素尺寸</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// &#125;); //材质对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// var points = new THREE.Points(geometry, material); //点模型对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// scene.add(points); //点对象添加到场景中</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 辅助坐标系</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> AxesHelper = <span class="keyword">new</span> THREE.AxesHelper(<span class="number">250</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// scene.add(AxesHelper);</span></span></span><br><span class="line">    /**</span><br><span class="line">     * 光源设置</span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    <span class="comment">//点光源</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> point = <span class="keyword">new</span> THREE.PointLight(<span class="number">0xffffff</span>);</span></span><br><span class="line"><span class="actionscript">    point.position.set(<span class="number">400</span>, <span class="number">200</span>, <span class="number">300</span>); <span class="comment">//点光源位置</span></span></span><br><span class="line"><span class="actionscript">    scene.add(point); <span class="comment">//点光源添加到场景中</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//环境光</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> ambient = <span class="keyword">new</span> THREE.AmbientLight(<span class="number">0x444444</span>);</span></span><br><span class="line">    scene.add(ambient);</span><br><span class="line">    /**</span><br><span class="line">     * 相机设置</span><br><span class="line">     */</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> width = <span class="built_in">window</span>.innerWidth; <span class="comment">//窗口宽度</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> height = <span class="built_in">window</span>.innerHeight; <span class="comment">//窗口高度</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> k = width / height; <span class="comment">//窗口宽高比</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> s = <span class="number">150</span>; <span class="comment">//三维场景显示范围控制系数，系数越大，显示的范围越大</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//创建相机对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> camera = <span class="keyword">new</span> THREE.OrthographicCamera(-s * k, s * k, s, -s, <span class="number">1</span>, <span class="number">1000</span>);</span></span><br><span class="line"><span class="actionscript">    camera.position.set(<span class="number">200</span>, <span class="number">300</span>, <span class="number">200</span>); <span class="comment">//设置相机位置</span></span></span><br><span class="line"><span class="actionscript">    camera.lookAt(scene.position); <span class="comment">//设置相机方向(指向的场景对象)</span></span></span><br><span class="line">    /**</span><br><span class="line">     * 创建渲染器对象</span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer();</span></span><br><span class="line"><span class="actionscript">    renderer.setSize(width, height); <span class="comment">//设置渲染区域尺寸</span></span></span><br><span class="line"><span class="actionscript">    renderer.setClearColor(<span class="number">0xb9d3ff</span>, <span class="number">1</span>); <span class="comment">//设置背景颜色</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.appendChild(renderer.domElement); <span class="comment">//body元素中插入canvas对象</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 渲染函数</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">render</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">      renderer.render(scene, camera); <span class="comment">//执行渲染操作</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    render();</span><br><span class="line"><span class="actionscript">    <span class="comment">//创建控件对象  相机对象camera作为参数   控件可以监听鼠标的变化，改变相机对象的属性</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> controls = <span class="keyword">new</span> THREE.OrbitControls(camera,renderer.domElement);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//监听鼠标事件，触发渲染函数，更新canvas画布渲染效果</span></span></span><br><span class="line"><span class="actionscript">    controls.addEventListener(<span class="string">'change'</span>, render);</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="./01.png" alt="Geometry"></p>
]]></content>
  </entry>
  <entry>
    <title>Face3对象定义Geometry</title>
    <url>/2020/06/30/02web/ThreeJS/02%E9%A1%B6%E7%82%B9,%E5%87%A0%E4%BD%95%E4%BD%93%E7%BB%93%E6%9E%84/06Face3%E5%AF%B9%E8%B1%A1%E5%AE%9A%E4%B9%89Geometry/</url>
    <content><![CDATA[<h1 id="构建Face面"><a href="#构建Face面" class="headerlink" title="构建Face面"></a>构建Face面</h1><ul>
<li>模型顶点</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建网格模型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.Geometry(); <span class="comment">//声明一个几何体对象Geometry</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> THREE.Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//顶点1坐标</span></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> THREE.Vector3(<span class="number">0</span>, <span class="number">100</span>, <span class="number">0</span>); <span class="comment">//顶点2坐标</span></span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> THREE.Vector3(<span class="number">50</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//顶点3坐标</span></span><br><span class="line"><span class="keyword">var</span> p4 = <span class="keyword">new</span> THREE.Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>); <span class="comment">//顶点4坐标</span></span><br><span class="line"><span class="comment">//顶点坐标添加到geometry对象</span></span><br><span class="line">geometry.vertices.push(p1, p2, p3, p4);</span><br></pre></td></tr></table></figure>

<ul>
<li>颜色</li>
</ul>
<blockquote>
<p>顶点颜色并不能决定面的颜色</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Color对象表示顶点颜色数据</span></span><br><span class="line"><span class="keyword">var</span> color1 = <span class="keyword">new</span> THREE.Color(<span class="number">0x00ff00</span>); <span class="comment">//顶点1颜色——绿色</span></span><br><span class="line"><span class="keyword">var</span> color2 = <span class="keyword">new</span> THREE.Color(<span class="number">0xff0000</span>); <span class="comment">//顶点2颜色——红色</span></span><br><span class="line"><span class="keyword">var</span> color3 = <span class="keyword">new</span> THREE.Color(<span class="number">0x0000ff</span>); <span class="comment">//顶点3颜色——蓝色</span></span><br><span class="line"><span class="keyword">var</span> color4 = <span class="keyword">new</span> THREE.Color(<span class="number">0xffff00</span>); <span class="comment">//顶点3颜色——黄色</span></span><br><span class="line"><span class="comment">//顶点颜色数据添加到geometry对象</span></span><br><span class="line">geometry.colors.push(color1, color2, color3, color4);</span><br></pre></td></tr></table></figure>

<ul>
<li>Face3构造函数创建一个三角面</li>
</ul>
<blockquote>
<p>vertexColors才能决定面的颜色</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Face3构造函数创建一个三角面</span></span><br><span class="line"><span class="keyword">var</span> face1 = <span class="keyword">new</span> THREE.Face3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">//设置三角面face1每个顶点的法向量</span></span><br><span class="line"><span class="keyword">var</span> n1 = <span class="keyword">new</span> THREE.Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">var</span> n2 = <span class="keyword">new</span> THREE.Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">var</span> n3 = <span class="keyword">new</span> THREE.Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="comment">// 设置三角面Face3三个顶点的法向量</span></span><br><span class="line">face1.vertexNormals.push(n1, n2, n3);</span><br><span class="line"><span class="comment">// 设置三角面face1三个顶点的颜色</span></span><br><span class="line">face1.vertexColors = [</span><br><span class="line">  <span class="keyword">new</span> THREE.Color(<span class="number">0xffff00</span>),</span><br><span class="line">  <span class="keyword">new</span> THREE.Color(<span class="number">0xff00ff</span>),</span><br><span class="line">  <span class="keyword">new</span> THREE.Color(<span class="number">0x00ffff</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>Face3构造函数创建第二个三角面</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 三角面2</span></span><br><span class="line"><span class="keyword">var</span> face2 = <span class="keyword">new</span> THREE.Face3(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 设置三角面法向量</span></span><br><span class="line">face2.normal = <span class="keyword">new</span> THREE.Vector3(<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// face2.color = new THREE.Color(0x00ff00);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//三角面face1、face2添加到几何体中</span></span><br><span class="line">geometry.faces.push(face1, face2);</span><br></pre></td></tr></table></figure>

<h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    body &#123;</span><br><span class="line">      margin: 0;</span><br><span class="line">      overflow: hidden;</span><br><span class="line"><span class="css">      <span class="comment">/* 隐藏body窗口区域滚动条 */</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--引入three.js三维引擎--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./three.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入threejs扩展控件OrbitControls.js --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./OrbitControls.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    /**</span><br><span class="line">     * 创建场景对象Scene</span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> scene = <span class="keyword">new</span> THREE.Scene();</span></span><br><span class="line">    /**</span><br><span class="line">     * 创建网格模型</span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.Geometry(); <span class="comment">//声明一个几何体对象Geometry</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> THREE.Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//顶点1坐标</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> p2 = <span class="keyword">new</span> THREE.Vector3(<span class="number">0</span>, <span class="number">100</span>, <span class="number">0</span>); <span class="comment">//顶点2坐标</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> p3 = <span class="keyword">new</span> THREE.Vector3(<span class="number">50</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//顶点3坐标</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> p4 = <span class="keyword">new</span> THREE.Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>); <span class="comment">//顶点4坐标</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//顶点坐标添加到geometry对象</span></span></span><br><span class="line">    geometry.vertices.push(p1, p2, p3, p4);</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// Color对象表示顶点颜色数据</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> color1 = <span class="keyword">new</span> THREE.Color(<span class="number">0x00ff00</span>); <span class="comment">//顶点1颜色——绿色</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> color2 = <span class="keyword">new</span> THREE.Color(<span class="number">0xff0000</span>); <span class="comment">//顶点2颜色——红色</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> color3 = <span class="keyword">new</span> THREE.Color(<span class="number">0x0000ff</span>); <span class="comment">//顶点3颜色——蓝色</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> color4 = <span class="keyword">new</span> THREE.Color(<span class="number">0xffff00</span>); <span class="comment">//顶点3颜色——黄色</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//顶点颜色数据添加到geometry对象</span></span></span><br><span class="line">    geometry.colors.push(color1, color2, color3, color4);</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// Face3构造函数创建一个三角面</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> face1 = <span class="keyword">new</span> THREE.Face3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//设置三角面face1每个顶点的法向量</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> n1 = <span class="keyword">new</span> THREE.Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> n2 = <span class="keyword">new</span> THREE.Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> n3 = <span class="keyword">new</span> THREE.Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 设置三角面Face3三个顶点的法向量</span></span></span><br><span class="line">    face1.vertexNormals.push(n1, n2, n3);</span><br><span class="line"><span class="actionscript">    <span class="comment">// 设置三角面face1三个顶点的颜色</span></span></span><br><span class="line">    face1.vertexColors = [</span><br><span class="line"><span class="actionscript">      <span class="keyword">new</span> THREE.Color(<span class="number">0xffff00</span>),</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">new</span> THREE.Color(<span class="number">0xff00ff</span>),</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">new</span> THREE.Color(<span class="number">0x00ffff</span>),</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 三角面2</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> face2 = <span class="keyword">new</span> THREE.Face3(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 设置三角面法向量</span></span></span><br><span class="line"><span class="actionscript">    face2.normal = <span class="keyword">new</span> THREE.Vector3(<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// face2.color = new THREE.Color(0x00ff00);</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">//三角面face1、face2添加到几何体中</span></span></span><br><span class="line">    geometry.faces.push(face1, face2);</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">//材质对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="comment">// color: 0xffff00,</span></span></span><br><span class="line"><span class="actionscript">      vertexColors: THREE.VertexColors, <span class="comment">//以顶点颜色为准</span></span></span><br><span class="line"><span class="actionscript">      <span class="comment">// vertexColors: THREE.FaceColors,</span></span></span><br><span class="line"><span class="actionscript">      side: THREE.DoubleSide, <span class="comment">//两面可见</span></span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="actionscript">    <span class="comment">//网格模型对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material);</span></span><br><span class="line"><span class="actionscript">    scene.add(mesh); <span class="comment">//网格模型对象添加到场景中</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 点渲染模式</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// var material = new THREE.PointsMaterial(&#123;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//   // color: 0xff0000,</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//   vertexColors: THREE.VertexColors, //以顶点颜色为准</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//   size: 10.0 //点对象像素尺寸</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// &#125;); //材质对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// var points = new THREE.Points(geometry, material); //点模型对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// scene.add(points); //点对象添加到场景中</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 线条渲染模式</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// var material=new THREE.LineBasicMaterial(&#123;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//     // color:0xff0000, //线条颜色</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//     vertexColors: THREE.VertexColors, //以顶点颜色为准</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// &#125;);//材质对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// var line=new THREE.Line(geometry,material);//线条模型对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// scene.add(line);//线条对象添加到场景中</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 辅助坐标系</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> AxesHelper = <span class="keyword">new</span> THREE.AxesHelper(<span class="number">250</span>);</span></span><br><span class="line">    scene.add(AxesHelper);</span><br><span class="line">    /**</span><br><span class="line">     * 光源设置</span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    <span class="comment">//点光源</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> point = <span class="keyword">new</span> THREE.PointLight(<span class="number">0xffffff</span>);</span></span><br><span class="line"><span class="actionscript">    point.position.set(<span class="number">400</span>, <span class="number">200</span>, <span class="number">300</span>); <span class="comment">//点光源位置</span></span></span><br><span class="line"><span class="actionscript">    scene.add(point); <span class="comment">//点光源添加到场景中</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//环境光</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> ambient = <span class="keyword">new</span> THREE.AmbientLight(<span class="number">0x444444</span>);</span></span><br><span class="line">    scene.add(ambient);</span><br><span class="line">    /**</span><br><span class="line">     * 相机设置</span><br><span class="line">     */</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> width = <span class="built_in">window</span>.innerWidth; <span class="comment">//窗口宽度</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> height = <span class="built_in">window</span>.innerHeight; <span class="comment">//窗口高度</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> k = width / height; <span class="comment">//窗口宽高比</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> s = <span class="number">150</span>; <span class="comment">//三维场景显示范围控制系数，系数越大，显示的范围越大</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//创建相机对象</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> camera = <span class="keyword">new</span> THREE.OrthographicCamera(-s * k, s * k, s, -s, <span class="number">1</span>, <span class="number">1000</span>);</span></span><br><span class="line"><span class="actionscript">    camera.position.set(<span class="number">200</span>, <span class="number">300</span>, <span class="number">200</span>); <span class="comment">//设置相机位置</span></span></span><br><span class="line"><span class="actionscript">    camera.lookAt(scene.position); <span class="comment">//设置相机方向(指向的场景对象)</span></span></span><br><span class="line">    /**</span><br><span class="line">     * 创建渲染器对象</span><br><span class="line">     */</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer();</span></span><br><span class="line"><span class="actionscript">    renderer.setSize(width, height); <span class="comment">//设置渲染区域尺寸</span></span></span><br><span class="line"><span class="actionscript">    renderer.setClearColor(<span class="number">0xb9d3ff</span>, <span class="number">1</span>); <span class="comment">//设置背景颜色</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.appendChild(renderer.domElement); <span class="comment">//body元素中插入canvas对象</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 渲染函数</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">render</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">      renderer.render(scene, camera); <span class="comment">//执行渲染操作</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    render();</span><br><span class="line"><span class="actionscript">    <span class="comment">//创建控件对象  相机对象camera作为参数   控件可以监听鼠标的变化，改变相机对象的属性</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> controls = <span class="keyword">new</span> THREE.OrbitControls(camera,renderer.domElement);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//监听鼠标事件，触发渲染函数，更新canvas画布渲染效果</span></span></span><br><span class="line"><span class="actionscript">    controls.addEventListener(<span class="string">'change'</span>, render);</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="./01.png" alt="face"></p>
]]></content>
  </entry>
  <entry>
    <title>几何体旋转,缩放,平移变换</title>
    <url>/2020/06/30/02web/ThreeJS/02%E9%A1%B6%E7%82%B9,%E5%87%A0%E4%BD%95%E4%BD%93%E7%BB%93%E6%9E%84/08%E5%87%A0%E4%BD%95%E4%BD%93%E6%97%8B%E8%BD%AC,%E7%BC%A9%E6%94%BE,%E5%B9%B3%E7%A7%BB%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="几何体变换"><a href="#几何体变换" class="headerlink" title="几何体变换"></a>几何体变换</h1><ul>
<li>几何体Geometry对象有一系列的顶点属性</li>
<li>通过.scale()、.translate()、.rotateX()等方法可以对几何体本身进行缩放、平移、旋转等几何变换</li>
<li>本质上都是改变结合体顶点位置坐标数据</li>
<li>BufferGeometry和几何体Geometry 一样具有scale()、.rotateZ()、.rotateX()等几何体变换的方法</li>
</ul>
<p><img src="./01.png" alt="几何体对象的数据"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>); <span class="comment">//创建一个立方体几何对象Geometry</span></span><br><span class="line"><span class="comment">// 几何体xyz三个方向都放大2倍</span></span><br><span class="line">geometry.scale(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 几何体沿着x轴平移50</span></span><br><span class="line">geometry.translate(<span class="number">50</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 几何体绕着x轴旋转45度</span></span><br><span class="line">geometry.rotateX(<span class="built_in">Math</span>.PI / <span class="number">4</span>);</span><br><span class="line"><span class="comment">// 居中：偏移的几何体居中</span></span><br><span class="line">geometry.center();</span><br><span class="line"><span class="built_in">console</span>.log(geometry.vertices);</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>几何体对象的数据</title>
    <url>/2020/06/30/02web/ThreeJS/02%E9%A1%B6%E7%82%B9,%E5%87%A0%E4%BD%95%E4%BD%93%E7%BB%93%E6%9E%84/07%E5%87%A0%E4%BD%95%E4%BD%93%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="Geometry"><a href="#Geometry" class="headerlink" title="Geometry"></a>Geometry</h1><ul>
<li>执行THREE.BoxGeometry构造函数会自动生成几何体对象的顶点位置坐标、顶点法向量等数据</li>
<li>BoxGeometry、PlaneGeometry、SphereGeometry等几何体类的基类是Geometry</li>
<li>可以通过执行下面代码，然后查看浏览器控制台打印的数据</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>); <span class="comment">//创建一个立方体几何对象Geometry</span></span><br><span class="line"><span class="built_in">console</span>.log(geometry);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'几何体顶点位置数据'</span>,geometry.vertices);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'三角行面数据'</span>,geometry.faces);</span><br></pre></td></tr></table></figure>

<p><img src="./01.png" alt="几何体对象的数据"></p>
<h1 id="BufferGeometry"><a href="#BufferGeometry" class="headerlink" title="BufferGeometry"></a>BufferGeometry</h1><ul>
<li>BoxBufferGeometry、PlaneBufferGeometry、SphereBufferGeometry等几何体类的基类是BufferGeometry</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个矩形平面几何体</span></span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.PlaneBufferGeometry(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">console</span>.log(geometry);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'几何体顶点位置数据'</span>,geometry.attributes.position);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'几何体索引数据'</span>,geometry.index);</span><br></pre></td></tr></table></figure>

<p><img src="./02.png" alt="BufferGeometry"></p>
<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><h2 id="彩色正方形"><a href="#彩色正方形" class="headerlink" title="彩色正方形"></a>彩色正方形</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>); <span class="comment">//创建一个立方体几何对象Geometry</span></span><br><span class="line"><span class="comment">// 遍历几何体的face属性</span></span><br><span class="line">geometry.faces.forEach(<span class="function"><span class="params">face</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 设置三角面face三个顶点的颜色</span></span><br><span class="line">  face.vertexColors = [</span><br><span class="line">    <span class="keyword">new</span> THREE.Color(<span class="number">0xffff00</span>),</span><br><span class="line">    <span class="keyword">new</span> THREE.Color(<span class="number">0xff00ff</span>),</span><br><span class="line">    <span class="keyword">new</span> THREE.Color(<span class="number">0x00ffff</span>),</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123;</span><br><span class="line">  <span class="comment">// color: 0x0000ff,</span></span><br><span class="line">  vertexColors: THREE.FaceColors,</span><br><span class="line">  <span class="comment">// wireframe:true,//线框模式渲染</span></span><br><span class="line">&#125;); <span class="comment">//材质对象Material</span></span><br></pre></td></tr></table></figure>

<p><img src="./03.png" alt="彩色正方形"></p>
<h2 id="删除立方体部分三角形面"><a href="#删除立方体部分三角形面" class="headerlink" title="删除立方体部分三角形面"></a>删除立方体部分三角形面</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>); <span class="comment">//创建一个立方体几何对象Geometry</span></span><br><span class="line"><span class="comment">// pop()：删除数组的最后一个元素   shift：删除数组的第一个元素</span></span><br><span class="line">geometry.faces.pop();</span><br><span class="line">geometry.faces.pop();</span><br><span class="line">geometry.faces.shift();</span><br><span class="line">geometry.faces.shift();</span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x0000ff</span>,</span><br><span class="line">  side: THREE.DoubleSide, <span class="comment">//两面可见</span></span><br><span class="line">&#125;); <span class="comment">//材质对象Material</span></span><br></pre></td></tr></table></figure>

<p><img src="./04.png" alt="删除立方体部分三角形面"></p>
]]></content>
  </entry>
  <entry>
    <title>点、线、网格模型介绍</title>
    <url>/2020/07/01/02web/ThreeJS/04%E7%82%B9%E7%BA%BF%E9%9D%A2%E6%A8%A1%E5%9E%8B%E5%AF%B9%E8%B1%A1/01%E7%82%B9%E3%80%81%E7%BA%BF%E3%80%81%E7%BD%91%E6%A0%BC%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p><img src="./01.png" alt="点、线、网格模型介绍"></p>
<h1 id="点模型Points"><a href="#点模型Points" class="headerlink" title="点模型Points"></a>点模型Points</h1><p>点模型Points就是几何体的每一个顶点数据渲染为一个方形区域，方形区域的大小可以设置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>); <span class="comment">//创建一个立方体几何对象Geometry</span></span><br><span class="line"><span class="comment">// 点渲染模式</span></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.PointsMaterial(&#123;</span><br><span class="line">  color: <span class="number">0xff0000</span>,</span><br><span class="line">  size: <span class="number">5.0</span> <span class="comment">//点对象像素尺寸</span></span><br><span class="line">&#125;); <span class="comment">//材质对象</span></span><br><span class="line"><span class="keyword">var</span> points = <span class="keyword">new</span> THREE.Points(geometry, material); <span class="comment">//点模型对象</span></span><br></pre></td></tr></table></figure>

<p><img src="./02.png" alt="点模型"></p>
<h1 id="线模型Line"><a href="#线模型Line" class="headerlink" title="线模型Line"></a>线模型Line</h1><ul>
<li>两点确定一条直线，线模型Line就是使用线条去连接几何体的顶点数据。</li>
<li>Line:如图所示的链接</li>
<li>LineLoop:闭合把第一个顶点和最后一个顶点连接起来</li>
<li>LineSegments:第1、2点确定一条线，第3、4顶点确定一条直线，第2和3点之间不连接</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>); <span class="comment">//创建一个立方体几何对象Geometry</span></span><br><span class="line"><span class="comment">// 线条渲染模式</span></span><br><span class="line"><span class="keyword">var</span> material=<span class="keyword">new</span> THREE.LineBasicMaterial(&#123;</span><br><span class="line">    color:<span class="number">0xff0000</span> <span class="comment">//线条颜色</span></span><br><span class="line">&#125;);<span class="comment">//材质对象</span></span><br><span class="line"><span class="comment">// 创建线模型对象   构造函数：Line、LineLoop、LineSegments</span></span><br><span class="line"><span class="keyword">var</span> line=<span class="keyword">new</span> THREE.Line(geometry,material);<span class="comment">//线条模型对象</span></span><br></pre></td></tr></table></figure>

<p><img src="./03.png" alt="线模型Line"></p>
<h1 id="网格模型Mesh"><a href="#网格模型Mesh" class="headerlink" title="网格模型Mesh"></a>网格模型Mesh</h1><p>通过三角形面绘制渲染几何体的所有顶点，通过一系列的三角形拼接出来一个曲面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"><span class="comment">// 三角形面渲染模式  </span></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x0000ff</span>, <span class="comment">//三角面颜色</span></span><br><span class="line">&#125;); <span class="comment">//材质对象</span></span><br><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型对象Mesh</span></span><br></pre></td></tr></table></figure>

<p><img src="./04.png" alt="网格模型Mesh"></p>
<h2 id="如果设置网格模型的wireframe属性为true，所有三角形会以线条形式绘制出来"><a href="#如果设置网格模型的wireframe属性为true，所有三角形会以线条形式绘制出来" class="headerlink" title="如果设置网格模型的wireframe属性为true，所有三角形会以线条形式绘制出来"></a>如果设置网格模型的wireframe属性为true，所有三角形会以线条形式绘制出来</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>); <span class="comment">//创建一个立方体几何对象Geometry</span></span><br><span class="line"><span class="comment">// 三角面(网格)渲染模式   MeshLambertMaterial  MeshBasicMaterial</span></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x0000ff</span>, <span class="comment">//三角面颜色</span></span><br><span class="line">  wireframe:<span class="literal">true</span>,<span class="comment">//网格模型以线条的模式渲染</span></span><br><span class="line">&#125;); <span class="comment">//材质对象</span></span><br><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span><br></pre></td></tr></table></figure>

<p><img src="./05.png" alt="网格模型Mesh2"></p>
]]></content>
  </entry>
  <entry>
    <title>常用材质对象</title>
    <url>/2020/07/01/02web/ThreeJS/03%E6%9D%90%E8%B4%A8%E5%AF%B9%E8%B1%A1/01%E5%B8%B8%E7%94%A8%E6%9D%90%E8%B4%A8%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p><img src="./01.png" alt="常用材质对象"></p>
<h1 id="点材质"><a href="#点材质" class="headerlink" title="点材质"></a>点材质</h1><ul>
<li>通常使用点模型的时候会使用点材质PointsMaterial</li>
<li>PointsMaterial的.size属性可以每个顶点渲染的方形区域尺寸像素大小</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.SphereGeometry(<span class="number">100</span>, <span class="number">25</span>, <span class="number">25</span>); <span class="comment">//创建一个球体几何对象</span></span><br><span class="line"><span class="comment">// 创建一个点材质对象</span></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.PointsMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x0000ff</span>, <span class="comment">//颜色</span></span><br><span class="line">  size: <span class="number">3</span>, <span class="comment">//点渲染尺寸</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//点模型对象  参数：几何体  点材质</span></span><br><span class="line"><span class="keyword">var</span> point = <span class="keyword">new</span> THREE.Points(geometry, material);</span><br><span class="line">scene.add(point); <span class="comment">//网格模型添加到场景中</span></span><br></pre></td></tr></table></figure>

<p><img src="./02.png" alt="点材质"></p>
<h1 id="线材质"><a href="#线材质" class="headerlink" title="线材质"></a>线材质</h1><ul>
<li>基础线材质LineBasicMaterial</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.SphereGeometry(<span class="number">100</span>, <span class="number">25</span>, <span class="number">25</span>);<span class="comment">//球体</span></span><br><span class="line"><span class="comment">// 直线基础材质对象</span></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.LineBasicMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x0000ff</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> line = <span class="keyword">new</span> THREE.Line(geometry, material); <span class="comment">//线模型对象</span></span><br><span class="line">scene.add(line); <span class="comment">//点模型添加到场景中</span></span><br></pre></td></tr></table></figure>

<ul>
<li>虚线材质LineDashedMaterial</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 虚线材质对象：产生虚线效果</span></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.LineDashedMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x0000ff</span>,</span><br><span class="line">  dashSize: <span class="number">10</span>,<span class="comment">//显示线段的大小。默认为3。</span></span><br><span class="line">  gapSize: <span class="number">5</span>,<span class="comment">//间隙的大小。默认为1</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> line = <span class="keyword">new</span> THREE.Line(geometry, material); <span class="comment">//线模型对象</span></span><br><span class="line"><span class="comment">//  computeLineDistances方法  计算LineDashedMaterial所需的距离数组</span></span><br><span class="line">line.computeLineDistances();</span><br></pre></td></tr></table></figure>

<p><img src="./03.png" alt="线材质"></p>
<h1 id="网格模型"><a href="#网格模型" class="headerlink" title="网格模型"></a>网格模型</h1><p>网格类模型才会使用的材质对象</p>
<ul>
<li>基础网格材质对象MeshBasicMaterial,不受带有方向光源影响，没有棱角感。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x0000ff</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>MeshLambertMaterial材质可以实现网格Mesh表面与光源的漫反射光照计算，有了光照计算，物体表面分界的位置才会产生棱角感</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x00ff00</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>高光网格材质MeshPhongMaterial除了和MeshLambertMaterial一样可以实现光源和网格表面的漫反射光照计算，还可以产生高光效果(镜面反射)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshPhongMaterial(&#123;</span><br><span class="line">  color: <span class="number">0xff0000</span>,</span><br><span class="line">  specular:<span class="number">0x444444</span>,<span class="comment">//高光部分的颜色</span></span><br><span class="line">  shininess:<span class="number">20</span>,<span class="comment">//高光部分的亮度，默认30</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>模型对象旋转平移缩放变换</title>
    <url>/2020/07/01/02web/ThreeJS/04%E7%82%B9%E7%BA%BF%E9%9D%A2%E6%A8%A1%E5%9E%8B%E5%AF%B9%E8%B1%A1/02%E6%A8%A1%E5%9E%8B%E5%AF%B9%E8%B1%A1%E6%97%8B%E8%BD%AC%E5%B9%B3%E7%A7%BB%E7%BC%A9%E6%94%BE%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<p><img src="./01.png" alt="模型对象旋转平移缩放变换"></p>
<h1 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h1><ul>
<li>网格模型Mesh的属性.scale表示模型对象的缩放比例，默认值是THREE.Vector3(1.0,1.0,1.0)</li>
<li>.scale的属性值是一个三维向量对象Vector3</li>
<li>Vector3对象具有属性.x、.y、.z</li>
<li>Vector3对象还具有方法.set()，.set方法有三个表示xyz方向缩放比例<ul>
<li>网格模型xyz方向分别缩放0.5,1.5,2倍<blockquote>
<p>mesh.scale.set(0.5, 1.5, 2)</p>
</blockquote>
</li>
<li>x轴方向放大2倍<blockquote>
<p>mesh.scale.x = 2.0;</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="位置属性"><a href="#位置属性" class="headerlink" title="位置属性"></a>位置属性</h1><ul>
<li>模型位置.position属性和.scale属性的属性值一样也是三维向量对象Vector3</li>
<li>通过模型位置属性.position可以设置模型在场景Scene中的位置</li>
<li>模型位置.position的默认值是THREE.Vector3(0.0,0.0,0.0)<ul>
<li>设置网格模型y坐标<blockquote>
<p>mesh.position.y = 80;</p>
</blockquote>
</li>
<li>设置模型xyz坐标<blockquote>
<p>mesh.position.set(80,2,10);</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h1><ul>
<li>网格模型沿着x轴正方向平移100</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等价于mesh.position = mesh.position + 100;</span></span><br><span class="line">mesh.translateX(<span class="number">100</span>);<span class="comment">//沿着x轴正方向平移距离100</span></span><br></pre></td></tr></table></figure>

<ul>
<li>沿着Z轴负方向平移距离50。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mesh.translateZ(<span class="number">-50</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>沿着自定义的方向移动。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//向量Vector3对象表示方向</span></span><br><span class="line"><span class="keyword">var</span> axis = <span class="keyword">new</span> THREE.Vector3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">axis.normalize(); <span class="comment">//向量归一化</span></span><br><span class="line"><span class="comment">//沿着axis轴表示方向平移100</span></span><br><span class="line">mesh.translateOnAxis(axis, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<h1 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h1><ul>
<li>立方体网格模型绕立方体的x轴旋转π/4</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mesh.rotateX(<span class="built_in">Math</span>.PI/<span class="number">4</span>);<span class="comment">//绕x轴旋转π/4</span></span><br></pre></td></tr></table></figure>

<ul>
<li>网格模型绕(0,1,0)向量表示的轴旋转π/8</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> axis = <span class="keyword">new</span> THREE.Vector3(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);<span class="comment">//向量axis</span></span><br><span class="line">mesh.rotateOnAxis(axis,<span class="built_in">Math</span>.PI/<span class="number">8</span>);<span class="comment">//绕axis轴旋转π/8</span></span><br></pre></td></tr></table></figure>

<ul>
<li>执行旋转.rotateX()等方法和执行平移.translateY()等方法一样都是对模型状态属性的改变</li>
<li>执行平移方法改变的是模型的位置属性.position</li>
<li>执行模型的旋转方法改变的是表示模型角度状态的角度属性.rotation</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>常见光源</title>
    <url>/2020/07/02/02web/ThreeJS/05%E5%85%89%E6%BA%90%E5%AF%B9%E8%B1%A1/01%E5%B8%B8%E8%A7%81%E5%85%89%E6%BA%90/</url>
    <content><![CDATA[<p><img src="./01.png" alt="常见光源"></p>
<p><img src="./02.png" alt="常见光源2"></p>
<h1 id="环境光AmbientLight"><a href="#环境光AmbientLight" class="headerlink" title="环境光AmbientLight"></a>环境光AmbientLight</h1><p>环境光是没有特定方向的光源，主要是均匀整体改变Threejs物体表面的明暗效果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//环境光:环境光颜色RGB成分分别和物体材质颜色RGB成分分别相乘</span></span><br><span class="line"><span class="keyword">var</span> ambient = <span class="keyword">new</span> THREE.AmbientLight(<span class="number">0x444444</span>);</span><br><span class="line">scene.add(ambient);<span class="comment">//环境光对象添加到scene场景中</span></span><br></pre></td></tr></table></figure>

<h1 id="点光源PointLight"><a href="#点光源PointLight" class="headerlink" title="点光源PointLight"></a>点光源PointLight</h1><ul>
<li>点光源就像生活中的白炽灯，光线沿着发光核心向外发散</li>
<li>同一平面的不同位置与点光源光线入射角是不同的</li>
<li>点光源照射下，同一个平面不同区域是呈现出不同的明暗效果</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//点光源</span></span><br><span class="line"><span class="keyword">var</span> point = <span class="keyword">new</span> THREE.PointLight(<span class="number">0xffffff</span>);</span><br><span class="line"><span class="comment">//设置点光源位置，改变光源的位置</span></span><br><span class="line">point.position.set(<span class="number">400</span>, <span class="number">200</span>, <span class="number">300</span>);</span><br><span class="line">scene.add(point);</span><br></pre></td></tr></table></figure>

<h1 id="平行光DirectionalLight"><a href="#平行光DirectionalLight" class="headerlink" title="平行光DirectionalLight"></a>平行光DirectionalLight</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 平行光</span></span><br><span class="line"><span class="keyword">var</span> directionalLight = <span class="keyword">new</span> THREE.DirectionalLight(<span class="number">0xffffff</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 设置光源的方向：通过光源position属性和目标指向对象的position属性计算</span></span><br><span class="line">directionalLight.position.set(<span class="number">80</span>, <span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line"><span class="comment">// 方向光指向对象网格模型mesh2，可以不设置，默认的位置是0,0,0</span></span><br><span class="line">directionalLight.target = mesh2;</span><br><span class="line">scene.add(directionalLight);</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>克隆.clone()和复制.copy()</title>
    <url>/2020/07/01/02web/ThreeJS/04%E7%82%B9%E7%BA%BF%E9%9D%A2%E6%A8%A1%E5%9E%8B%E5%AF%B9%E8%B1%A1/03%E5%85%8B%E9%9A%86.clone()%E5%92%8C%E5%A4%8D%E5%88%B6.copy()/</url>
    <content><![CDATA[<p><img src="./01.png" alt="克隆.clone()和复制.copy()"></p>
<h1 id="复制和克隆"><a href="#复制和克隆" class="headerlink" title="复制和克隆"></a>复制和克隆</h1><ul>
<li>复制<ul>
<li>A.copy(B)表示B属性的值赋值给A对应属性。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> THREE.Vector3(<span class="number">1.2</span>,<span class="number">2.6</span>,<span class="number">3.2</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> THREE.Vector3(<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>);</span><br><span class="line">p2.copy(p1)</span><br><span class="line"><span class="comment">// p2向量的xyz变为p1的xyz值</span></span><br><span class="line"><span class="built_in">console</span>.log(p2);</span><br></pre></td></tr></table></figure>

<ul>
<li>克隆<ul>
<li>N = M.copy()表示返回一个和M相同的对象赋值给N。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> THREE.Vector3(<span class="number">1.2</span>,<span class="number">2.6</span>,<span class="number">3.2</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = p1.clone();</span><br><span class="line"><span class="comment">// p2对象和p1对象xyz属性相同</span></span><br><span class="line"><span class="built_in">console</span>.log(p2);</span><br></pre></td></tr></table></figure>

<h1 id="网格模型复制和克隆"><a href="#网格模型复制和克隆" class="headerlink" title="网格模型复制和克隆"></a>网格模型复制和克隆</h1><ul>
<li>网格模型复制克隆和三维向量基本逻辑是相同</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> box=<span class="keyword">new</span> THREE.BoxGeometry(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>);<span class="comment">//创建一个立方体几何对象</span></span><br><span class="line"><span class="keyword">var</span> material=<span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;<span class="attr">color</span>:<span class="number">0x0000ff</span>&#125;);<span class="comment">//材质对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mesh=<span class="keyword">new</span> THREE.Mesh(box,material);<span class="comment">//网格模型对象</span></span><br><span class="line"><span class="keyword">var</span> mesh2 = mesh.clone();<span class="comment">//克隆网格模型</span></span><br><span class="line">mesh.translateX(<span class="number">20</span>);<span class="comment">//网格模型mesh平移</span></span><br><span class="line"></span><br><span class="line">scene.add(mesh,mesh2);<span class="comment">//网格模型添加到场景中</span></span><br></pre></td></tr></table></figure>

<ul>
<li>缩放几何体box,上面代码中的两个网格模型的大小都发生了变化</li>
<li>网格模型克隆的时候，mesh对象的几何体对象mesh.geometry属性值是box对象的索引值</li>
<li>返回的新对象mesh2几何体属性mesh.geometry的值同样是box对象的索引值</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>常见光源</title>
    <url>/2020/07/08/02web/ThreeJS/05%E5%85%89%E6%BA%90%E5%AF%B9%E8%B1%A1/02%E6%8A%95%E5%BD%B1/</url>
    <content><![CDATA[<h1 id="投影分类"><a href="#投影分类" class="headerlink" title="投影分类"></a>投影分类</h1><ul>
<li>设置产生投影的模型对象</li>
<li>设置接收投影效果的模型</li>
<li>光源对象本身的设置</li>
</ul>
<h2 id="平行投影"><a href="#平行投影" class="headerlink" title="平行投影"></a>平行投影</h2><h3 id="创建立方体"><a href="#创建立方体" class="headerlink" title="创建立方体"></a>创建立方体</h3><ul>
<li>castShadow<ul>
<li>.castShadow属性值是布尔值，默认false，用来设置一个模型对象是否在光照下产生投影效果</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">40</span>, <span class="number">100</span>, <span class="number">40</span>); <span class="comment">//创建一个立方体几何对象Geometry</span></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">      color: <span class="number">0x0000ff</span></span><br><span class="line">    &#125;); <span class="comment">//材质对象Material</span></span><br><span class="line">    <span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">    scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span><br><span class="line"><span class="comment">// 设置产生投影的网格模型</span></span><br><span class="line">    mesh.castShadow = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<h3 id="设置产生投影的网格模型"><a href="#设置产生投影的网格模型" class="headerlink" title="设置产生投影的网格模型"></a>设置产生投影的网格模型</h3><ul>
<li>receiveShadow<ul>
<li>.receiveShadow属性值是布尔值，默认false，用来设置一个模型对象是否在光照下接受其它模型的投影效果。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个平面几何体作为投影面</span></span><br><span class="line"><span class="keyword">var</span> planeGeometry = <span class="keyword">new</span> THREE.PlaneGeometry(<span class="number">300</span>, <span class="number">200</span>);</span><br><span class="line"><span class="keyword">var</span> planeMaterial = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x999999</span></span><br><span class="line">&#125;); <span class="comment">//材质对象Material</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 平面网格模型作为投影面</span></span><br><span class="line"><span class="keyword">var</span> planeMesh = <span class="keyword">new</span> THREE.Mesh(planeGeometry, planeMaterial); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">scene.add(planeMesh); <span class="comment">//网格模型添加到场景中</span></span><br><span class="line">planeMesh.rotateX(-<span class="built_in">Math</span>.PI / <span class="number">2</span>); <span class="comment">//旋转网格模型</span></span><br><span class="line">planeMesh.position.y = <span class="number">-50</span>; <span class="comment">//设置网格模型y坐标</span></span><br><span class="line"><span class="comment">// 设置接收阴影的投影面</span></span><br><span class="line">planeMesh.receiveShadow = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<h3 id="设置投影光源"><a href="#设置投影光源" class="headerlink" title="设置投影光源"></a>设置投影光源</h3><ul>
<li>castShadow<ul>
<li>如果属性设置为 true， 光源将投射动态阴影.</li>
</ul>
</li>
<li>shadow.camera<ul>
<li>观察光源的相机对象. 从光的角度来看，以相机对象的观察位置和方向来判断，其他物体背后的物体将处于阴影中。</li>
</ul>
</li>
<li>shadow.mapSize<ul>
<li>较高的值会以计算时间为代价提供更好的阴影质量. 宽高分量值必须是2的幂</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方向光</span></span><br><span class="line"><span class="keyword">var</span> directionalLight = <span class="keyword">new</span> THREE.DirectionalLight(<span class="number">0xffffff</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 设置光源位置</span></span><br><span class="line">directionalLight.position.set(<span class="number">60</span>, <span class="number">100</span>, <span class="number">40</span>);</span><br><span class="line">scene.add(directionalLight);</span><br><span class="line"><span class="comment">// 设置用于计算阴影的光源对象</span></span><br><span class="line">directionalLight.castShadow = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 设置计算阴影的区域，最好刚好紧密包围在对象周围</span></span><br><span class="line"><span class="comment">// 计算阴影的区域过大：模糊  过小：看不到或显示不完整</span></span><br><span class="line">directionalLight.shadow.camera.near = <span class="number">0.5</span>;</span><br><span class="line">directionalLight.shadow.camera.far = <span class="number">300</span>;</span><br><span class="line">directionalLight.shadow.camera.left = <span class="number">-50</span>;</span><br><span class="line">directionalLight.shadow.camera.right = <span class="number">50</span>;</span><br><span class="line">directionalLight.shadow.camera.top = <span class="number">200</span>;</span><br><span class="line">directionalLight.shadow.camera.bottom = <span class="number">-100</span>;</span><br><span class="line"><span class="comment">// 设置mapSize属性可以使阴影更清晰，不那么模糊</span></span><br><span class="line"><span class="comment">// directionalLight.shadow.mapSize.set(1024,1024)</span></span><br><span class="line"><span class="built_in">console</span>.log(directionalLight.shadow.camera);</span><br></pre></td></tr></table></figure>
<p><img src="./01.png" alt="平行投影"></p>
<h2 id="聚光光源投影"><a href="#聚光光源投影" class="headerlink" title="聚光光源投影"></a>聚光光源投影</h2><p>其他设置与平行光源相同</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 聚光光源</span></span><br><span class="line"><span class="keyword">var</span> spotLight = <span class="keyword">new</span> THREE.SpotLight(<span class="number">0xffffff</span>);</span><br><span class="line"><span class="comment">// 设置聚光光源位置</span></span><br><span class="line">spotLight.position.set(<span class="number">50</span>, <span class="number">90</span>, <span class="number">50</span>);</span><br><span class="line"><span class="comment">// 设置聚光光源发散角度</span></span><br><span class="line">spotLight.angle = <span class="built_in">Math</span>.PI /<span class="number">6</span></span><br><span class="line">scene.add(spotLight); <span class="comment">//光对象添加到scene场景中</span></span><br><span class="line"><span class="comment">// 设置用于计算阴影的光源对象</span></span><br><span class="line">spotLight.castShadow = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 设置计算阴影的区域，注意包裹对象的周围</span></span><br><span class="line">spotLight.shadow.camera.near = <span class="number">1</span>;</span><br><span class="line">spotLight.shadow.camera.far = <span class="number">300</span>;</span><br><span class="line">spotLight.shadow.camera.fov = <span class="number">20</span>;</span><br><span class="line"><span class="comment">// 聚光光源辅助显示</span></span><br><span class="line"><span class="keyword">var</span> spotLightHelper = <span class="keyword">new</span> THREE.SpotLightHelper(spotLight);</span><br><span class="line">scene.add(spotLightHelper);</span><br></pre></td></tr></table></figure>

<p><img src="./02.png" alt="聚光光源投影"></p>
]]></content>
  </entry>
  <entry>
    <title>节点命名.查找.遍历</title>
    <url>/2020/07/09/02web/ThreeJS/06%E5%B1%82%E7%BA%A7%E6%A8%A1%E5%9E%8B/02%E8%8A%82%E7%82%B9%E5%91%BD%E5%90%8D.%E6%9F%A5%E6%89%BE.%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="模型命名"><a href="#模型命名" class="headerlink" title="模型命名"></a>模型命名</h1><p>在层级模型中可以给一些模型对象通过.name属性命名进行标记。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> leftLegMesh = cylinderMesh(<span class="number">4</span>, <span class="number">60</span>, <span class="number">0</span>, <span class="number">-80</span>, <span class="number">-7</span>);</span><br><span class="line">leftLegMesh.name = <span class="string">"左腿"</span></span><br><span class="line"><span class="keyword">var</span> rightLegMesh = cylinderMesh(<span class="number">4</span>, <span class="number">60</span>, <span class="number">0</span>, <span class="number">-80</span>, <span class="number">7</span>);</span><br><span class="line">rightLegMesh.name = <span class="string">"右腿"</span></span><br><span class="line"><span class="keyword">var</span> legGroup = <span class="keyword">new</span> THREE.Group();</span><br><span class="line">legGroup.name = <span class="string">"腿"</span></span><br><span class="line">legGroup.add(leftLegMesh, rightLegMesh);</span><br></pre></td></tr></table></figure>

<h1 id="创建树形结构层级"><a href="#创建树形结构层级" class="headerlink" title="创建树形结构层级"></a>创建树形结构层级</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头部网格模型和组</span></span><br><span class="line"><span class="keyword">var</span> headMesh = sphereMesh(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">headMesh.name = <span class="string">"脑壳"</span></span><br><span class="line"><span class="keyword">var</span> leftEyeMesh = sphereMesh(<span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line">leftEyeMesh.name = <span class="string">"左眼"</span></span><br><span class="line"><span class="keyword">var</span> rightEyeMesh = sphereMesh(<span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">-4</span>);</span><br><span class="line">rightEyeMesh.name = <span class="string">"右眼"</span></span><br><span class="line"><span class="keyword">var</span> headGroup = <span class="keyword">new</span> THREE.Group();</span><br><span class="line">headGroup.name = <span class="string">"头部"</span></span><br><span class="line">headGroup.add(headMesh, leftEyeMesh, rightEyeMesh);</span><br><span class="line"><span class="comment">// 身体网格模型和组</span></span><br><span class="line"><span class="keyword">var</span> neckMesh = cylinderMesh(<span class="number">3</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">-15</span>, <span class="number">0</span>);</span><br><span class="line">neckMesh.name = <span class="string">"脖子"</span></span><br><span class="line"><span class="keyword">var</span> bodyMesh = cylinderMesh(<span class="number">14</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">-35</span>, <span class="number">0</span>);</span><br><span class="line">bodyMesh.name = <span class="string">"腹部"</span></span><br><span class="line"><span class="keyword">var</span> leftLegMesh = cylinderMesh(<span class="number">4</span>, <span class="number">60</span>, <span class="number">0</span>, <span class="number">-80</span>, <span class="number">-7</span>);</span><br><span class="line">leftLegMesh.name = <span class="string">"左腿"</span></span><br><span class="line"><span class="keyword">var</span> rightLegMesh = cylinderMesh(<span class="number">4</span>, <span class="number">60</span>, <span class="number">0</span>, <span class="number">-80</span>, <span class="number">7</span>);</span><br><span class="line">rightLegMesh.name = <span class="string">"右腿"</span></span><br><span class="line"><span class="keyword">var</span> legGroup = <span class="keyword">new</span> THREE.Group();</span><br><span class="line">legGroup.name = <span class="string">"腿"</span></span><br><span class="line">legGroup.add(leftLegMesh, rightLegMesh);</span><br><span class="line"><span class="keyword">var</span> bodyGroup = <span class="keyword">new</span> THREE.Group();</span><br><span class="line">bodyGroup.name = <span class="string">"身体"</span></span><br><span class="line">bodyGroup.add(neckMesh, bodyMesh, legGroup);</span><br><span class="line"><span class="comment">// 人Group</span></span><br><span class="line"><span class="keyword">var</span> personGroup = <span class="keyword">new</span> THREE.Group();</span><br><span class="line">personGroup.name = <span class="string">"人"</span></span><br><span class="line">personGroup.add(headGroup, bodyGroup)</span><br><span class="line">personGroup.translateY(<span class="number">50</span>)</span><br><span class="line">scene.add(personGroup);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 球体网格模型创建函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sphereMesh</span>(<span class="params">R, x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.SphereGeometry(R, <span class="number">25</span>, <span class="number">25</span>); <span class="comment">//球体几何体</span></span><br><span class="line">  <span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshPhongMaterial(&#123;</span><br><span class="line">    color: <span class="number">0x0000ff</span></span><br><span class="line">  &#125;); <span class="comment">//材质对象Material</span></span><br><span class="line">  <span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">// 创建网格模型对象</span></span><br><span class="line">  mesh.position.set(x, y, z);</span><br><span class="line">  <span class="keyword">return</span> mesh;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 圆柱体网格模型创建函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cylinderMesh</span>(<span class="params">R, h, x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.CylinderGeometry(R, R, h, <span class="number">25</span>, <span class="number">25</span>); <span class="comment">//球体几何体</span></span><br><span class="line">  <span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshPhongMaterial(&#123;</span><br><span class="line">    color: <span class="number">0x0000ff</span></span><br><span class="line">  &#125;); <span class="comment">//材质对象Material</span></span><br><span class="line">  <span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">// 创建网格模型对象</span></span><br><span class="line">  mesh.position.set(x, y, z);</span><br><span class="line">  <span class="keyword">return</span> mesh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="递归遍历方法-traverse"><a href="#递归遍历方法-traverse" class="headerlink" title="递归遍历方法.traverse()"></a>递归遍历方法.traverse()</h1><p>.traverse()方法是递归的，遍历父级和子集</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">scene.traverse(<span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj.type === <span class="string">"Group"</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(obj.name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (obj.type === <span class="string">"Mesh"</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'  '</span> + obj.name);</span><br><span class="line">    obj.material.color.set(<span class="number">0xffff00</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (obj.name === <span class="string">"左眼"</span> | obj.name === <span class="string">"右眼"</span>) &#123;</span><br><span class="line">    obj.material.color.set(<span class="number">0x000000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 打印id属性</span></span><br><span class="line">  <span class="built_in">console</span>.log(obj.id);</span><br><span class="line">  <span class="comment">// 打印该对象的父对象</span></span><br><span class="line">  <span class="built_in">console</span>.log(obj.parent);</span><br><span class="line">  <span class="comment">// 打印该对象的子对象</span></span><br><span class="line">  <span class="built_in">console</span>.log(obj.children);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="./01.png" alt="模型命名"></p>
<h1 id="查找某个具体的模型"><a href="#查找某个具体的模型" class="headerlink" title="查找某个具体的模型"></a>查找某个具体的模型</h1><ul>
<li>Threejs和前端DOM一样，可以通过一个方法查找树结构父元素的某个后代对象</li>
<li>对于普通前端而言可以通过name或id等方式查找一个或多个DOM元素</li>
<li>Threejs同样可以通过一些方法查找一个模型树中的某个节点</li>
<li>类似document.getElementById</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历查找scene中复合条件的子对象，并返回id对应的对象</span></span><br><span class="line"><span class="keyword">var</span> idNode = scene.getObjectById ( <span class="number">4</span> );</span><br><span class="line"><span class="built_in">console</span>.log(idNode);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历查找对象的子对象，返回name对应的对象（name是可以重名的，返回第一个）</span></span><br><span class="line"><span class="keyword">var</span> nameNode = scene.getObjectByName ( <span class="string">"左腿"</span> );</span><br><span class="line">nameNode.material.color.set(<span class="number">0xff0000</span>);</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Light和Object3D</title>
    <url>/2020/07/08/02web/ThreeJS/05%E5%85%89%E6%BA%90%E5%AF%B9%E8%B1%A1/03%E5%9F%BA%E7%B1%BBLight%E5%92%8CObject3D/</url>
    <content><![CDATA[<p><img src="./01.png" alt="Light和Object3D"></p>
<h1 id="光源位置属性"><a href="#光源位置属性" class="headerlink" title="光源位置属性"></a>光源位置属性</h1><ul>
<li>PointLight的基类是Light</li>
<li>Light的基类是Object3D</li>
<li>点光源自然继承对象Object3D的位置属性.position。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> point = <span class="keyword">new</span> THREE.PointLight(<span class="number">0xffffff</span>);<span class="comment">//点光源</span></span><br><span class="line"><span class="comment">//设置点光源位置  </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//光源对象和模型对象的position属性一样是Vector3对象</span></span><br><span class="line">point.position.set(<span class="number">400</span>, <span class="number">200</span>, <span class="number">300</span>);</span><br></pre></td></tr></table></figure>

<h1 id="光源颜色属性和强度属性"><a href="#光源颜色属性和强度属性" class="headerlink" title="光源颜色属性和强度属性"></a>光源颜色属性和强度属性</h1><ul>
<li>光源颜色属性.color默认值是白色0xffffff,强度属性</li>
<li>强度属性.intensity默认1.0</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//环境光：颜色设置为`0xffffff`,强度系数设置为0.5</span></span><br><span class="line"><span class="keyword">var</span> ambient = <span class="keyword">new</span> THREE.AmbientLight(<span class="number">0xffffff</span>,<span class="number">0.5</span>);</span><br><span class="line">scene.add(ambient);</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>几何体和曲线</title>
    <url>/2020/07/10/02web/ThreeJS/07%E4%B8%89%E7%BB%B4%E5%87%A0%E4%BD%95%E4%BD%93%E5%BB%BA%E6%A8%A1/01%E5%87%A0%E4%BD%95%E4%BD%93%E5%92%8C%E6%9B%B2%E7%BA%BF/</url>
    <content><![CDATA[<h1 id="几何体"><a href="#几何体" class="headerlink" title="几何体"></a>几何体</h1><ul>
<li>几何体本质上就是threejs生成顶点的算法</li>
<li>所有几何体的基类分为Geometry和BufferGeometry两大类，两类几何体直接可以相互转化。</li>
</ul>
<p><img src="./01.png" alt="几何体"></p>
<h1 id="曲线"><a href="#曲线" class="headerlink" title="曲线"></a>曲线</h1><ul>
<li>曲线和几何体同样本质上都是用来生成顶点的算法</li>
<li>曲线主要是按照一定的规则生成一系列沿着某条轨迹线分布的顶点</li>
</ul>
<p><img src="./01.png" alt="曲线"></p>
]]></content>
  </entry>
  <entry>
    <title>组对象Group</title>
    <url>/2020/07/09/02web/ThreeJS/06%E5%B1%82%E7%BA%A7%E6%A8%A1%E5%9E%8B/01%E7%BB%84%E5%AF%B9%E8%B1%A1Group/</url>
    <content><![CDATA[<p><img src="./01.png" alt="组对象Group"></p>
<h1 id="Group说明"><a href="#Group说明" class="headerlink" title="Group说明"></a>Group说明</h1><h2 id="模型添加到组中"><a href="#模型添加到组中" class="headerlink" title="模型添加到组中"></a>模型添加到组中</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建两个网格模型mesh1、mesh2</span></span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;<span class="attr">color</span>: <span class="number">0x0000ff</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> group = <span class="keyword">new</span> THREE.Group();</span><br><span class="line"><span class="keyword">var</span> mesh1 = <span class="keyword">new</span> THREE.Mesh(geometry, material);</span><br><span class="line"><span class="keyword">var</span> mesh2 = <span class="keyword">new</span> THREE.Mesh(geometry, material);</span><br><span class="line">mesh2.translateX(<span class="number">25</span>);</span><br><span class="line"><span class="comment">//把mesh1型插入到组group中，mesh1作为group的子对象</span></span><br><span class="line">group.add(mesh1);</span><br><span class="line"><span class="comment">//把mesh2型插入到组group中，mesh2作为group的子对象</span></span><br><span class="line">group.add(mesh2);</span><br><span class="line"><span class="comment">//把group插入到场景中作为场景子对象</span></span><br><span class="line">scene.add(group);</span><br></pre></td></tr></table></figure>

<h2 id="组移动"><a href="#组移动" class="headerlink" title="组移动"></a>组移动</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//沿着Y轴平移mesh1和mesh2的父对象，mesh1和mesh2跟着平移</span></span><br><span class="line">group.translateY(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父对象缩放，子对象跟着缩放</span></span><br><span class="line">group.scale.set(<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父对象旋转，子对象跟着旋转</span></span><br><span class="line">group.rotateY(<span class="built_in">Math</span>.PI/<span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Group案例"><a href="#Group案例" class="headerlink" title="Group案例"></a>Group案例</h1><h2 id="模型成线"><a href="#模型成线" class="headerlink" title="模型成线"></a>模型成线</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> group1 = <span class="keyword">new</span> THREE.Group();</span><br><span class="line">    <span class="comment">// 共享材质和几何体数据，批量创建mesh</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">// 创建网格模型对象</span></span><br><span class="line">  mesh.translateX(i * <span class="number">25</span>); <span class="comment">// 平移该网格模型</span></span><br><span class="line">  scene.add(mesh);<span class="comment">//把网格模型插入到场景中</span></span><br><span class="line">  <span class="comment">// group1.add(mesh); //把网格模型插入到组group1中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="./03.png" alt="组对象Group"></p>
<h2 id="模型成面"><a href="#模型成面" class="headerlink" title="模型成面"></a>模型成面</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// group1沿着y轴方向阵列</span></span><br><span class="line"><span class="keyword">var</span> group2 = <span class="keyword">new</span> THREE.Group();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> newGroup = group1.clone(); <span class="comment">// 克隆组group1</span></span><br><span class="line">  newGroup.translateY(i * <span class="number">25</span>); <span class="comment">//沿着z轴平移</span></span><br><span class="line">  scene.add(newGroup); <span class="comment">//场景中插入组group1克隆的对象</span></span><br><span class="line">  <span class="comment">// group2.add(newGroup); //group2中插入组group1克隆的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="./04.png" alt="组对象Group"></p>
<h2 id="模型成体"><a href="#模型成体" class="headerlink" title="模型成体"></a>模型成体</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// group2沿着z轴方向阵列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> newGroup = group2.clone(); <span class="comment">// 克隆组group2</span></span><br><span class="line">  newGroup.translateZ(i * <span class="number">25</span>); <span class="comment">//沿着z轴平移</span></span><br><span class="line">  scene.add(newGroup); <span class="comment">//场景中插入组group2的克隆对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="./02.png" alt="组对象Group"></p>
]]></content>
  </entry>
  <entry>
    <title>绘制圆弧</title>
    <url>/2020/07/10/02web/ThreeJS/07%E4%B8%89%E7%BB%B4%E5%87%A0%E4%BD%95%E4%BD%93%E5%BB%BA%E6%A8%A1/02%E7%BB%98%E5%88%B6%E5%9C%86%E5%BC%A7/</url>
    <content><![CDATA[<h1 id="圆弧线ArcCurve"><a href="#圆弧线ArcCurve" class="headerlink" title="圆弧线ArcCurve"></a>圆弧线ArcCurve</h1><p>圆弧线ArcCurve的基类是椭圆弧线EllipseCurve</p>
<blockquote>
<p>ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise )</p>
</blockquote>
<table>
<thead>
<tr>
<th>参数</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td>aX, aY</td>
<td align="center">圆弧圆心坐标</td>
</tr>
<tr>
<td>aRadius</td>
<td align="center">圆弧半径</td>
</tr>
<tr>
<td>aStartAngle, aEndAngle</td>
<td align="center">起始角度</td>
</tr>
<tr>
<td>aClockwise</td>
<td align="center">是否顺时针绘制，默认值为false</td>
</tr>
</tbody></table>
<h2 id="ArcCurve创建圆弧"><a href="#ArcCurve创建圆弧" class="headerlink" title="ArcCurve创建圆弧"></a>ArcCurve创建圆弧</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.Geometry(); <span class="comment">//声明一个几何体对象Geometry</span></span><br><span class="line"><span class="comment">//参数：0, 0圆弧坐标原点x，y  100：圆弧半径    0, 2 * Math.PI：圆弧起始角度</span></span><br><span class="line"><span class="keyword">var</span> arc = <span class="keyword">new</span> THREE.ArcCurve(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI);</span><br><span class="line"><span class="comment">//getPoints是基类Curve的方法，返回一个vector2对象作为元素组成的数组</span></span><br><span class="line"><span class="keyword">var</span> points = arc.getPoints(<span class="number">50</span>);<span class="comment">//分段数50，返回51个顶点</span></span><br><span class="line"><span class="comment">// setFromPoints方法从points中提取数据改变几何体的顶点属性vertices</span></span><br><span class="line">geometry.setFromPoints(points);</span><br><span class="line"><span class="comment">//材质对象</span></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.LineBasicMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x000000</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//线条模型对象</span></span><br><span class="line"><span class="keyword">var</span> line = <span class="keyword">new</span> THREE.Line(geometry, material);</span><br><span class="line">scene.add(line); <span class="comment">//线条对象添加到场景中</span></span><br></pre></td></tr></table></figure>

<h2 id="创建点创建圆弧"><a href="#创建点创建圆弧" class="headerlink" title="创建点创建圆弧"></a>创建点创建圆弧</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.Geometry(); <span class="comment">//声明一个几何体对象Geometry</span></span><br><span class="line"><span class="keyword">var</span> R = <span class="number">100</span>; <span class="comment">//圆弧半径</span></span><br><span class="line"><span class="keyword">var</span> N = <span class="number">50</span>; <span class="comment">//分段数量</span></span><br><span class="line"><span class="comment">// 批量生成圆弧上的顶点数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> angle = <span class="number">2</span> * <span class="built_in">Math</span>.PI / N * i;</span><br><span class="line">  <span class="keyword">var</span> x = R * <span class="built_in">Math</span>.sin(angle);</span><br><span class="line">  <span class="keyword">var</span> y = R * <span class="built_in">Math</span>.cos(angle);</span><br><span class="line">  geometry.vertices.push(<span class="keyword">new</span> THREE.Vector3(x, y, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入最后一个点，line渲染模式下，产生闭合效果</span></span><br><span class="line">geometry.vertices.push(geometry.vertices[<span class="number">0</span>])</span><br><span class="line"><span class="comment">//材质对象</span></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.LineBasicMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x000000</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//线条模型对象</span></span><br><span class="line"><span class="keyword">var</span> line = <span class="keyword">new</span> THREE.Line(geometry, material);</span><br><span class="line"><span class="comment">// var line = new THREE.LineLoop(geometry, material); // 不需要geometry.vertices[0]而自动闭合</span></span><br><span class="line">scene.add(line); <span class="comment">//线条对象添加到场景中</span></span><br></pre></td></tr></table></figure>

<h2 id="getPoints-方法"><a href="#getPoints-方法" class="headerlink" title="getPoints()方法"></a>getPoints()方法</h2><p>上面两个圆弧例子都用到了getPoints方法</p>
<ul>
<li>.getPoints()是基类Curve的方法</li>
<li>通过方法.getPoints()可以从圆弧线按照一定的细分精度返回沿着圆弧线分布的顶点坐标</li>
<li>细分数越高返回的顶点数量越多，自然轮廓越接近于圆形</li>
<li>返回值是一个由二维向量Vector2或三维向量Vector3构成的数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arc = <span class="keyword">new</span> THREE.ArcCurve(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI);</span><br><span class="line"><span class="comment">//getPoints是基类Curve的方法，返回一个vector2对象作为元素组成的数组</span></span><br><span class="line"><span class="keyword">var</span> points = arc.getPoints(<span class="number">50</span>);<span class="comment">//分段数50，返回51个顶点</span></span><br></pre></td></tr></table></figure>

<h2 id="setFromPoints-方法"><a href="#setFromPoints-方法" class="headerlink" title="setFromPoints()方法"></a>setFromPoints()方法</h2><ul>
<li>.setFromPoints()是几何体Geometry的方法</li>
<li>通过该方法可以把数组points中顶点数据提取出来赋值给几何体的顶点位置属性</li>
<li>BufferGeometry和Geometry一样具有方法.setFromPoints()<ul>
<li>Geometry——给几何体的顶点位置属性geometry.vertices</li>
<li>BufferGeometry——给geometry.attributes.position属性</li>
</ul>
</li>
</ul>
<h1 id="绘制直线"><a href="#绘制直线" class="headerlink" title="绘制直线"></a>绘制直线</h1><h2 id="直接绘制"><a href="#直接绘制" class="headerlink" title="直接绘制"></a>直接绘制</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.Geometry(); <span class="comment">//声明一个几何体对象Geometry</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> THREE.Vector3(<span class="number">50</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//顶点1坐标</span></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> THREE.Vector3(<span class="number">0</span>, <span class="number">70</span>, <span class="number">0</span>); <span class="comment">//顶点2坐标</span></span><br><span class="line"><span class="comment">//顶点坐标添加到geometry对象</span></span><br><span class="line">geometry.vertices.push(p1, p2);</span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.LineBasicMaterial(&#123;</span><br><span class="line">  color: <span class="number">0xffff00</span>,</span><br><span class="line">&#125;);<span class="comment">//材质对象</span></span><br><span class="line"><span class="comment">//线条模型对象</span></span><br><span class="line"><span class="keyword">var</span> line = <span class="keyword">new</span> THREE.Line(geometry, material);</span><br><span class="line">scene.add(line); <span class="comment">//线条对象添加到场景中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 点模型</span></span><br><span class="line"><span class="keyword">var</span> material2 = <span class="keyword">new</span> THREE.PointsMaterial(&#123;</span><br><span class="line">  color: <span class="number">0xff00ff</span>,</span><br><span class="line">  size:<span class="number">5</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//点模型对象</span></span><br><span class="line"><span class="keyword">var</span> points = <span class="keyword">new</span> THREE.Points(geometry, material2);</span><br><span class="line">scene.add(points); <span class="comment">//点模型对象添加到场景中</span></span><br></pre></td></tr></table></figure>

<p><img src="./01.png" alt="直接绘制"></p>
<h2 id="LineCurve3绘制一条三维直线"><a href="#LineCurve3绘制一条三维直线" class="headerlink" title="LineCurve3绘制一条三维直线"></a>LineCurve3绘制一条三维直线</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.Geometry(); <span class="comment">//声明一个几何体对象Geometry</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> THREE.Vector3(<span class="number">50</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//顶点1坐标</span></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> THREE.Vector3(<span class="number">0</span>, <span class="number">70</span>, <span class="number">0</span>); <span class="comment">//顶点2坐标</span></span><br><span class="line"><span class="comment">// 三维直线LineCurve3</span></span><br><span class="line"><span class="keyword">var</span> LineCurve = <span class="keyword">new</span> THREE.LineCurve3(p1, p2);</span><br><span class="line"><span class="keyword">var</span> pointArr = LineCurve.getPoints(<span class="number">10</span>); <span class="comment">// 以这两个顶点为基准细分10个顶点</span></span><br><span class="line">geometry.setFromPoints(pointArr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点模型</span></span><br><span class="line"><span class="keyword">var</span> material2 = <span class="keyword">new</span> THREE.PointsMaterial(&#123;</span><br><span class="line">  color: <span class="number">0xff00ff</span>,</span><br><span class="line">  size:<span class="number">5</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//点模型对象</span></span><br><span class="line"><span class="keyword">var</span> points = <span class="keyword">new</span> THREE.Points(geometry, material2);</span><br><span class="line">scene.add(points); <span class="comment">//点模型对象添加到场景中</span></span><br></pre></td></tr></table></figure>

<p><img src="./02.png" alt="LineCurve3"></p>
<h2 id="LineCurve绘制"><a href="#LineCurve绘制" class="headerlink" title="LineCurve绘制"></a>LineCurve绘制</h2><p>和上面区别是不需要设置点的z坐标，默认为0</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.Geometry(); <span class="comment">//声明一个几何体对象Geometry</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> THREE.Vector2(<span class="number">50</span>, <span class="number">0</span>); <span class="comment">//顶点1坐标</span></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> THREE.Vector2(<span class="number">0</span>, <span class="number">70</span>); <span class="comment">//顶点2坐标</span></span><br><span class="line"><span class="comment">// 二维直线LineCurve</span></span><br><span class="line"><span class="keyword">var</span> LineCurve = <span class="keyword">new</span> THREE.LineCurve(p1, p2);</span><br><span class="line"><span class="keyword">var</span> pointArr = LineCurve.getPoints(<span class="number">10</span>);</span><br><span class="line">geometry.setFromPoints(pointArr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点模型</span></span><br><span class="line"><span class="keyword">var</span> material2 = <span class="keyword">new</span> THREE.PointsMaterial(&#123;</span><br><span class="line">  color: <span class="number">0xff00ff</span>,</span><br><span class="line">  size:<span class="number">5</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//点模型对象</span></span><br><span class="line"><span class="keyword">var</span> points = <span class="keyword">new</span> THREE.Points(geometry, material2);</span><br><span class="line">scene.add(points); <span class="comment">//点模型对象添加到场景中</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>多个线条组合曲线</title>
    <url>/2020/07/14/02web/ThreeJS/07%E4%B8%89%E7%BB%B4%E5%87%A0%E4%BD%95%E4%BD%93%E5%BB%BA%E6%A8%A1/04%E5%A4%9A%E4%B8%AA%E7%BA%BF%E6%9D%A1%E7%BB%84%E5%90%88%E6%9B%B2%E7%BA%BF/</url>
    <content><![CDATA[<ul>
<li>通过组合曲线CurvePath可以把多个圆弧线、样条曲线、直线等多个曲线合并成一个曲线。</li>
<li>线条组合时候需要有顺序</li>
</ul>
<h1 id="正常顺序"><a href="#正常顺序" class="headerlink" title="正常顺序"></a>正常顺序</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.Geometry(); <span class="comment">//声明一个几何体对象Geometry</span></span><br><span class="line"><span class="comment">// 绘制一个U型轮廓</span></span><br><span class="line"><span class="keyword">var</span> R = <span class="number">80</span>;<span class="comment">//圆弧半径</span></span><br><span class="line"><span class="keyword">var</span> arc = <span class="keyword">new</span> THREE.ArcCurve(<span class="number">0</span>, <span class="number">0</span>, R, <span class="number">0</span>, <span class="built_in">Math</span>.PI, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 半圆弧的一个端点作为直线的一个端点</span></span><br><span class="line"><span class="keyword">var</span> line1 = <span class="keyword">new</span> THREE.LineCurve(<span class="keyword">new</span> THREE.Vector2(R, <span class="number">200</span>, <span class="number">0</span>), <span class="keyword">new</span> THREE.Vector2(R, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">var</span> line2 = <span class="keyword">new</span> THREE.LineCurve(<span class="keyword">new</span> THREE.Vector2(-R, <span class="number">0</span>, <span class="number">0</span>), <span class="keyword">new</span> THREE.Vector2(-R, <span class="number">200</span>, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 创建组合曲线对象CurvePath</span></span><br><span class="line"><span class="keyword">var</span> CurvePath = <span class="keyword">new</span> THREE.CurvePath();</span><br><span class="line"><span class="comment">// 把多个线条插入到CurvePath中</span></span><br><span class="line">CurvePath.curves.push(line1, arc, line2);</span><br><span class="line"><span class="comment">//分段数200</span></span><br><span class="line"><span class="keyword">var</span> points = CurvePath.getPoints(<span class="number">200</span>);</span><br><span class="line"><span class="comment">// setFromPoints方法从points中提取数据改变几何体的顶点属性vertices</span></span><br><span class="line">geometry.setFromPoints(points);</span><br><span class="line"><span class="comment">//材质对象</span></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.LineBasicMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x000000</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//线条模型对象</span></span><br><span class="line"><span class="keyword">var</span> line = <span class="keyword">new</span> THREE.Line(geometry, material);</span><br><span class="line">scene.add(line); <span class="comment">//线条对象添加到场景中</span></span><br></pre></td></tr></table></figure>

<p><img src="./01.png" alt="多个线条组合曲线"></p>
<h1 id="颠倒顺序"><a href="#颠倒顺序" class="headerlink" title="颠倒顺序"></a>颠倒顺序</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">CurvePath.curves.push(line1, line2, arc);</span><br></pre></td></tr></table></figure>

<p><img src="./02.png" alt="多个线条组合曲线"></p>
]]></content>
  </entry>
  <entry>
    <title>世界坐标</title>
    <url>/2020/07/10/02web/ThreeJS/06%E5%B1%82%E7%BA%A7%E6%A8%A1%E5%9E%8B/03%E4%B8%96%E7%95%8C%E5%9D%90%E6%A0%87/</url>
    <content><![CDATA[<p>Three.js获得世界坐标.getWorldPosition()</p>
<h1 id="世界坐标系概念"><a href="#世界坐标系概念" class="headerlink" title="世界坐标系概念"></a>世界坐标系概念</h1><ul>
<li>本地坐标：几何体在该父级组里面的坐标</li>
<li>世界坐标：几何体在坐标系下的坐标，本地坐标+组坐标</li>
</ul>
<h2 id="创建几何体"><a href="#创建几何体" class="headerlink" title="创建几何体"></a>创建几何体</h2><p>创建几何体并设置坐标x轴向右50</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material);</span><br><span class="line"><span class="comment">// mesh的本地坐标设置为(50, 0, 0)</span></span><br><span class="line">mesh.position.set(<span class="number">50</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h2 id="创建组"><a href="#创建组" class="headerlink" title="创建组"></a>创建组</h2><p>创建组，把几何体放入组中，并把组设置X向右50</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> group = <span class="keyword">new</span> THREE.Group();</span><br><span class="line"><span class="comment">// group本地坐标设置和mesh一样设置为(50, 0, 0)</span></span><br><span class="line"><span class="comment">// mesh父对象设置position会影响得到mesh的世界坐标</span></span><br><span class="line">group.position.set(<span class="number">50</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">group.add(mesh);</span><br><span class="line">scene.add(group);</span><br></pre></td></tr></table></figure>

<h2 id="获取几何体本地坐标"><a href="#获取几何体本地坐标" class="headerlink" title="获取几何体本地坐标"></a>获取几何体本地坐标</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .position属性获得本地坐标</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'本地坐标'</span>,mesh.position);</span><br></pre></td></tr></table></figure>

<h2 id="获取几何体世界坐标"><a href="#获取几何体世界坐标" class="headerlink" title="获取几何体世界坐标"></a>获取几何体世界坐标</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// getWorldPosition()方法获得世界坐标</span></span><br><span class="line"><span class="comment">//该语句默认在threejs渲染的过程中执行,如果渲染之前想获得世界矩阵属性、世界位置属性等属性，需要通过代码更新</span></span><br><span class="line">scene.updateMatrixWorld(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">var</span> worldPosition = <span class="keyword">new</span> THREE.Vector3();</span><br><span class="line">mesh.getWorldPosition(worldPosition);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'世界坐标'</span>,worldPosition);</span><br></pre></td></tr></table></figure>

<p><img src="./01.png" alt="世界坐标"></p>
]]></content>
  </entry>
  <entry>
    <title>样条曲线,贝塞尔曲线</title>
    <url>/2020/07/14/02web/ThreeJS/07%E4%B8%89%E7%BB%B4%E5%87%A0%E4%BD%95%E4%BD%93%E5%BB%BA%E6%A8%A1/03%E6%A0%B7%E6%9D%A1%E6%9B%B2%E7%BA%BF,%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF/</url>
    <content><![CDATA[<p><img src="./01.png" alt="样条曲线,贝塞尔曲线"></p>
<h1 id="光滑样条曲线"><a href="#光滑样条曲线" class="headerlink" title="光滑样条曲线"></a>光滑样条曲线</h1><ul>
<li>定义点</li>
<li>根据定义的点再细分出更多的点</li>
<li>把这些点放到模型中进行渲染</li>
</ul>
<h2 id="光滑曲线样例"><a href="#光滑曲线样例" class="headerlink" title="光滑曲线样例"></a>光滑曲线样例</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.Geometry(); <span class="comment">//声明一个几何体对象Geometry</span></span><br><span class="line"><span class="comment">// 三维样条曲线  Catmull-Rom算法</span></span><br><span class="line"><span class="keyword">var</span> curve = <span class="keyword">new</span> THREE.CatmullRomCurve3([</span><br><span class="line">  <span class="keyword">new</span> THREE.Vector3(<span class="number">-50</span>, <span class="number">20</span>, <span class="number">90</span>),</span><br><span class="line">  <span class="keyword">new</span> THREE.Vector3(<span class="number">-10</span>, <span class="number">40</span>, <span class="number">40</span>),</span><br><span class="line">  <span class="keyword">new</span> THREE.Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">  <span class="keyword">new</span> THREE.Vector3(<span class="number">60</span>, <span class="number">-60</span>, <span class="number">0</span>),</span><br><span class="line">  <span class="keyword">new</span> THREE.Vector3(<span class="number">70</span>, <span class="number">0</span>, <span class="number">80</span>)</span><br><span class="line">]);</span><br><span class="line"><span class="comment">//getPoints是基类Curve的方法，返回一个vector3对象作为元素组成的数组</span></span><br><span class="line"><span class="keyword">var</span> points = curve.getPoints(<span class="number">100</span>); <span class="comment">//分段数100，返回101个顶点</span></span><br><span class="line"><span class="comment">// setFromPoints方法从points中提取数据改变几何体的顶点属性vertices</span></span><br><span class="line">geometry.setFromPoints(points);</span><br><span class="line"><span class="comment">//材质对象</span></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.LineBasicMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x000000</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//线条模型对象</span></span><br><span class="line"><span class="keyword">var</span> line = <span class="keyword">new</span> THREE.Line(geometry, material);</span><br><span class="line">scene.add(line); <span class="comment">//线条对象添加到场景中</span></span><br></pre></td></tr></table></figure>

<p><img src="./02.png" alt="光滑样条曲线"></p>
<h2 id="正方体曲线样例"><a href="#正方体曲线样例" class="headerlink" title="正方体曲线样例"></a>正方体曲线样例</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.Geometry(); <span class="comment">//声明一个几何体对象Geometry</span></span><br><span class="line"><span class="comment">// 定义正方体</span></span><br><span class="line"><span class="keyword">var</span> box = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"><span class="comment">// 获取正方体的顶点坐标</span></span><br><span class="line"><span class="keyword">var</span> curve = <span class="keyword">new</span> THREE.CatmullRomCurve3(box.vertices);</span><br><span class="line"><span class="comment">//getPoints是基类Curve的方法，返回一个vector3对象作为元素组成的数组</span></span><br><span class="line"><span class="keyword">var</span> points = curve.getPoints(<span class="number">100</span>); <span class="comment">//分段数100，返回101个顶点</span></span><br><span class="line"><span class="comment">// setFromPoints方法从points中提取数据改变几何体的顶点属性vertices</span></span><br><span class="line">geometry.setFromPoints(points);</span><br><span class="line"><span class="comment">//材质对象</span></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.LineBasicMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x000000</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//线条模型对象</span></span><br><span class="line"><span class="keyword">var</span> line = <span class="keyword">new</span> THREE.Line(geometry, material);</span><br><span class="line">scene.add(line); <span class="comment">//线条对象添加到场景中</span></span><br><span class="line">scene.add(<span class="keyword">new</span> THREE.Line(box));<span class="comment">//线条模式渲染立方体</span></span><br></pre></td></tr></table></figure>

<p><img src="./05.png" alt="正方体曲线样例"></p>
<h1 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h1><ul>
<li>贝塞尔曲线和样条曲线不同，多了一个控制点概念。</li>
<li>二次贝赛尔曲线的参数p1、p3是起始点，p2是控制点，控制点不在贝塞尔曲线上。</li>
</ul>
<h2 id="二次贝塞尔曲线"><a href="#二次贝塞尔曲线" class="headerlink" title="二次贝塞尔曲线"></a>二次贝塞尔曲线</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.Geometry(); <span class="comment">//声明一个几何体对象Geometry</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> THREE.Vector3(<span class="number">-80</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> THREE.Vector3(<span class="number">20</span>, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> THREE.Vector3(<span class="number">80</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 三维二次贝赛尔曲线</span></span><br><span class="line"><span class="keyword">var</span> curve = <span class="keyword">new</span> THREE.QuadraticBezierCurve3(p1, p2, p3);</span><br><span class="line"><span class="comment">//getPoints是基类Curve的方法，返回一个vector3对象作为元素组成的数组</span></span><br><span class="line"><span class="keyword">var</span> points = curve.getPoints(<span class="number">100</span>); <span class="comment">//分段数100，返回101个顶点</span></span><br><span class="line"><span class="comment">// setFromPoints方法从points中提取数据改变几何体的顶点属性vertices</span></span><br><span class="line">geometry.setFromPoints(points);</span><br><span class="line"><span class="comment">//材质对象</span></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.LineBasicMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x000000</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//线条模型对象</span></span><br><span class="line"><span class="keyword">var</span> line = <span class="keyword">new</span> THREE.Line(geometry, material);</span><br><span class="line">scene.add(line); <span class="comment">//线条对象添加到场景中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 点模型</span></span><br><span class="line"><span class="keyword">var</span> geometry2 = <span class="keyword">new</span> THREE.Geometry();</span><br><span class="line">geometry2.vertices.push(p1, p2, p3)</span><br><span class="line"><span class="keyword">var</span> material2 = <span class="keyword">new</span> THREE.PointsMaterial(&#123;</span><br><span class="line">  color: <span class="number">0xff00ff</span>,</span><br><span class="line">  size: <span class="number">10</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//点模型对象</span></span><br><span class="line"><span class="keyword">var</span> points = <span class="keyword">new</span> THREE.Points(geometry2, material2);</span><br><span class="line">scene.add(points); <span class="comment">//点模型对象添加到场景中</span></span><br><span class="line">scene.add(<span class="keyword">new</span> THREE.Line(geometry2, material2));</span><br></pre></td></tr></table></figure>

<p><img src="./03.png" alt="二次贝塞尔曲线"></p>
<h2 id="三次贝塞尔曲线"><a href="#三次贝塞尔曲线" class="headerlink" title="三次贝塞尔曲线"></a>三次贝塞尔曲线</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.Geometry(); <span class="comment">//声明一个几何体对象Geometry</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> THREE.Vector3(<span class="number">-80</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> THREE.Vector3(<span class="number">-40</span>, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> THREE.Vector3(<span class="number">40</span>, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> p4 = <span class="keyword">new</span> THREE.Vector3(<span class="number">80</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 三维三次贝赛尔曲线</span></span><br><span class="line"><span class="keyword">var</span> curve = <span class="keyword">new</span> THREE.CubicBezierCurve3(p1, p2, p3, p4);</span><br><span class="line"><span class="comment">//getPoints是基类Curve的方法，返回一个vector3对象作为元素组成的数组</span></span><br><span class="line"><span class="keyword">var</span> points = curve.getPoints(<span class="number">100</span>); <span class="comment">//分段数100，返回101个顶点</span></span><br><span class="line"><span class="comment">// setFromPoints方法从points中提取数据改变几何体的顶点属性vertices</span></span><br><span class="line">geometry.setFromPoints(points);</span><br><span class="line"><span class="comment">//材质对象</span></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.LineBasicMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x000000</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//线条模型对象</span></span><br><span class="line"><span class="keyword">var</span> line = <span class="keyword">new</span> THREE.Line(geometry, material);</span><br><span class="line">scene.add(line); <span class="comment">//线条对象添加到场景中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 点模型</span></span><br><span class="line"><span class="keyword">var</span> geometry2 = <span class="keyword">new</span> THREE.Geometry();</span><br><span class="line">geometry2.vertices.push(p1, p2, p3, p4)</span><br><span class="line"><span class="keyword">var</span> material2 = <span class="keyword">new</span> THREE.PointsMaterial(&#123;</span><br><span class="line">  color: <span class="number">0xff00ff</span>,</span><br><span class="line">  size: <span class="number">10</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//点模型对象</span></span><br><span class="line"><span class="keyword">var</span> points = <span class="keyword">new</span> THREE.Points(geometry2, material2);</span><br><span class="line">scene.add(points); <span class="comment">//点模型对象添加到场景中</span></span><br><span class="line">scene.add(<span class="keyword">new</span> THREE.Line(geometry2, material2));</span><br></pre></td></tr></table></figure>

<p><img src="./04.png" alt="三次贝塞尔曲线"></p>
]]></content>
  </entry>
  <entry>
    <title>曲线路径管道</title>
    <url>/2020/07/14/02web/ThreeJS/07%E4%B8%89%E7%BB%B4%E5%87%A0%E4%BD%95%E4%BD%93%E5%BB%BA%E6%A8%A1/05%E6%9B%B2%E7%BA%BF%E8%B7%AF%E5%BE%84%E7%AE%A1%E9%81%93/</url>
    <content><![CDATA[<h1 id="TubeGeometry"><a href="#TubeGeometry" class="headerlink" title="TubeGeometry"></a>TubeGeometry</h1><h2 id="TubeGeometry概念用法"><a href="#TubeGeometry概念用法" class="headerlink" title="TubeGeometry概念用法"></a>TubeGeometry概念用法</h2><ul>
<li>TubeGeometry的功能就是通过一条曲线生成一个圆管</li>
<li>本质就是以曲线上顶点为基准，生成一系列曲线等径分布的顶点数据</li>
</ul>
<blockquote>
<p>构造函数格式：TubeGeometry(path, tubularSegments, radius, radiusSegments, closed)</p>
</blockquote>
<table>
<thead>
<tr>
<th>参数</th>
<th align="center">值</th>
</tr>
</thead>
<tbody><tr>
<td>path</td>
<td align="center">扫描路径，基本类是Curve的路径构造函数</td>
</tr>
<tr>
<td>tubularSegments</td>
<td align="center">路径方向细分数，默认64</td>
</tr>
<tr>
<td>radius</td>
<td align="center">管道半径，默认1</td>
</tr>
<tr>
<td>radiusSegments</td>
<td align="center">管道圆弧细分数，默认8</td>
</tr>
<tr>
<td>closed</td>
<td align="center">Boolean值，管道是否闭合</td>
</tr>
</tbody></table>
<h2 id="样条曲面生成圆管"><a href="#样条曲面生成圆管" class="headerlink" title="样条曲面生成圆管"></a>样条曲面生成圆管</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建管道成型的路径(3D样条曲线)</span></span><br><span class="line"><span class="keyword">var</span> path = <span class="keyword">new</span> THREE.CatmullRomCurve3([</span><br><span class="line">  <span class="keyword">new</span> THREE.Vector3(<span class="number">-10</span>, <span class="number">-50</span>, <span class="number">-50</span>),</span><br><span class="line">  <span class="keyword">new</span> THREE.Vector3(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">  <span class="keyword">new</span> THREE.Vector3(<span class="number">8</span>, <span class="number">50</span>, <span class="number">50</span>),</span><br><span class="line">  <span class="keyword">new</span> THREE.Vector3(<span class="number">-5</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// path:路径   40：沿着轨迹细分数  2：管道半径   25：管道截面圆细分数</span></span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.TubeGeometry(path, <span class="number">40</span>, <span class="number">2</span>, <span class="number">25</span>);</span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshPhongMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x0000ff</span>,</span><br><span class="line">  side: THREE.DoubleSide <span class="comment">//两面可见</span></span><br><span class="line">&#125;); <span class="comment">//材质对象</span></span><br><span class="line"><span class="comment">// material.wireframe = true;//线条模式渲染(查看细分数)</span></span><br><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//管道网格模型对象</span></span><br><span class="line">scene.add(mesh); <span class="comment">//管道网格模型添加到场景中</span></span><br></pre></td></tr></table></figure>

<p><img src="./01.png" alt="样条曲面生成圆管"></p>
<p>线条模式渲染</p>
<blockquote>
<p>material.wireframe = true</p>
</blockquote>
<p><img src="./03.png" alt="线条模式渲染"></p>
<h2 id="多段路径生成管道"><a href="#多段路径生成管道" class="headerlink" title="多段路径生成管道"></a>多段路径生成管道</h2><ul>
<li>创建一段样条曲线和两条直线拼接成的路径</li>
<li>通过曲线路径CurvePath把样条曲线和料条曲线合并成为一条路径</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建多段线条的顶点数据</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> THREE.Vector3(<span class="number">-85.35</span>, <span class="number">-35.36</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> THREE.Vector3(<span class="number">-50</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> THREE.Vector3(<span class="number">0</span>, <span class="number">50</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> p4 = <span class="keyword">new</span> THREE.Vector3(<span class="number">50</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> p5 = <span class="keyword">new</span> THREE.Vector3(<span class="number">85.35</span>, <span class="number">-35.36</span>);</span><br><span class="line"><span class="comment">// 创建线条一：直线</span></span><br><span class="line"><span class="keyword">let</span> line1 = <span class="keyword">new</span> THREE.LineCurve3(p1,p2);</span><br><span class="line"><span class="comment">// 重建线条2：三维样条曲线</span></span><br><span class="line"><span class="keyword">var</span> curve = <span class="keyword">new</span> THREE.CatmullRomCurve3([p2, p3, p4]);</span><br><span class="line"><span class="comment">// 创建线条3：直线</span></span><br><span class="line"><span class="keyword">let</span> line2 = <span class="keyword">new</span> THREE.LineCurve3(p4,p5);</span><br><span class="line"><span class="keyword">var</span> CurvePath = <span class="keyword">new</span> THREE.CurvePath();<span class="comment">// 创建CurvePath对象</span></span><br><span class="line">CurvePath.curves.push(line1, curve, line2);<span class="comment">// 插入多段线条</span></span><br><span class="line"><span class="comment">//通过多段曲线路径创建生成管道，CCurvePath：管道路径</span></span><br><span class="line"><span class="keyword">var</span> geometry2 = <span class="keyword">new</span> THREE.TubeGeometry(CurvePath, <span class="number">100</span>, <span class="number">5</span>, <span class="number">25</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">//材质对象</span></span><br><span class="line"><span class="keyword">var</span> material2 = <span class="keyword">new</span> THREE.MeshPhongMaterial(&#123;</span><br><span class="line">  color: <span class="number">0xE6A23C</span>,</span><br><span class="line">  side: THREE.DoubleSide,<span class="comment">//双面可见</span></span><br><span class="line">&#125;); </span><br><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry2, material2);</span><br><span class="line">scene.add(mesh);</span><br><span class="line"><span class="comment">// 坐标系辅助显示</span></span><br><span class="line"><span class="keyword">var</span> axesHelper = <span class="keyword">new</span> THREE.AxesHelper(<span class="number">200</span>);</span><br><span class="line">scene.add(axesHelper);</span><br></pre></td></tr></table></figure>

<p><img src="./02.png" alt="多段路径生成管道"></p>
]]></content>
  </entry>
  <entry>
    <title>旋转成型</title>
    <url>/2020/07/14/02web/ThreeJS/07%E4%B8%89%E7%BB%B4%E5%87%A0%E4%BD%95%E4%BD%93%E5%BB%BA%E6%A8%A1/06%E6%97%8B%E8%BD%AC%E6%88%90%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="LatheGeometry"><a href="#LatheGeometry" class="headerlink" title="LatheGeometry"></a>LatheGeometry</h1><h2 id="LatheGeometry使用"><a href="#LatheGeometry使用" class="headerlink" title="LatheGeometry使用"></a>LatheGeometry使用</h2><p><img src="./01.png" alt="旋转成型"></p>
<p>LatheGeometry可以利用已有的二维数据生成三维顶点数据</p>
<blockquote>
<p>LatheGeometry(points, segments, phiStart, phiLength)</p>
</blockquote>
<table>
<thead>
<tr>
<th>参数</th>
<th align="center">值</th>
</tr>
</thead>
<tbody><tr>
<td>points</td>
<td align="center">Vector2表示的坐标数据组成的数组</td>
</tr>
<tr>
<td>segments</td>
<td align="center">圆周方向细分数，默认12</td>
</tr>
<tr>
<td>phiStart</td>
<td align="center">开始角度,默认0</td>
</tr>
<tr>
<td>phiLength</td>
<td align="center">旋转角度，默认2π</td>
</tr>
</tbody></table>
<h2 id="以三个顶点旋转"><a href="#以三个顶点旋转" class="headerlink" title="以三个顶点旋转"></a>以三个顶点旋转</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 三个顶点构成的轮廓（理解为两条相连的直线段）</span></span><br><span class="line"><span class="comment">// Vector2对象作为元素构成的数组</span></span><br><span class="line"><span class="keyword">var</span> points = [</span><br><span class="line">    <span class="keyword">new</span> THREE.Vector2(<span class="number">50</span>,<span class="number">60</span>),</span><br><span class="line">    <span class="keyword">new</span> THREE.Vector2(<span class="number">25</span>,<span class="number">0</span>),</span><br><span class="line">    <span class="keyword">new</span> THREE.Vector2(<span class="number">50</span>,<span class="number">-60</span>)</span><br><span class="line">];</span><br><span class="line"><span class="comment">// 30:旋转方向细分数   0,2*Math.PI：旋转起始角度设置</span></span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.LatheGeometry(points,<span class="number">30</span>,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI);</span><br><span class="line"><span class="keyword">var</span> material=<span class="keyword">new</span> THREE.MeshPhongMaterial(&#123;</span><br><span class="line">    color:<span class="number">0x0000ff</span>,<span class="comment">//三角面颜色</span></span><br><span class="line">    side:THREE.DoubleSide<span class="comment">//两面可见</span></span><br><span class="line">&#125;);<span class="comment">//材质对象</span></span><br><span class="line">material.wireframe = <span class="literal">true</span>;<span class="comment">//线条模式渲染(查看细分数)</span></span><br><span class="line"><span class="keyword">var</span> mesh=<span class="keyword">new</span> THREE.Mesh(geometry,material);<span class="comment">//旋转网格模型对象</span></span><br><span class="line">scene.add(mesh);<span class="comment">//旋转网格模型添加到场景中</span></span><br></pre></td></tr></table></figure>

<p><img src="./02.png" alt="旋转成型"></p>
<h2 id="样条曲线旋转"><a href="#样条曲线旋转" class="headerlink" title="样条曲线旋转"></a>样条曲线旋转</h2><p>以三个顶点细分更多的顶点进行旋转</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> points = [</span><br><span class="line">    <span class="keyword">new</span> THREE.Vector2(<span class="number">50</span>,<span class="number">60</span>),</span><br><span class="line">    <span class="keyword">new</span> THREE.Vector2(<span class="number">25</span>,<span class="number">0</span>),</span><br><span class="line">    <span class="keyword">new</span> THREE.Vector2(<span class="number">50</span>,<span class="number">-60</span>)</span><br><span class="line">];</span><br><span class="line"><span class="comment">// SplineCurve：二维样条曲线</span></span><br><span class="line"><span class="keyword">var</span> splineCurve =  <span class="keyword">new</span> THREE.SplineCurve(points);</span><br><span class="line"><span class="comment">//分段数50，返回51个顶点</span></span><br><span class="line"><span class="keyword">var</span> splinePoints = splineCurve.getPoints(<span class="number">50</span>);</span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.LatheGeometry(splinePoints,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">var</span> material=<span class="keyword">new</span> THREE.MeshPhongMaterial(&#123;</span><br><span class="line">    color:<span class="number">0x0000ff</span>,<span class="comment">//三角面颜色</span></span><br><span class="line">    side:THREE.DoubleSide<span class="comment">//两面可见</span></span><br><span class="line">&#125;);<span class="comment">//材质对象</span></span><br><span class="line">material.wireframe = <span class="literal">true</span>;<span class="comment">//线条模式渲染(查看细分数)</span></span><br><span class="line"><span class="keyword">var</span> mesh=<span class="keyword">new</span> THREE.Mesh(geometry,material);<span class="comment">//旋转网格模型对象</span></span><br><span class="line">scene.add(mesh);<span class="comment">//旋转网格模型添加到场景中</span></span><br></pre></td></tr></table></figure>

<p><img src="./03.png" alt="样条曲线旋转"></p>
]]></content>
  </entry>
  <entry>
    <title>轮廓和轮廓填充</title>
    <url>/2020/07/14/02web/ThreeJS/07%E4%B8%89%E7%BB%B4%E5%87%A0%E4%BD%95%E4%BD%93%E5%BB%BA%E6%A8%A1/07%E8%BD%AE%E5%BB%93%E5%92%8C%E8%BD%AE%E5%BB%93%E5%A1%AB%E5%85%85/</url>
    <content><![CDATA[<h1 id="填充顶点构成的轮廓"><a href="#填充顶点构成的轮廓" class="headerlink" title="填充顶点构成的轮廓"></a>填充顶点构成的轮廓</h1><h2 id="自定义点"><a href="#自定义点" class="headerlink" title="自定义点"></a>自定义点</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> points = [</span><br><span class="line">  <span class="keyword">new</span> THREE.Vector2(<span class="number">-50</span>, <span class="number">-50</span>),</span><br><span class="line">  <span class="keyword">new</span> THREE.Vector2(<span class="number">-60</span>, <span class="number">0</span>),</span><br><span class="line">  <span class="keyword">new</span> THREE.Vector2(<span class="number">0</span>, <span class="number">50</span>),</span><br><span class="line">  <span class="keyword">new</span> THREE.Vector2(<span class="number">60</span>, <span class="number">0</span>),</span><br><span class="line">  <span class="keyword">new</span> THREE.Vector2(<span class="number">50</span>, <span class="number">-50</span>),</span><br><span class="line">  <span class="keyword">new</span> THREE.Vector2(<span class="number">-50</span>, <span class="number">-50</span>),</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 通过顶点定义轮廓</span></span><br><span class="line"><span class="keyword">var</span> shape = <span class="keyword">new</span> THREE.Shape(points);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.ShapeGeometry(shape, <span class="number">25</span>);</span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshPhongMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x0000ff</span>,</span><br><span class="line">  side: THREE.DoubleSide, <span class="comment">//两面可见</span></span><br><span class="line">  wireframe: <span class="literal">true</span>,</span><br><span class="line">&#125;); <span class="comment">//材质对象</span></span><br><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型对象</span></span><br><span class="line">scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span><br></pre></td></tr></table></figure>

<p><img src="./01.png" alt="自定义"></p>
<h2 id="圆形"><a href="#圆形" class="headerlink" title="圆形"></a>圆形</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shape = <span class="keyword">new</span> THREE.Shape();</span><br><span class="line">shape.absarc(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI);<span class="comment">//圆弧轮廓</span></span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.ShapeGeometry(shape, <span class="number">25</span>);</span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshPhongMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x0000ff</span>,</span><br><span class="line">  side: THREE.DoubleSide, <span class="comment">//两面可见</span></span><br><span class="line">  wireframe: <span class="literal">true</span>,</span><br><span class="line">&#125;); <span class="comment">//材质对象</span></span><br><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型对象</span></span><br><span class="line">scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span><br></pre></td></tr></table></figure>

<p><img src="./02.png" alt="圆形"></p>
<h2 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shape = <span class="keyword">new</span> THREE.Shape();</span><br><span class="line"><span class="comment">// 四条直线绘制一个矩形轮廓</span></span><br><span class="line">shape.moveTo(<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//起点</span></span><br><span class="line">shape.lineTo(<span class="number">0</span>,<span class="number">100</span>);<span class="comment">//第2点</span></span><br><span class="line">shape.lineTo(<span class="number">100</span>,<span class="number">100</span>);<span class="comment">//第3点</span></span><br><span class="line">shape.lineTo(<span class="number">100</span>,<span class="number">0</span>);<span class="comment">//第4点</span></span><br><span class="line">shape.lineTo(<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//第5点</span></span><br><span class="line"><span class="comment">// shape可以理解为一个需要填充轮廓</span></span><br><span class="line"><span class="comment">// 所谓填充：ShapeGeometry算法利用顶点计算出三角面face3数据填充轮廓</span></span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.ShapeGeometry(shape, <span class="number">25</span>);</span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshPhongMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x0000ff</span>,</span><br><span class="line">  side: THREE.DoubleSide, <span class="comment">//两面可见</span></span><br><span class="line">  wireframe: <span class="literal">true</span>,</span><br><span class="line">&#125;); <span class="comment">//材质对象</span></span><br><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型对象</span></span><br><span class="line">scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span><br></pre></td></tr></table></figure>

<p><img src="./03.png" alt="矩形"></p>
<h1 id="shape外轮廓和内轮廓"><a href="#shape外轮廓和内轮廓" class="headerlink" title="shape外轮廓和内轮廓"></a>shape外轮廓和内轮廓</h1><h2 id="填充轮廓"><a href="#填充轮廓" class="headerlink" title="填充轮廓"></a>填充轮廓</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 圆弧与直线连接</span></span><br><span class="line"><span class="keyword">var</span> shape = <span class="keyword">new</span> THREE.Shape(); <span class="comment">//Shape对象</span></span><br><span class="line"><span class="keyword">var</span> R = <span class="number">50</span>;</span><br><span class="line"><span class="comment">// 绘制一个半径为R、圆心坐标(0, 0)的半圆弧</span></span><br><span class="line">shape.absarc(<span class="number">0</span>, <span class="number">0</span>, R, <span class="number">0</span>, <span class="built_in">Math</span>.PI);</span><br><span class="line"><span class="comment">//从圆弧的一个端点(-R, 0)到(-R, -200)绘制一条直线</span></span><br><span class="line">shape.lineTo(-R, <span class="number">-200</span>);</span><br><span class="line"><span class="comment">// 绘制一个半径为R、圆心坐标(0, -200)的半圆弧</span></span><br><span class="line">shape.absarc(<span class="number">0</span>, <span class="number">-200</span>, R, <span class="built_in">Math</span>.PI, <span class="number">2</span> * <span class="built_in">Math</span>.PI);</span><br><span class="line"><span class="comment">//从圆弧的一个端点(R, -200)到(-R, -200)绘制一条直线</span></span><br><span class="line">shape.lineTo(R, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.ShapeGeometry(shape, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<p><img src="./04.png" alt="填充轮廓"></p>
<h2 id="原型内轮廓"><a href="#原型内轮廓" class="headerlink" title="原型内轮廓"></a>原型内轮廓</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个外轮廓圆弧嵌套三个内圆弧轮廓</span></span><br><span class="line"><span class="keyword">var</span> shape = <span class="keyword">new</span> THREE.Shape(); <span class="comment">//Shape对象</span></span><br><span class="line"><span class="comment">//外轮廓</span></span><br><span class="line">shape.arc(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI);</span><br><span class="line"><span class="comment">// 内轮廓1</span></span><br><span class="line"><span class="keyword">var</span> path1 = <span class="keyword">new</span> THREE.Path();</span><br><span class="line">path1.arc(<span class="number">0</span>, <span class="number">0</span>, <span class="number">40</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI);</span><br><span class="line"><span class="comment">// 内轮廓2</span></span><br><span class="line"><span class="keyword">var</span> path2 = <span class="keyword">new</span> THREE.Path();</span><br><span class="line">path2.arc(<span class="number">80</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI);</span><br><span class="line"><span class="comment">// 内轮廓3</span></span><br><span class="line"><span class="keyword">var</span> path3 = <span class="keyword">new</span> THREE.Path();</span><br><span class="line">path3.arc(<span class="number">-80</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI);</span><br><span class="line"><span class="comment">//三个内轮廓分别插入到holes属性中</span></span><br><span class="line">shape.holes.push(path1, path2, path3);</span><br></pre></td></tr></table></figure>

<p><img src="./05.png" alt="填充轮廓"></p>
<h2 id="矩形内轮廓"><a href="#矩形内轮廓" class="headerlink" title="矩形内轮廓"></a>矩形内轮廓</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 矩形嵌套矩形或圆弧</span></span><br><span class="line"><span class="keyword">var</span> shape=<span class="keyword">new</span> THREE.Shape();<span class="comment">//Shape对象</span></span><br><span class="line"><span class="comment">//外轮廓</span></span><br><span class="line">shape.moveTo(<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//起点</span></span><br><span class="line">shape.lineTo(<span class="number">0</span>,<span class="number">100</span>);<span class="comment">//第2点</span></span><br><span class="line">shape.lineTo(<span class="number">100</span>,<span class="number">100</span>);<span class="comment">//第3点</span></span><br><span class="line">shape.lineTo(<span class="number">100</span>,<span class="number">0</span>);<span class="comment">//第4点</span></span><br><span class="line">shape.lineTo(<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//第5点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内轮廓</span></span><br><span class="line"><span class="keyword">var</span> path=<span class="keyword">new</span> THREE.Path();<span class="comment">//path对象</span></span><br><span class="line"><span class="comment">// path.arc(50,50,40,0,2*Math.PI);//圆弧</span></span><br><span class="line">path.moveTo(<span class="number">20</span>,<span class="number">20</span>);<span class="comment">//起点</span></span><br><span class="line">path.lineTo(<span class="number">20</span>,<span class="number">80</span>);<span class="comment">//第2点</span></span><br><span class="line">path.lineTo(<span class="number">80</span>,<span class="number">80</span>);<span class="comment">//第3点</span></span><br><span class="line">path.lineTo(<span class="number">80</span>,<span class="number">20</span>);<span class="comment">//第4点</span></span><br><span class="line">path.lineTo(<span class="number">20</span>,<span class="number">20</span>);<span class="comment">//第5点</span></span><br><span class="line">shape.holes.push(path);<span class="comment">//设置内轮廓</span></span><br></pre></td></tr></table></figure>

<p><img src="./06.png" alt="填充轮廓"></p>
<h2 id="多轮廓填充"><a href="#多轮廓填充" class="headerlink" title="多轮廓填充"></a>多轮廓填充</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 轮廓对象1</span></span><br><span class="line"> <span class="keyword">var</span> shape=<span class="keyword">new</span> THREE.Shape();</span><br><span class="line"> shape.arc(<span class="number">-50</span>,<span class="number">0</span>,<span class="number">30</span>,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI);</span><br><span class="line"> <span class="comment">// 轮廓对象2</span></span><br><span class="line"> <span class="keyword">var</span> shape2=<span class="keyword">new</span> THREE.Shape();</span><br><span class="line"> shape2.arc(<span class="number">50</span>,<span class="number">0</span>,<span class="number">30</span>,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI);</span><br><span class="line"> <span class="comment">// 轮廓对象3</span></span><br><span class="line"> <span class="keyword">var</span> shape3=<span class="keyword">new</span> THREE.Shape();</span><br><span class="line"> shape3.arc(<span class="number">0</span>,<span class="number">50</span>,<span class="number">30</span>,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI);</span><br><span class="line"><span class="comment">// 多个shape作为元素组成数组,每一个shpae可以理解为一个要填充的轮廓</span></span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.ShapeGeometry([shape,shape2,shape3], <span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<p><img src="./07.png" alt="填充轮廓"></p>
]]></content>
  </entry>
  <entry>
    <title>拉伸扫描</title>
    <url>/2020/07/14/02web/ThreeJS/07%E4%B8%89%E7%BB%B4%E5%87%A0%E4%BD%95%E4%BD%93%E5%BB%BA%E6%A8%A1/08%E6%8B%89%E4%BC%B8%E6%89%AB%E6%8F%8F/</url>
    <content><![CDATA[<h1 id="拉伸"><a href="#拉伸" class="headerlink" title="拉伸"></a>拉伸</h1><h2 id="ExtrudeGeometry使用"><a href="#ExtrudeGeometry使用" class="headerlink" title="ExtrudeGeometry使用"></a>ExtrudeGeometry使用</h2><p><img src="./01.png" alt="拉伸扫描"></p>
<p>ExtrudeGeometry()可以利用2D轮廓生成3D模型</p>
<table>
<thead>
<tr>
<th>参数</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td>amount</td>
<td align="center">拉伸长度，默认100</td>
</tr>
<tr>
<td>bevelEnabled</td>
<td align="center">是否使用倒角</td>
</tr>
<tr>
<td>bevelSegments</td>
<td align="center">倒角细分数，默认3</td>
</tr>
<tr>
<td>bevelThickness</td>
<td align="center">倒角尺寸(经向)</td>
</tr>
<tr>
<td>curveSegments</td>
<td align="center">拉伸轮廓细分数</td>
</tr>
<tr>
<td>steps</td>
<td align="center">拉伸方向细分数</td>
</tr>
<tr>
<td>extrudePath</td>
<td align="center">扫描路径THREE.CurvePath，默认Z轴方向</td>
</tr>
<tr>
<td>material</td>
<td align="center">前后面材质索引号</td>
</tr>
<tr>
<td>extrudeMaterial</td>
<td align="center">拉伸面、倒角面材质索引号</td>
</tr>
<tr>
<td>bevelSize</td>
<td align="center">倒角尺寸(拉伸方向)</td>
</tr>
</tbody></table>
<h2 id="通过顶点定义轮廓拉伸"><a href="#通过顶点定义轮廓拉伸" class="headerlink" title="通过顶点定义轮廓拉伸"></a>通过顶点定义轮廓拉伸</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> points = [</span><br><span class="line">  <span class="keyword">new</span> THREE.Vector2(<span class="number">-50</span>, <span class="number">-50</span>),</span><br><span class="line">  <span class="keyword">new</span> THREE.Vector2(<span class="number">-60</span>, <span class="number">0</span>),</span><br><span class="line">  <span class="keyword">new</span> THREE.Vector2(<span class="number">0</span>, <span class="number">50</span>),</span><br><span class="line">  <span class="keyword">new</span> THREE.Vector2(<span class="number">60</span>, <span class="number">0</span>),</span><br><span class="line">  <span class="keyword">new</span> THREE.Vector2(<span class="number">50</span>, <span class="number">-50</span>),</span><br><span class="line">  <span class="keyword">new</span> THREE.Vector2(<span class="number">-50</span>, <span class="number">-50</span>),</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 通过顶点定义轮廓</span></span><br><span class="line"><span class="keyword">var</span> shape = <span class="keyword">new</span> THREE.Shape(points);</span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.ExtrudeGeometry( <span class="comment">//拉伸造型</span></span><br><span class="line">  shape, <span class="comment">//二维轮廓</span></span><br><span class="line">  <span class="comment">//拉伸参数</span></span><br><span class="line">  &#123;</span><br><span class="line">    amount: <span class="number">120</span>, <span class="comment">//拉伸长度</span></span><br><span class="line">    <span class="comment">// curveSegments: 35, //拉伸轮廓细分数</span></span><br><span class="line">    <span class="comment">// steps: 12, //拉伸方向的细分数</span></span><br><span class="line">    <span class="comment">// bevelEnabled: false, //无倒角</span></span><br><span class="line">    <span class="comment">// bevelSegments:1,//倒直角：设置为1  倒圆角：越大越光滑</span></span><br><span class="line">    <span class="comment">// bevelThickness: 30,//拉伸方向尺寸</span></span><br><span class="line">    <span class="comment">// bevelSize: 4,//径向尺寸</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">//材质对象</span></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshPhongMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x0000ff</span>,</span><br><span class="line">  side: THREE.DoubleSide, <span class="comment">//两面可见</span></span><br><span class="line">  <span class="comment">// wireframe: true,</span></span><br><span class="line">&#125;); </span><br><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型对象</span></span><br><span class="line">scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span><br></pre></td></tr></table></figure>

<p><img src="./02.png" alt="通过顶点定义轮廓拉伸"></p>
<h2 id="通过线条绘制方法定义轮廓"><a href="#通过线条绘制方法定义轮廓" class="headerlink" title="通过线条绘制方法定义轮廓"></a>通过线条绘制方法定义轮廓</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过Path类的线条绘制方法方法定义轮廓</span></span><br><span class="line"><span class="keyword">var</span> shape = <span class="keyword">new</span> THREE.Shape();</span><br><span class="line"><span class="comment">// shape.absarc(50,50,40,0,2*Math.PI);//圆弧</span></span><br><span class="line">shape.moveTo(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">//起点</span></span><br><span class="line">shape.lineTo(<span class="number">0</span>, <span class="number">100</span>); <span class="comment">//第2点</span></span><br><span class="line">shape.lineTo(<span class="number">100</span>, <span class="number">100</span>); <span class="comment">//第3点</span></span><br><span class="line">shape.lineTo(<span class="number">100</span>, <span class="number">0</span>); <span class="comment">//第4点</span></span><br><span class="line">shape.lineTo(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">//第5点</span></span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.ExtrudeGeometry( <span class="comment">//拉伸造型</span></span><br><span class="line">  shape, <span class="comment">//二维轮廓</span></span><br><span class="line">  <span class="comment">//拉伸参数</span></span><br><span class="line">  &#123;</span><br><span class="line">    amount: <span class="number">120</span>, <span class="comment">//拉伸长度</span></span><br><span class="line">    <span class="comment">// curveSegments: 35, //拉伸轮廓细分数</span></span><br><span class="line">    <span class="comment">// steps: 12, //拉伸方向的细分数</span></span><br><span class="line">    <span class="comment">// bevelEnabled: false, //无倒角</span></span><br><span class="line">    <span class="comment">// bevelSegments:1,//倒直角：设置为1  倒圆角：越大越光滑</span></span><br><span class="line">    <span class="comment">// bevelThickness: 30,//拉伸方向尺寸</span></span><br><span class="line">    <span class="comment">// bevelSize: 4,//径向尺寸</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"> <span class="comment">//材质对象</span></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshPhongMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x0000ff</span>,</span><br><span class="line">  side: THREE.DoubleSide, <span class="comment">//两面可见</span></span><br><span class="line">  <span class="comment">// wireframe: true,</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型对象</span></span><br><span class="line">scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span><br></pre></td></tr></table></figure>

<p><img src="./03.png" alt="通过线条绘制方法定义轮廓"></p>
<h2 id="拉伸填充模型"><a href="#拉伸填充模型" class="headerlink" title="拉伸填充模型"></a>拉伸填充模型</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 圆弧与直线连接</span></span><br><span class="line"> <span class="keyword">var</span> shape = <span class="keyword">new</span> THREE.Shape(); <span class="comment">//Shape对象</span></span><br><span class="line"> <span class="keyword">var</span> R = <span class="number">50</span>;</span><br><span class="line"> <span class="comment">// 绘制一个半径为R、圆心坐标(0, 0)的半圆弧</span></span><br><span class="line"> shape.absarc(<span class="number">0</span>, <span class="number">0</span>, R, <span class="number">0</span>, <span class="built_in">Math</span>.PI);</span><br><span class="line"> <span class="comment">//从圆弧的一个端点(-R, 0)到(-R, -200)绘制一条直线</span></span><br><span class="line"> shape.lineTo(-R, <span class="number">-200</span>);</span><br><span class="line"> <span class="comment">// 绘制一个半径为R、圆心坐标(0, -200)的半圆弧</span></span><br><span class="line"> shape.absarc(<span class="number">0</span>, <span class="number">-200</span>, R, <span class="built_in">Math</span>.PI, <span class="number">2</span> * <span class="built_in">Math</span>.PI);</span><br><span class="line"> <span class="comment">//从圆弧的一个端点(R, -200)到(-R, -200)绘制一条直线</span></span><br><span class="line"> shape.lineTo(R, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.ExtrudeGeometry( <span class="comment">//拉伸造型</span></span><br><span class="line">  shape, <span class="comment">//二维轮廓</span></span><br><span class="line">  <span class="comment">//拉伸参数</span></span><br><span class="line">  &#123;</span><br><span class="line">    amount: <span class="number">10</span>, <span class="comment">//拉伸长度</span></span><br><span class="line">    curveSegments: <span class="number">40</span>, <span class="comment">//圆周方向细分数</span></span><br><span class="line">    bevelEnabled: <span class="literal">false</span> <span class="comment">//无倒角</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshPhongMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x0000ff</span>,</span><br><span class="line">  side: THREE.DoubleSide <span class="comment">//两面可见</span></span><br><span class="line">&#125;); <span class="comment">//材质对象</span></span><br><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型对象</span></span><br><span class="line">scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span><br></pre></td></tr></table></figure>

<p><img src="./05.png" alt="拉伸填充模型"></p>
<h2 id="拉伸多个"><a href="#拉伸多个" class="headerlink" title="拉伸多个"></a>拉伸多个</h2><p>把三个轮廓模型放到数组中进行拉伸</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 轮廓对象1</span></span><br><span class="line"><span class="keyword">var</span> shape=<span class="keyword">new</span> THREE.Shape();</span><br><span class="line">shape.arc(<span class="number">-50</span>,<span class="number">0</span>,<span class="number">30</span>,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI);</span><br><span class="line"><span class="comment">// 轮廓对象2</span></span><br><span class="line"><span class="keyword">var</span> shape2=<span class="keyword">new</span> THREE.Shape();</span><br><span class="line">shape2.arc(<span class="number">50</span>,<span class="number">0</span>,<span class="number">30</span>,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI);</span><br><span class="line"><span class="comment">// 轮廓对象3</span></span><br><span class="line"><span class="keyword">var</span> shape3=<span class="keyword">new</span> THREE.Shape();</span><br><span class="line">shape3.arc(<span class="number">0</span>,<span class="number">50</span>,<span class="number">30</span>,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI);</span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.ExtrudeGeometry(<span class="comment">//拉伸造型</span></span><br><span class="line"> [shape,shape2,shape3],<span class="comment">//二维轮廓</span></span><br><span class="line"> <span class="comment">//拉伸参数</span></span><br><span class="line"> &#123;</span><br><span class="line">     amount:<span class="number">10</span>,<span class="comment">//拉伸长度</span></span><br><span class="line">     curveSegments: <span class="number">35</span>, <span class="comment">//拉伸轮廓细分数</span></span><br><span class="line">     bevelEnabled:<span class="literal">false</span><span class="comment">//无倒角</span></span><br><span class="line"> &#125;</span><br><span class="line"> );</span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshPhongMaterial(&#123;</span><br><span class="line">color: <span class="number">0x0000ff</span>,</span><br><span class="line">side: THREE.DoubleSide <span class="comment">//两面可见</span></span><br><span class="line">&#125;); <span class="comment">//材质对象</span></span><br><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型对象</span></span><br><span class="line">scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span><br></pre></td></tr></table></figure>

<p><img src="./06.png" alt="拉伸多个"></p>
<h1 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h1><ul>
<li>拉伸和扫描一样都是三维造型建模方法</li>
<li>对于扫描而言不需要定义amount属性设置拉伸距离，设置扫描路径即可</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shape = <span class="keyword">new</span> THREE.Shape();</span><br><span class="line"> <span class="comment">/**四条直线绘制一个矩形轮廓*/</span></span><br><span class="line"> shape.moveTo(<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//起点</span></span><br><span class="line"> shape.lineTo(<span class="number">0</span>,<span class="number">10</span>);<span class="comment">//第2点</span></span><br><span class="line"> shape.lineTo(<span class="number">10</span>,<span class="number">10</span>);<span class="comment">//第3点</span></span><br><span class="line"> shape.lineTo(<span class="number">10</span>,<span class="number">0</span>);<span class="comment">//第4点</span></span><br><span class="line"> shape.lineTo(<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//第5点</span></span><br><span class="line"> <span class="comment">/**创建轮廓的扫描轨迹(3D样条曲线)*/</span></span><br><span class="line"> <span class="keyword">var</span> curve = <span class="keyword">new</span> THREE.SplineCurve3([</span><br><span class="line">     <span class="keyword">new</span> THREE.Vector3( <span class="number">-10</span>, <span class="number">-50</span>, <span class="number">-50</span> ),</span><br><span class="line">     <span class="keyword">new</span> THREE.Vector3( <span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span> ),</span><br><span class="line">     <span class="keyword">new</span> THREE.Vector3( <span class="number">8</span>, <span class="number">50</span>, <span class="number">50</span> ),</span><br><span class="line">     <span class="keyword">new</span> THREE.Vector3( <span class="number">-5</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line"> ]);</span><br><span class="line"> <span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.ExtrudeGeometry(<span class="comment">//拉伸造型</span></span><br><span class="line">     shape,<span class="comment">//二维轮廓</span></span><br><span class="line">     <span class="comment">//拉伸参数</span></span><br><span class="line">     &#123;</span><br><span class="line">         bevelEnabled:<span class="literal">false</span>,<span class="comment">//无倒角</span></span><br><span class="line">         extrudePath:curve,<span class="comment">//选择扫描轨迹</span></span><br><span class="line">         steps:<span class="number">50</span><span class="comment">//沿着路径细分数</span></span><br><span class="line">     &#125;</span><br><span class="line"> );</span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshPhongMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x0000ff</span>,</span><br><span class="line">  side: THREE.DoubleSide <span class="comment">//两面可见</span></span><br><span class="line">&#125;); <span class="comment">//材质对象</span></span><br><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型对象</span></span><br><span class="line">scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span><br></pre></td></tr></table></figure>

<p><img src="./04.png" alt="通过线条绘制方法定义轮廓"></p>
]]></content>
  </entry>
  <entry>
    <title>创建纹理贴图</title>
    <url>/2020/07/15/02web/ThreeJS/08%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE/01%E5%88%9B%E5%BB%BA%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="创建纹理"><a href="#创建纹理" class="headerlink" title="创建纹理"></a>创建纹理</h1><h2 id="TextureLoader加载图片"><a href="#TextureLoader加载图片" class="headerlink" title="TextureLoader加载图片"></a>TextureLoader加载图片</h2><ul>
<li>通过纹理贴图加载器TextureLoader的load()方法加载一张图片可以返回一个纹理对象Texture</li>
<li>纹理对象Texture可以作为模型材质颜色贴图.map属性的值</li>
<li>材质的颜色贴图属性.map设置后，模型会从纹理贴图上采集像素值</li>
<li>这时候一般来说不需要在设置材质颜色.color</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.SphereGeometry(<span class="number">60</span>, <span class="number">25</span>, <span class="number">25</span>); <span class="comment">//球体</span></span><br><span class="line"><span class="comment">// TextureLoader创建一个纹理加载器对象，可以加载图片作为几何体纹理</span></span><br><span class="line"><span class="keyword">var</span> textureLoader = <span class="keyword">new</span> THREE.TextureLoader();</span><br><span class="line"><span class="comment">// 执行load方法，加载纹理贴图成功后，返回一个纹理对象Texture</span></span><br><span class="line">textureLoader.load(<span class="string">'Earth.png'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">texture</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">    <span class="comment">// color: 0x0000ff,</span></span><br><span class="line">    <span class="comment">// 设置纹理贴图：Texture对象作为材质map属性的属性值</span></span><br><span class="line">    map: texture,</span><br><span class="line">  &#125;); <span class="comment">//材质对象Material</span></span><br><span class="line">  <span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">  scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span><br><span class="line">  <span class="comment">//纹理贴图加载成功后，调用渲染函数执行渲染操作</span></span><br><span class="line">  render();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="./01.png" alt="创建纹理贴图"></p>
<p>如果不在回调方法中渲染，则需要在渲染方法中加入不断渲染，因为加载图片是异步操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 渲染函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  renderer.render(scene, camera); <span class="comment">//执行渲染操作</span></span><br><span class="line">  requestAnimationFrame(render);<span class="comment">//请求再次执行渲染函数render，渲染下一帧</span></span><br><span class="line">&#125;</span><br><span class="line">render();</span><br></pre></td></tr></table></figure>

<h2 id="ImageLoader加载图片"><a href="#ImageLoader加载图片" class="headerlink" title="ImageLoader加载图片"></a>ImageLoader加载图片</h2><p>返回的是一个图片对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.PlaneGeometry(<span class="number">204</span>, <span class="number">102</span>); <span class="comment">//矩形平面</span></span><br><span class="line"><span class="comment">// 图片加载器</span></span><br><span class="line"><span class="keyword">var</span> ImageLoader = <span class="keyword">new</span> THREE.ImageLoader();</span><br><span class="line"><span class="comment">// load方法回调函数，按照路径加载图片，返回一个html的元素img对象</span></span><br><span class="line">ImageLoader.load(<span class="string">'Earth.png'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">img</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// image对象作为参数，创建一个纹理对象Texture</span></span><br><span class="line">  <span class="keyword">var</span> texture = <span class="keyword">new</span> THREE.Texture(img);</span><br><span class="line">  <span class="comment">// 下次使用纹理时触发更新</span></span><br><span class="line">  texture.needsUpdate = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">    map: texture, <span class="comment">//设置纹理贴图</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">  scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>UV映射原理</title>
    <url>/2020/07/15/02web/ThreeJS/08%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE/02UV%E6%98%A0%E5%B0%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="纹理UV坐标"><a href="#纹理UV坐标" class="headerlink" title="纹理UV坐标"></a>纹理UV坐标</h2><p>选择一张图片，比如以图片左下角为坐标原点，右上角为坐标(1.0,1.0)，图片上所有位置纵横坐标都介于0.0~1.0之间。</p>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><ul>
<li>纹理UV坐标和顶点位置坐标是一一对应关系</li>
<li>这也就是为什么一张图片可以映射到一个模型的表面</li>
<li>只要把图片的每个纹理坐标和模型的顶点位置建立一对一的关系，就可以实现图像到模型的映射</li>
</ul>
<p><img src="./01.png" alt="映射"><br><img src="./02.png" alt="映射2"></p>
<h1 id="修改纹理坐标"><a href="#修改纹理坐标" class="headerlink" title="修改纹理坐标"></a>修改纹理坐标</h1><h2 id="重置矩形纹理坐标"><a href="#重置矩形纹理坐标" class="headerlink" title="重置矩形纹理坐标"></a>重置矩形纹理坐标</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.PlaneGeometry(<span class="number">204</span>, <span class="number">102</span>); <span class="comment">//矩形平面</span></span><br><span class="line"><span class="comment">// 重置矩形纹理坐标</span></span><br><span class="line">geometry.faceVertexUvs[<span class="number">0</span>].forEach(<span class="function"><span class="params">elem</span> =&gt;</span> &#123;</span><br><span class="line">  elem.forEach(<span class="function"><span class="params">Vector2</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 所有的UV坐标全部设置为一个值</span></span><br><span class="line">    Vector2.set(<span class="number">0.4</span>,<span class="number">0.4</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// TextureLoader创建一个纹理加载器对象，可以加载图片作为几何体纹理</span></span><br><span class="line"><span class="keyword">var</span> textureLoader = <span class="keyword">new</span> THREE.TextureLoader();</span><br><span class="line"><span class="comment">// 执行load方法，加载纹理贴图成功后，返回一个纹理对象Texture</span></span><br><span class="line">textureLoader.load(<span class="string">'Earth.png'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">texture</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">    map: texture,<span class="comment">// 设置纹理贴图</span></span><br><span class="line">    <span class="comment">// wireframe:true,</span></span><br><span class="line">  &#125;); <span class="comment">//材质对象Material</span></span><br><span class="line">  <span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">  scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>整个矩形的所有点都映射图片(0.4，0.4)的地方</p>
<p><img src="./03.png" alt="重置矩形纹理坐标"></p>
<h2 id="局部贴图"><a href="#局部贴图" class="headerlink" title="局部贴图"></a>局部贴图</h2><ul>
<li>把矩形进行细分</li>
<li>把图片标出坐标</li>
<li>通过坐标模拟图片部分</li>
<li>把细分块设置图片的这部分</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 矩形平面 设置细分数4,4</span></span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.PlaneGeometry(<span class="number">204</span>, <span class="number">102</span>, <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">var</span> t0 = <span class="keyword">new</span> THREE.Vector2(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">//图片左下角</span></span><br><span class="line"><span class="keyword">var</span> t1 = <span class="keyword">new</span> THREE.Vector2(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">//图片右下角</span></span><br><span class="line"><span class="keyword">var</span> t2 = <span class="keyword">new</span> THREE.Vector2(<span class="number">1</span>, <span class="number">0</span>); <span class="comment">//图片右上角</span></span><br><span class="line"><span class="keyword">var</span> t3 = <span class="keyword">new</span> THREE.Vector2(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">//图片左上角</span></span><br><span class="line"><span class="keyword">var</span> uv1 = [t0, t1, t3]; <span class="comment">//选中图片一个三角区域像素——用于映射到一个三角面</span></span><br><span class="line"><span class="keyword">var</span> uv2 = [t1, t2, t3]; <span class="comment">//选中图片一个三角区域像素——用于映射到一个三角面</span></span><br><span class="line"><span class="comment">// 设置第五、第六个三角面对应的纹理坐标</span></span><br><span class="line">geometry.faceVertexUvs[<span class="number">0</span>][<span class="number">4</span>] = uv1</span><br><span class="line">geometry.faceVertexUvs[<span class="number">0</span>][<span class="number">5</span>] = uv2</span><br><span class="line"></span><br><span class="line"><span class="comment">// TextureLoader创建一个纹理加载器对象，可以加载图片作为几何体纹理</span></span><br><span class="line"><span class="keyword">var</span> textureLoader = <span class="keyword">new</span> THREE.TextureLoader();</span><br><span class="line"><span class="comment">// 执行load方法，加载纹理贴图成功后，返回一个纹理对象Texture</span></span><br><span class="line">textureLoader.load(<span class="string">'Earth.png'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">texture</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">    <span class="comment">// color:0x000000,</span></span><br><span class="line">    map: texture,<span class="comment">// 设置纹理贴图</span></span><br><span class="line">    <span class="comment">// wireframe:true,</span></span><br><span class="line">  &#125;); <span class="comment">//材质对象Material</span></span><br><span class="line">  <span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">  scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="./04.png" alt="局部贴图"></p>
<h2 id="Geometry自定义顶点UV坐标"><a href="#Geometry自定义顶点UV坐标" class="headerlink" title="Geometry自定义顶点UV坐标"></a>Geometry自定义顶点UV坐标</h2><p>代码通过几何体Geometry自定义了一个由两个三角形组成的矩形几何体，并且通过几何体的.faceVertexUvs[0]属性设置了每个顶点对应的第一组UV坐标。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.Geometry(); <span class="comment">//创建一个空几何体对象</span></span><br><span class="line"><span class="comment">/**顶点坐标(纹理映射位置)*/</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> THREE.Vector3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>); <span class="comment">//顶点1坐标</span></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> THREE.Vector3(<span class="number">160</span>,<span class="number">0</span>,<span class="number">0</span>); <span class="comment">//顶点2坐标</span></span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> THREE.Vector3(<span class="number">160</span>,<span class="number">80</span>,<span class="number">0</span>); <span class="comment">//顶点3坐标</span></span><br><span class="line"><span class="keyword">var</span> p4 = <span class="keyword">new</span> THREE.Vector3(<span class="number">0</span>,<span class="number">80</span>,<span class="number">0</span>); <span class="comment">//顶点4坐标</span></span><br><span class="line">geometry.vertices.push(p1,p2,p3,p4); <span class="comment">//顶点坐标添加到geometry对象</span></span><br><span class="line"><span class="comment">/** 三角面1、三角面2*/</span></span><br><span class="line"><span class="keyword">var</span> normal = <span class="keyword">new</span> THREE.Vector3( <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> ); <span class="comment">//三角面法向量</span></span><br><span class="line"><span class="keyword">var</span> face0 = <span class="keyword">new</span> THREE.Face3( <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, normal); <span class="comment">//三角面1</span></span><br><span class="line"><span class="keyword">var</span> face1 = <span class="keyword">new</span> THREE.Face3( <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, normal); <span class="comment">//三角面2</span></span><br><span class="line">geometry.faces.push( face0,face1 ); <span class="comment">//三角面1、2添加到几何体</span></span><br><span class="line"><span class="comment">/**纹理坐标*/</span></span><br><span class="line"><span class="keyword">var</span> t0 = <span class="keyword">new</span> THREE.Vector2(<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//图片左下角</span></span><br><span class="line"><span class="keyword">var</span> t1 = <span class="keyword">new</span> THREE.Vector2(<span class="number">1</span>,<span class="number">0</span>);<span class="comment">//图片右下角</span></span><br><span class="line"><span class="keyword">var</span> t2 = <span class="keyword">new</span> THREE.Vector2(<span class="number">1</span>,<span class="number">1</span>);<span class="comment">//图片右上角</span></span><br><span class="line"><span class="keyword">var</span> t3 = <span class="keyword">new</span> THREE.Vector2(<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//图片左上角</span></span><br><span class="line">uv1 = [t0,t1,t2];<span class="comment">//选中图片一个三角区域像素——映射到三角面1</span></span><br><span class="line">uv2 = [t0,t2,t3];<span class="comment">//选中图片一个三角区域像素——映射到三角面2</span></span><br><span class="line">geometry.faceVertexUvs[<span class="number">0</span>].push(uv1,uv2);<span class="comment">//纹理坐标传递给纹理三角面属性</span></span><br></pre></td></tr></table></figure>

<h2 id="BufferGeometry自定义顶点UV坐标"><a href="#BufferGeometry自定义顶点UV坐标" class="headerlink" title="BufferGeometry自定义顶点UV坐标"></a>BufferGeometry自定义顶点UV坐标</h2><p>通过几何体BufferGeometry自定义了一个由两个三角形组成的矩形几何体，并且通过几何体的.attributes.uv属性设置了每个顶点对应的第一组UV坐标</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.BufferGeometry(); <span class="comment">//声明一个空几何体对象</span></span><br><span class="line"><span class="comment">//类型数组创建顶点位置position数据</span></span><br><span class="line"><span class="keyword">var</span> vertices = <span class="keyword">new</span> <span class="built_in">Float32Array</span>([</span><br><span class="line">  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点1坐标</span></span><br><span class="line">  <span class="number">80</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点2坐标</span></span><br><span class="line">  <span class="number">80</span>, <span class="number">80</span>, <span class="number">0</span>, <span class="comment">//顶点3坐标</span></span><br><span class="line">  <span class="number">0</span>, <span class="number">80</span>, <span class="number">0</span>, <span class="comment">//顶点4坐标</span></span><br><span class="line">]);</span><br><span class="line"><span class="comment">// 创建属性缓冲区对象</span></span><br><span class="line"><span class="keyword">var</span> attribue = <span class="keyword">new</span> THREE.BufferAttribute(vertices, <span class="number">3</span>); <span class="comment">//3个为一组</span></span><br><span class="line"><span class="comment">// 设置几何体attributes属性的位置position属性</span></span><br><span class="line">geometry.attributes.position = attribue</span><br><span class="line"><span class="keyword">var</span> normals = <span class="keyword">new</span> <span class="built_in">Float32Array</span>([</span><br><span class="line">  <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="comment">//顶点1法向量</span></span><br><span class="line">  <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="comment">//顶点2法向量</span></span><br><span class="line">  <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="comment">//顶点3法向量</span></span><br><span class="line">  <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="comment">//顶点4法向量</span></span><br><span class="line">]);</span><br><span class="line"><span class="comment">// 设置几何体attributes属性的位置normal属性</span></span><br><span class="line">geometry.attributes.normal = <span class="keyword">new</span> THREE.BufferAttribute(normals, <span class="number">3</span>); <span class="comment">//3个为一组,表示一个顶点的xyz坐标</span></span><br><span class="line"><span class="comment">// Uint16Array类型数组创建顶点索引数据</span></span><br><span class="line"><span class="keyword">var</span> indexes = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>([</span><br><span class="line">  <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">])</span><br><span class="line"><span class="comment">// 索引数据赋值给几何体的index属性</span></span><br><span class="line">geometry.index = <span class="keyword">new</span> THREE.BufferAttribute(indexes, <span class="number">1</span>); <span class="comment">//1个为一组</span></span><br><span class="line"> <span class="comment">/**纹理坐标*/</span></span><br><span class="line"> <span class="keyword">var</span> uvs = <span class="keyword">new</span> <span class="built_in">Float32Array</span>([</span><br><span class="line">   <span class="number">0</span>,<span class="number">0</span>, <span class="comment">//图片左下角</span></span><br><span class="line">   <span class="number">1</span>,<span class="number">0</span>, <span class="comment">//图片右下角</span></span><br><span class="line">   <span class="number">1</span>,<span class="number">1</span>, <span class="comment">//图片右上角</span></span><br><span class="line">   <span class="number">0</span>,<span class="number">1</span>, <span class="comment">//图片左上角</span></span><br><span class="line"> ]);</span><br><span class="line"> <span class="comment">// 设置几何体attributes属性的位置normal属性</span></span><br><span class="line"> geometry.attributes.uv = <span class="keyword">new</span> THREE.BufferAttribute(uvs, <span class="number">2</span>); <span class="comment">//2个为一组,表示一个顶点的纹理坐标</span></span><br></pre></td></tr></table></figure>

<h2 id="加载一个包含UV坐标的模型文件"><a href="#加载一个包含UV坐标的模型文件" class="headerlink" title="加载一个包含UV坐标的模型文件"></a>加载一个包含UV坐标的模型文件</h2><p>通过Threejs加载一个包含UV坐标的外部三维模型文件，加载成功后，给模型设置一张贴图.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个加载threejs格式JSON文件的加载器</span></span><br><span class="line"><span class="keyword">var</span> loader = <span class="keyword">new</span> THREE.ObjectLoader();</span><br><span class="line"><span class="comment">// TextureLoader创建一个纹理加载器对象，可以加载图片作为几何体纹理</span></span><br><span class="line"><span class="keyword">var</span> textureLoader = <span class="keyword">new</span> THREE.TextureLoader();</span><br><span class="line">loader.load(<span class="string">'model.json'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(obj);</span><br><span class="line">  scene.add(obj);<span class="comment">//加载返回的对象插入场景中</span></span><br><span class="line">  <span class="comment">// 执行load方法，加载纹理贴图成功后，返回一个纹理对象Texture</span></span><br><span class="line">  textureLoader.load(<span class="string">'Earth.png'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">texture</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 设置球体网格模型材质的map属性</span></span><br><span class="line">    obj.children[<span class="number">0</span>].material.map = texture;</span><br><span class="line">    <span class="comment">// 告诉threejs渲染器系统，材质对象的map属性已更新</span></span><br><span class="line">    obj.children[<span class="number">0</span>].material.needsUpdate=<span class="literal">true</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>纹理对象Texture阵列,偏移,旋转</title>
    <url>/2020/07/21/02web/ThreeJS/08%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE/04%E7%BA%B9%E7%90%86%E5%AF%B9%E8%B1%A1Texture%E9%98%B5%E5%88%97,%E5%81%8F%E7%A7%BB,%E6%97%8B%E8%BD%AC/</url>
    <content><![CDATA[<p>当图像贴图出现重复时，为了优化性能可以使用一张小的图片通过列阵以及便宜实现</p>
<h1 id="阵列"><a href="#阵列" class="headerlink" title="阵列"></a>阵列</h1><h2 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.PlaneGeometry(<span class="number">200</span>, <span class="number">100</span>); <span class="comment">//矩形平面</span></span><br><span class="line"><span class="comment">// TextureLoader创建一个纹理加载器对象，可以加载图片作为几何体纹理</span></span><br><span class="line"><span class="keyword">var</span> textureLoader = <span class="keyword">new</span> THREE.TextureLoader();</span><br><span class="line"><span class="keyword">var</span> texture = textureLoader.load(<span class="string">'太阳能板.png'</span>);</span><br><span class="line"><span class="comment">// 设置阵列模式   默认ClampToEdgeWrapping  RepeatWrapping：阵列  镜像阵列：MirroredRepeatWrapping</span></span><br><span class="line">texture.wrapS = THREE.RepeatWrapping;</span><br><span class="line">texture.wrapT = THREE.RepeatWrapping;</span><br><span class="line"><span class="comment">// uv两个方向纹理重复数量</span></span><br><span class="line">texture.repeat.set(<span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// 偏移效果</span></span><br><span class="line">texture.offset = <span class="keyword">new</span> THREE.Vector2(<span class="number">0.5</span>, <span class="number">0.5</span>)</span><br><span class="line"><span class="comment">//材质对象Material</span></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">  <span class="comment">// 设置纹理贴图：Texture对象作为材质map属性的属性值</span></span><br><span class="line">  map: texture,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//网格模型对象Mesh</span></span><br><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); </span><br><span class="line"><span class="comment">//网格模型添加到场景中</span></span><br><span class="line">scene.add(mesh);</span><br></pre></td></tr></table></figure>

<p><img src="./02.png" alt="阵列"></p>
<h2 id="偏移"><a href="#偏移" class="headerlink" title="偏移"></a>偏移</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> textureLoader = <span class="keyword">new</span> THREE.TextureLoader();</span><br><span class="line"><span class="keyword">var</span> texture = textureLoader.load(<span class="string">'太阳能板2.png'</span>);<span class="comment">// 加载纹理贴图</span></span><br><span class="line"><span class="comment">// 不设置重复  偏移范围-1~1</span></span><br><span class="line">texture.offset = <span class="keyword">new</span> THREE.Vector2(<span class="number">0.3</span>, <span class="number">0.1</span>)</span><br></pre></td></tr></table></figure>

<p><img src="./01.png" alt="偏移"></p>
<h2 id="纹理旋转"><a href="#纹理旋转" class="headerlink" title="纹理旋转"></a>纹理旋转</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> texture = textureLoader.load(<span class="string">'太阳能板.png'</span>); <span class="comment">// 加载纹理贴图</span></span><br><span class="line"><span class="comment">// 设置纹理旋转角度</span></span><br><span class="line">texture.rotation = <span class="built_in">Math</span>.PI/<span class="number">4</span>;</span><br><span class="line"><span class="comment">// 设置纹理的旋转中心，默认(0,0)</span></span><br><span class="line">texture.center.set(<span class="number">0.5</span>,<span class="number">0.5</span>);</span><br></pre></td></tr></table></figure>

<p><img src="./03.png" alt="纹理旋转"></p>
<h1 id="纹理动画"><a href="#纹理动画" class="headerlink" title="纹理动画"></a>纹理动画</h1><p>纹理动画比较简单，必须要在渲染函数中render()一直执行texture.offset.x -= 0.06动态改变纹理对象Texture的偏移属性.offset就可以。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个设置重复纹理的管道</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> curve = <span class="keyword">new</span> THREE.CatmullRomCurve3([</span><br><span class="line">  <span class="keyword">new</span> THREE.Vector3(<span class="number">-80</span>, <span class="number">-40</span>, <span class="number">0</span>),</span><br><span class="line">  <span class="keyword">new</span> THREE.Vector3(<span class="number">-70</span>, <span class="number">40</span>, <span class="number">0</span>),</span><br><span class="line">  <span class="keyword">new</span> THREE.Vector3(<span class="number">70</span>, <span class="number">40</span>, <span class="number">0</span>),</span><br><span class="line">  <span class="keyword">new</span> THREE.Vector3(<span class="number">80</span>, <span class="number">-40</span>, <span class="number">0</span>)</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// 管道几何体</span></span><br><span class="line"><span class="keyword">var</span> tubeGeometry = <span class="keyword">new</span> THREE.TubeGeometry(curve, <span class="number">100</span>, <span class="number">0.6</span>, <span class="number">50</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">var</span> textureLoader = <span class="keyword">new</span> THREE.TextureLoader();</span><br><span class="line"><span class="keyword">var</span> texture = textureLoader.load(<span class="string">'run.jpg'</span>);</span><br><span class="line"><span class="comment">// 设置阵列模式为 RepeatWrapping</span></span><br><span class="line">texture.wrapS = THREE.RepeatWrapping</span><br><span class="line">texture.wrapT=THREE.RepeatWrapping</span><br><span class="line"><span class="comment">// 设置x方向的偏移(沿着管道路径方向)，y方向默认1</span></span><br><span class="line"><span class="comment">//等价texture.repeat= new THREE.Vector2(20,1)</span></span><br><span class="line">texture.repeat.x = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> tubeMaterial = <span class="keyword">new</span> THREE.MeshPhongMaterial(&#123;</span><br><span class="line">  map: texture,</span><br><span class="line">  transparent: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> tube = <span class="keyword">new</span> THREE.Mesh(tubeGeometry, tubeMaterial);</span><br><span class="line">scene.add(tube)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  renderer.render(scene, camera); <span class="comment">//执行渲染操作</span></span><br><span class="line">  requestAnimationFrame(render);</span><br><span class="line">  <span class="comment">// 使用加减法可以设置不同的运动方向</span></span><br><span class="line">  <span class="comment">// 设置纹理偏移</span></span><br><span class="line">  texture.offset.x -= <span class="number">0.06</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="./01.gif" alt="纹理动画"></p>
]]></content>
  </entry>
  <entry>
    <title>数组材质,材质索引</title>
    <url>/2020/07/15/02web/ThreeJS/08%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE/03%E6%95%B0%E7%BB%84%E6%9D%90%E8%B4%A8,%E6%9D%90%E8%B4%A8%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h1 id="数组材质"><a href="#数组材质" class="headerlink" title="数组材质"></a>数组材质</h1><ul>
<li>把数组材质作为几何体的纹理贴图</li>
<li>数组材质就是多个材质对象构成一个数组作为模型对象的材质</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>); <span class="comment">//立方体</span></span><br><span class="line"><span class="comment">// 材质对象1</span></span><br><span class="line"><span class="keyword">var</span> material_1 = <span class="keyword">new</span> THREE.MeshPhongMaterial(&#123;</span><br><span class="line">  color: <span class="number">0xffff3f</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> textureLoader = <span class="keyword">new</span> THREE.TextureLoader(); <span class="comment">// 纹理加载器</span></span><br><span class="line"><span class="keyword">var</span> texture = textureLoader.load(<span class="string">'Earth.png'</span>); <span class="comment">// 加载图片，返回Texture对象</span></span><br><span class="line"><span class="comment">// 材质对象2</span></span><br><span class="line"><span class="keyword">var</span> material_2 = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">  map: texture, <span class="comment">// 设置纹理贴图</span></span><br><span class="line">  <span class="comment">// wireframe:true,</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 设置材质数组</span></span><br><span class="line"><span class="keyword">var</span> materialArr = [material_2, material_1, material_1, material_1, material_1, material_1];</span><br><span class="line"><span class="comment">// 设置数组材质对象作为网格模型材质参数</span></span><br><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, materialArr); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span><br></pre></td></tr></table></figure>

<p><img src="./01.png" alt="数组材质"></p>
<h1 id="材质索引"><a href="#材质索引" class="headerlink" title="材质索引"></a>材质索引</h1><ul>
<li>类似映射原理中局部贴图</li>
<li>把细分的矩形某些位置设置为索引的材质</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.PlaneGeometry(<span class="number">204</span>, <span class="number">102</span>, <span class="number">4</span>, <span class="number">4</span>); <span class="comment">//矩形平面</span></span><br><span class="line"><span class="comment">// 材质对象1</span></span><br><span class="line"><span class="keyword">var</span> material1 = <span class="keyword">new</span> THREE.MeshPhongMaterial(&#123;</span><br><span class="line">  color: <span class="number">0xffff3f</span>,</span><br><span class="line">  <span class="comment">// wireframe:true,</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 材质对象2</span></span><br><span class="line"><span class="keyword">var</span> material2 = <span class="keyword">new</span> THREE.MeshPhongMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x0000ff</span>,</span><br><span class="line">  <span class="comment">// wireframe:true,</span></span><br><span class="line">&#125;); <span class="comment">//材质对象Material</span></span><br><span class="line"><span class="comment">// 数组材质</span></span><br><span class="line"><span class="keyword">var</span> materialArr = [material1, material2];</span><br><span class="line"><span class="comment">// 设置几何体的材质索引(对于PlaneGeometry而言所有Face3的材质索引默认0)</span></span><br><span class="line">geometry.faces[<span class="number">4</span>].materialIndex = <span class="number">1</span>;</span><br><span class="line">geometry.faces[<span class="number">5</span>].materialIndex = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, materialArr); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span><br></pre></td></tr></table></figure>

<p><img src="./02.png" alt="材质索引"></p>
]]></content>
  </entry>
  <entry>
    <title>画布视频纹理贴图</title>
    <url>/2020/07/21/02web/ThreeJS/08%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE/05%E7%94%BB%E5%B8%83%E8%A7%86%E9%A2%91%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="画布纹理贴图"><a href="#画布纹理贴图" class="headerlink" title="画布纹理贴图"></a>画布纹理贴图</h1><p>Canvas画布可以通过2D API绘制各种各样的几何形状，可以通过Canvas绘制一个轮廓后然后作为Three.js网格模型、精灵模型等模型对象的纹理贴图。</p>
<h2 id="canvas画布"><a href="#canvas画布" class="headerlink" title="canvas画布"></a>canvas画布</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">"canvas"</span>);</span><br><span class="line">canvas.width = <span class="number">512</span>;</span><br><span class="line">canvas.height = <span class="number">128</span>;</span><br><span class="line"><span class="comment">// 开启2d绘制</span></span><br><span class="line"><span class="keyword">var</span> c = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="comment">// 矩形区域填充背景</span></span><br><span class="line">c.fillStyle = <span class="string">"#ff00ff"</span>;</span><br><span class="line">c.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">512</span>, <span class="number">128</span>);</span><br><span class="line">c.beginPath();</span><br><span class="line"><span class="comment">// 文字</span></span><br><span class="line">c.beginPath();</span><br><span class="line">c.translate(<span class="number">256</span>,<span class="number">64</span>);</span><br><span class="line">c.fillStyle = <span class="string">"#000000"</span>; <span class="comment">//文本填充颜色</span></span><br><span class="line">c.font = <span class="string">"bold 48px 宋体"</span>; <span class="comment">//字体样式设置</span></span><br><span class="line">c.textBaseline = <span class="string">"middle"</span>; <span class="comment">//文本与fillText定义的纵坐标</span></span><br><span class="line">c.textAlign = <span class="string">"center"</span>; <span class="comment">//文本居中(以fillText定义的横坐标)</span></span><br><span class="line">c.fillText(<span class="string">"linjiad"</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(canvas)</span><br></pre></td></tr></table></figure>

<p><img src="./01.png" alt="canvas画布"></p>
<h2 id="画布贴图"><a href="#画布贴图" class="headerlink" title="画布贴图"></a>画布贴图</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// canvas画布对象作为CanvasTexture的参数重建一个纹理对象</span></span><br><span class="line"><span class="comment">// canvas画布可以理解为一张图片</span></span><br><span class="line"><span class="keyword">var</span> texture = <span class="keyword">new</span> THREE.CanvasTexture(canvas);</span><br><span class="line"><span class="comment">//打印纹理对象的image属性</span></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshPhongMaterial(&#123;</span><br><span class="line">  map: texture, <span class="comment">// 设置纹理贴图</span></span><br><span class="line">&#125;); <span class="comment">//材质对象Material</span></span><br><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span><br></pre></td></tr></table></figure>

<p><img src="./02.png" alt="画布贴图"></p>
<h1 id="视频纹理贴图"><a href="#视频纹理贴图" class="headerlink" title="视频纹理贴图"></a>视频纹理贴图</h1><ul>
<li>视频本质上就是一帧帧图片流构成</li>
<li>把视频作为Threejs模型的纹理贴图使用，就是从视频中提取一帧一帧的图片作为模型的纹理贴图</li>
<li>然后不停的更新的纹理贴图就可以产生视频播放的效果。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scene = <span class="keyword">new</span> THREE.Scene();</span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.PlaneGeometry(<span class="number">108</span>, <span class="number">71</span>); <span class="comment">//矩形平面</span></span><br><span class="line"><span class="comment">// 创建video对象</span></span><br><span class="line"><span class="keyword">let</span> video = <span class="built_in">document</span>.createElement(<span class="string">'video'</span>);</span><br><span class="line">video.src = <span class="string">"./1086x716.mp4"</span>; <span class="comment">// 设置视频地址</span></span><br><span class="line">video.autoplay = <span class="string">"autoplay"</span>; <span class="comment">//要设置播放</span></span><br><span class="line"><span class="comment">// video对象作为VideoTexture参数创建纹理对象</span></span><br><span class="line"><span class="keyword">var</span> texture = <span class="keyword">new</span> THREE.VideoTexture(video)</span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshPhongMaterial(&#123;</span><br><span class="line">  map: texture, <span class="comment">// 设置纹理贴图</span></span><br><span class="line">&#125;); <span class="comment">//材质对象Material</span></span><br><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span><br></pre></td></tr></table></figure>

<ul>
<li>VideoTexture.js封装了一个update函数</li>
<li>Threejs每次执行渲染方法进行渲染场景中的时候，都会执行VideoTexture封装的update函数</li>
<li>执行update函数中代码this.needsUpdate = true</li>
<li>读取视频流最新一帧图片来更新Threejs模型纹理贴图</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>凹凸贴图和法线贴图</title>
    <url>/2020/07/21/02web/ThreeJS/08%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE/06%E5%87%B9%E5%87%B8%E8%B4%B4%E5%9B%BE%E5%92%8C%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="法线贴图"><a href="#法线贴图" class="headerlink" title="法线贴图"></a>法线贴图</h1><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li>没有设置法线贴图之前就是一个立方体网格模型Mesh</li>
<li>然后把一个携带圆形凹坑信息的法线贴图设置到立方体网格模型的面上</li>
<li>之后可以看到面上多个凹陷效果</li>
<li>复杂的三维模型3D美术可以通过减面操作把精模简化为简模</li>
<li>然后把精模表面的复杂几何信息映射到法线贴图.normalMap上</li>
</ul>
<p>法线贴图</p>
<p><img src="./03.jpg" alt="法线贴图"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//立方体</span></span><br><span class="line"> <span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>); </span><br><span class="line"><span class="comment">// TextureLoader创建一个纹理加载器对象，可以加载图片作为几何体纹理</span></span><br><span class="line"><span class="keyword">var</span> textureLoader = <span class="keyword">new</span> THREE.TextureLoader();</span><br><span class="line"><span class="comment">// 加载法线贴图</span></span><br><span class="line"><span class="keyword">var</span> textureNormal = textureLoader.load(<span class="string">'./法线贴图/3_256.jpg'</span>);</span><br><span class="line"><span class="comment">//材质对象Material</span></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshPhongMaterial(&#123;</span><br><span class="line">  color: <span class="number">0xff0000</span>,</span><br><span class="line">  normalMap: textureNormal, <span class="comment">//法线贴图</span></span><br><span class="line">  <span class="comment">//设置深浅程度，默认值(1,1)。</span></span><br><span class="line">  normalScale: <span class="keyword">new</span> THREE.Vector2(<span class="number">3</span>, <span class="number">3</span>),</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span><br></pre></td></tr></table></figure>

<p><img src="./01.png" alt="法线贴图"></p>
<h2 id="地球案例"><a href="#地球案例" class="headerlink" title="地球案例"></a>地球案例</h2><p>地球表面法线贴图记录了地面表面的几何信息</p>
<p><img src="./04.png" alt="法线贴图"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.SphereGeometry(<span class="number">100</span>, <span class="number">25</span>, <span class="number">25</span>); <span class="comment">//球体</span></span><br><span class="line"><span class="comment">// TextureLoader创建一个纹理加载器对象，可以加载图片作为几何体纹理</span></span><br><span class="line"><span class="keyword">var</span> textureLoader = <span class="keyword">new</span> THREE.TextureLoader();</span><br><span class="line"><span class="comment">// 加载纹理贴图</span></span><br><span class="line"><span class="keyword">var</span> texture = textureLoader.load(<span class="string">'./Earth.png'</span>);</span><br><span class="line"><span class="comment">// 加载法线贴图</span></span><br><span class="line"><span class="keyword">var</span> textureNormal = textureLoader.load(<span class="string">'./EarthNormal.png'</span>);</span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshPhongMaterial(&#123;</span><br><span class="line">  map: texture, <span class="comment">// 普通颜色纹理贴图</span></span><br><span class="line">  normalMap: textureNormal, <span class="comment">//法线贴图</span></span><br><span class="line">  <span class="comment">//设置深浅程度，默认值(1,1)。</span></span><br><span class="line">  normalScale: <span class="keyword">new</span> THREE.Vector2(<span class="number">1.2</span>, <span class="number">1.2</span>),</span><br><span class="line">&#125;); <span class="comment">//材质对象Material</span></span><br><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span><br></pre></td></tr></table></figure>

<p>对比两个地球的渲染效果，一个设置法线贴图，一个不设置法线贴图。</p>
<p><img src="./02.jpg" alt="地球案例"></p>
<h1 id="凹凸贴图"><a href="#凹凸贴图" class="headerlink" title="凹凸贴图"></a>凹凸贴图</h1><ul>
<li>凹凸贴图和法线贴图功能相似</li>
<li>只是没有发现贴图表达的几何体表面信息更丰富</li>
<li>凹凸贴图是用图片像素的灰度值表示几何表面的高低深度</li>
<li>如果模型定义了法线贴图，就没有必要在使用凹凸贴图。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.PlaneGeometry(<span class="number">400</span>, <span class="number">400</span>); <span class="comment">//矩形平面</span></span><br><span class="line"><span class="comment">// TextureLoader创建一个纹理加载器对象，可以加载图片作为几何体纹理</span></span><br><span class="line"><span class="keyword">var</span> textureLoader = <span class="keyword">new</span> THREE.TextureLoader();</span><br><span class="line"><span class="comment">// 加载纹理贴图</span></span><br><span class="line"><span class="keyword">var</span> texture = textureLoader.load(<span class="string">'./凹凸贴图/diffuse.jpg'</span>);</span><br><span class="line"><span class="comment">// 加载凹凸贴图</span></span><br><span class="line"><span class="keyword">var</span> textureBump = textureLoader.load(<span class="string">'./凹凸贴图/bump.jpg'</span>);</span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshPhongMaterial(&#123;</span><br><span class="line">  map: texture,<span class="comment">// 普通纹理贴图</span></span><br><span class="line">  bumpMap:textureBump,<span class="comment">//凹凸贴图</span></span><br><span class="line">  bumpScale:<span class="number">3</span>,<span class="comment">//设置凹凸高度，默认值1。</span></span><br><span class="line">&#125;); <span class="comment">//材质对象Material</span></span><br><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span><br></pre></td></tr></table></figure>

<p><img src="./05.jpg" alt="凹凸贴图"><br><img src="./06.jpg" alt="凹凸贴图"></p>
]]></content>
  </entry>
  <entry>
    <title>光照贴图添加阴影</title>
    <url>/2020/07/22/02web/ThreeJS/08%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE/07%E5%85%89%E7%85%A7%E8%B4%B4%E5%9B%BE%E6%B7%BB%E5%8A%A0%E9%98%B4%E5%BD%B1/</url>
    <content><![CDATA[<ul>
<li>之前我们用实时计算来设置投影</li>
<li>我们也可以用投影贴图来设置投影</li>
<li>贴图设置投影无需设置光照</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">40</span>, <span class="number">100</span>, <span class="number">40</span>); <span class="comment">//创建一个立方体几何对象Geometry</span></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x0000ff</span></span><br><span class="line">&#125;); <span class="comment">//材质对象Material</span></span><br><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个平面几何体作为投影面</span></span><br><span class="line"><span class="keyword">var</span> planeGeometry = <span class="keyword">new</span> THREE.PlaneGeometry(<span class="number">300</span>, <span class="number">200</span>);</span><br><span class="line">planeGeometry.faceVertexUvs[<span class="number">1</span>] = planeGeometry.faceVertexUvs[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> textureLoader = <span class="keyword">new</span> THREE.TextureLoader();</span><br><span class="line"><span class="comment">// 加载光照贴图</span></span><br><span class="line"><span class="keyword">var</span> textureLight = textureLoader.load(<span class="string">'shadow.png'</span>);</span><br><span class="line"><span class="keyword">var</span> planeMaterial = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x999999</span>,</span><br><span class="line">  lightMap:textureLight,<span class="comment">// 设置光照贴图</span></span><br><span class="line">  <span class="comment">// lightMapIntensity:0.5,//烘培光照的强度. 默认 1.</span></span><br><span class="line">&#125;); <span class="comment">//材质对象Material</span></span><br><span class="line"><span class="keyword">var</span> planeMesh = <span class="keyword">new</span> THREE.Mesh(planeGeometry, planeMaterial); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">scene.add(planeMesh); <span class="comment">//网格模型添加到场景中</span></span><br><span class="line">planeMesh.rotateX(-<span class="built_in">Math</span>.PI / <span class="number">2</span>); <span class="comment">//旋转网格模型</span></span><br><span class="line">planeMesh.position.y = <span class="number">-50</span>; <span class="comment">//设置网格模型y坐标</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对于Geometry类型几何体而言一般几何体有两套UV坐标</li>
<li>Geometry.faceVertexUvs[0]包含的纹理坐标用于颜色贴图map、法线贴图normalMap等</li>
<li>Geometry.faceVertexUvs[1]包含的第二套纹理贴图用于光照阴影贴图</li>
<li>一般通过Threejs几何体API创建的几何体默认只有一组纹理坐标Geometry.faceVertexUvs[0]</li>
<li>所以为了设置光照阴影贴图，需要给另一组纹理坐标赋值Geometry.faceVertexUvs[1] = Geometry.faceVertexUvs[0]</li>
</ul>
<p><img src="./01.png" alt="光照贴图添加阴影"></p>
]]></content>
  </entry>
  <entry>
    <title>高光贴图</title>
    <url>/2020/07/22/02web/ThreeJS/08%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE/08%E9%AB%98%E5%85%89%E8%B4%B4%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="高光贴图"><a href="#高光贴图" class="headerlink" title="高光贴图"></a>高光贴图</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul>
<li>高光网格材质MeshPhongMaterial具有高光属性.specular</li>
<li>如果说网格模型外表面所有不同区域的镜面反射能力相同，可以直接设置材质的高光属性.specular</li>
<li>如果一个网格模型表示一个人，那么人的不同部位高光程度是不同的，不可能直接通过.specular属性来描述，在这种情况通过高光贴图</li>
</ul>
<h2 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h2><ul>
<li>地球地面和海面的高光值是不同的</li>
<li>海面更为高亮</li>
<li>可以使用高光贴图和不使用高光贴图的渲染效果有什么不同。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.SphereGeometry(<span class="number">100</span>, <span class="number">35</span>, <span class="number">35</span>); <span class="comment">//球体</span></span><br><span class="line"><span class="comment">// TextureLoader创建一个纹理加载器对象，可以加载图片作为几何体纹理</span></span><br><span class="line"><span class="keyword">var</span> textureLoader = <span class="keyword">new</span> THREE.TextureLoader();</span><br><span class="line"><span class="comment">// 加载纹理贴图</span></span><br><span class="line"><span class="keyword">var</span> texture = textureLoader.load(<span class="string">'earth_diffuse.png'</span>);</span><br><span class="line"><span class="comment">// 加载高光贴图</span></span><br><span class="line"><span class="keyword">var</span> textureSpecular = textureLoader.load(<span class="string">'earth_specular.png'</span>);</span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshPhongMaterial(&#123;</span><br><span class="line">  <span class="comment">// specular: 0xff0000,//高光部分的颜色</span></span><br><span class="line">  shininess: <span class="number">30</span>,<span class="comment">//高光部分的亮度，默认30</span></span><br><span class="line">  map: texture,<span class="comment">// 普通纹理贴图</span></span><br><span class="line">  specularMap: textureSpecular, <span class="comment">//高光贴图</span></span><br><span class="line">&#125;); <span class="comment">//材质对象Material</span></span><br><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span><br></pre></td></tr></table></figure>

<p><img src="./01.png" alt="高光贴图"></p>
<h2 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h2><p>高光贴图图片</p>
<p><img src="./02.jpg" alt="案例2"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.PlaneGeometry(<span class="number">200</span>, <span class="number">200</span>); <span class="comment">//矩形平面</span></span><br><span class="line"><span class="comment">// TextureLoader创建一个纹理加载器对象，可以加载图片作为几何体纹理</span></span><br><span class="line"><span class="keyword">var</span> textureLoader = <span class="keyword">new</span> THREE.TextureLoader();</span><br><span class="line"><span class="comment">// 加载高光贴图</span></span><br><span class="line"><span class="keyword">var</span> textureSpecular = textureLoader.load(<span class="string">'specular.jpg'</span>);</span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshPhongMaterial(&#123;</span><br><span class="line">  color:<span class="number">0x0000ff</span>,</span><br><span class="line">  specular: <span class="number">0xff0000</span>,<span class="comment">//高光部分的颜色</span></span><br><span class="line">  shininess: <span class="number">30</span>,<span class="comment">//高光部分的亮度，默认30</span></span><br><span class="line">  <span class="comment">//高光贴图：像素值越大反光效果越明显</span></span><br><span class="line">  specularMap: textureSpecular,</span><br><span class="line">&#125;); <span class="comment">//材质对象Material</span></span><br><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span><br></pre></td></tr></table></figure>

<p><img src="./03.png" alt="案例3"></p>
]]></content>
  </entry>
  <entry>
    <title>环境贴图</title>
    <url>/2020/07/22/02web/ThreeJS/08%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE/09%E7%8E%AF%E5%A2%83%E8%B4%B4%E5%9B%BE/</url>
    <content><![CDATA[<ul>
<li>环境贴图可以模拟玻璃体</li>
<li>环境贴图需要有六个图片[前，后，左，右，上，下]</li>
<li>一个立方体有六个面，给每个面都设置环境贴图</li>
<li>加载器加载一组图片</li>
<li>把这一组图片放到立方体的环境贴图变量中</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>); <span class="comment">//立方体</span></span><br><span class="line"><span class="keyword">var</span> loader = <span class="keyword">new</span> THREE.CubeTextureLoader();</span><br><span class="line"><span class="comment">// 所有贴图在同一目录下，可以使用该方法设置共用路径</span></span><br><span class="line">loader.setPath(<span class="string">'环境贴图/'</span>);</span><br><span class="line"><span class="comment">// 立方体纹理加载器返回立方体纹理对象CubeTexture</span></span><br><span class="line"><span class="keyword">var</span> CubeTexture = loader.load([<span class="string">'px.jpg'</span>, <span class="string">'nx.jpg'</span>, <span class="string">'py.jpg'</span>, <span class="string">'ny.jpg'</span>, <span class="string">'pz.jpg'</span>, <span class="string">'nz.jpg'</span>]);</span><br><span class="line"><span class="comment">//材质对象Material</span></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshPhongMaterial(&#123;</span><br><span class="line">  envMap: CubeTexture, <span class="comment">//设置环境贴图</span></span><br><span class="line">  <span class="comment">// 环境贴图反射率</span></span><br><span class="line">  <span class="comment">// reflectivity: 0.1,</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span><br></pre></td></tr></table></figure>

<p><img src="./01.png" alt="环境贴图"></p>
]]></content>
  </entry>
  <entry>
    <title>正投影和透视投影相机</title>
    <url>/2020/07/22/02web/ThreeJS/09%E7%9B%B8%E6%9C%BA%E5%AF%B9%E8%B1%A1/01%E6%AD%A3%E6%8A%95%E5%BD%B1%E5%92%8C%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1%E7%9B%B8%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><img src="./01.png" alt="概述"></p>
<ul>
<li>针对不同应用的三维场景需要使用不同的投影方式</li>
<li>比如机械、工业设计领域常常采用正投影(平行投影)</li>
<li>大型游戏场景往往采用透视投影(中心投影)</li>
<li>three.js封装WebGL API和相关算法，提供了正投影相机OrthographicCamera和透视投影相机PerspectiveCamera</li>
</ul>
<h2 id="正投影和透视投影"><a href="#正投影和透视投影" class="headerlink" title="正投影和透视投影"></a>正投影和透视投影</h2><ul>
<li>对于正投影而言，一条直线放置的角度不同，投影在投影面上面的长短不同</li>
<li>对于透视投影而言，投影的结果除了与几何体的角度有关，还和距离相关</li>
<li>使用OrthographicCamera相机对象的时候，three.js会按照正投影算法自动计算几何体的投影结果</li>
<li>使用PerspectiveCamera相机对象的时候，three.js会按照透视投影算法自动计算几何体的投影结果</li>
</ul>
<p><img src="./02.jpg" alt="正投影和透视投影"></p>
<h2 id="正投影相机对象OrthographicCamera"><a href="#正投影相机对象OrthographicCamera" class="headerlink" title="正投影相机对象OrthographicCamera"></a>正投影相机对象OrthographicCamera</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正投影相机设置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> width = <span class="built_in">window</span>.innerWidth; <span class="comment">//窗口宽度</span></span><br><span class="line"><span class="keyword">var</span> height = <span class="built_in">window</span>.innerHeight; <span class="comment">//窗口高度</span></span><br><span class="line"><span class="keyword">var</span> k = width / height; <span class="comment">//窗口宽高比</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="number">150</span>; <span class="comment">//三维场景显示范围控制系数，系数越大，显示的范围越大</span></span><br><span class="line"><span class="comment">//创建相机对象</span></span><br><span class="line"><span class="keyword">var</span> camera = <span class="keyword">new</span> THREE.OrthographicCamera(-s * k, s * k, s, -s, <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">camera.position.set(<span class="number">200</span>, <span class="number">300</span>, <span class="number">200</span>); <span class="comment">//设置相机位置</span></span><br><span class="line">camera.lookAt(scene.position); <span class="comment">//设置相机方向(指向的场景对象)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>OrthographicCamera( left, right, top, bottom, near, far )</p>
</blockquote>
<table>
<thead>
<tr>
<th>参数(属性)</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td>left</td>
<td align="center">渲染空间的左边界</td>
</tr>
<tr>
<td>right</td>
<td align="center">渲染空间的右边界</td>
</tr>
<tr>
<td>top</td>
<td align="center">渲染空间的上边界</td>
</tr>
<tr>
<td>bottom</td>
<td align="center">渲染空间的下边界</td>
</tr>
<tr>
<td>near</td>
<td align="center">near属性表示的是从距离相机多远的位置开始渲染，一般情况会设置一个很小的值。 默认值0.1</td>
</tr>
<tr>
<td>far</td>
<td align="center">far属性表示的是距离相机多远的位置截止渲染，如果设置的值偏小小，会有部分场景看不到。 默认值1000</td>
</tr>
</tbody></table>
<p><img src="./03.png" alt="参数"></p>
<ul>
<li><code>三维场景中坐标值不在三维空间中的网格模型不会被渲染出来，会被剪裁掉，比如你把上面代码中far参数的值从1000更改为420，你会发现长方体的一部分无法显示。</code></li>
<li><code>左右边界的距离与上下边界的距离比值与画布的渲染窗口的宽高比例要一致，否则三维模型的显示效果会被单方向不等比例拉伸</code></li>
</ul>
<h2 id="透视投影相机PerspectiveCamera"><a href="#透视投影相机PerspectiveCamera" class="headerlink" title="透视投影相机PerspectiveCamera"></a>透视投影相机PerspectiveCamera</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 透视投影相机设置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> width = <span class="built_in">window</span>.innerWidth; <span class="comment">//窗口宽度</span></span><br><span class="line"><span class="keyword">var</span> height = <span class="built_in">window</span>.innerHeight; <span class="comment">//窗口高度</span></span><br><span class="line"><span class="comment">/**透视投影相机对象*/</span></span><br><span class="line"><span class="keyword">var</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera(<span class="number">60</span>, width / height, <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">camera.position.set(<span class="number">200</span>, <span class="number">300</span>, <span class="number">200</span>); <span class="comment">//设置相机位置</span></span><br><span class="line">camera.lookAt(scene.position); <span class="comment">//设置相机方向(指向的场景对象)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>PerspectiveCamera( fov, aspect, near, far )</p>
</blockquote>
<table>
<thead>
<tr>
<th>参数</th>
<th align="center">含义</th>
<th align="right">默认值</th>
</tr>
</thead>
<tbody><tr>
<td>fov</td>
<td align="center">fov表示视场，所谓视场就是能够看到的角度范围，人的眼睛大约能够看到180度的视场，视角大小设置要根据具体应用，一般游戏会设置60~90度</td>
<td align="right">45</td>
</tr>
<tr>
<td>aspect</td>
<td align="center">aspect表示渲染窗口的长宽比，如果一个网页上只有一个全屏的canvas画布且画布上只有一个窗口，那么aspect的值就是网页窗口客户区的宽高比</td>
<td align="right">window.innerWidth/window.innerHeight</td>
</tr>
<tr>
<td>near</td>
<td align="center">near属性表示的是从距离相机多远的位置开始渲染，一般情况会设置一个很小的值。</td>
<td align="right">0.1</td>
</tr>
<tr>
<td>far</td>
<td align="center">far属性表示的是距离相机多远的位置截止渲染，如果设置的值偏小小，会有部分场景看不到</td>
<td align="right">1000</td>
</tr>
</tbody></table>
<p><img src="./04.png" alt="参数"></p>
<h2 id="相机位置-posiiotn和-lookAt-相机拍摄目标位置"><a href="#相机位置-posiiotn和-lookAt-相机拍摄目标位置" class="headerlink" title="相机位置.posiiotn和.lookAt(相机拍摄目标位置)"></a>相机位置.posiiotn和.lookAt(相机拍摄目标位置)</h2><p><img src="./05.png" alt="参数"></p>
<ul>
<li>.lookAt()方法用来指定相机拍摄对象的坐标位置<ul>
<li>lookAt()方法的参数是表示位置坐标的三维向量对象Vector3</li>
<li>所以.lookAt()方法的参数可以通过代码new THREE.Vector3(x,y,z)设置</li>
</ul>
</li>
<li>scene.position就表示返回场景scene的位置坐标<ul>
<li>如果把scene.position换成某个网格模型对象的位置就是mesh.position，mesh.position表示网格模型mesh的本地位置坐标</li>
</ul>
</li>
<li>通过相机观察点的位置和.lookAt()方法指向的位置就可以计算出相机的拍摄角度</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>数据纹理对象DataTexture</title>
    <url>/2020/07/22/02web/ThreeJS/08%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE/10%E6%95%B0%E6%8D%AE%E7%BA%B9%E7%90%86%E5%AF%B9%E8%B1%A1DataTexture/</url>
    <content><![CDATA[<p>Three.js数据纹理对象DataTexture简单地说就是通过程序创建纹理贴图的每一个像素值。</p>
<h1 id="程序生成一张图片的RGB值"><a href="#程序生成一张图片的RGB值" class="headerlink" title="程序生成一张图片的RGB值"></a>程序生成一张图片的RGB值</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scene = <span class="keyword">new</span> THREE.Scene();</span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.PlaneGeometry(<span class="number">128</span>, <span class="number">128</span>); <span class="comment">//矩形平面</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建纹理对象的像素数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> width = <span class="number">32</span>; <span class="comment">//纹理宽度</span></span><br><span class="line"><span class="keyword">var</span> height = <span class="number">32</span>; <span class="comment">//纹理高度</span></span><br><span class="line"><span class="keyword">var</span> size = width * height; <span class="comment">//像素大小</span></span><br><span class="line"><span class="comment">// 创建初始化为0的，包含length个元素的无符号整型数组</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(size * <span class="number">3</span>); <span class="comment">//size*3：像素在缓冲区占用空间</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; size * <span class="number">3</span>; i += <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="comment">// 随机设置RGB分量的值</span></span><br><span class="line">  data[i] = <span class="number">255</span> * <span class="built_in">Math</span>.random()</span><br><span class="line">  data[i + <span class="number">1</span>] = <span class="number">255</span> * <span class="built_in">Math</span>.random()</span><br><span class="line">  data[i + <span class="number">2</span>] = <span class="number">255</span> * <span class="built_in">Math</span>.random()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建数据文理对象   RGB格式：THREE.RGBFormat</span></span><br><span class="line"><span class="keyword">var</span> texture = <span class="keyword">new</span> THREE.DataTexture(data, width, height, THREE.RGBFormat);</span><br><span class="line">texture.needsUpdate = <span class="literal">true</span>; <span class="comment">//纹理更新</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshPhongMaterial(&#123;</span><br><span class="line">  map: texture, <span class="comment">// 设置纹理贴图</span></span><br><span class="line">&#125;); <span class="comment">//材质对象Material</span></span><br><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span><br></pre></td></tr></table></figure>

<p><img src="./01.jpg" alt="程序生成一张图片的RGB值"></p>
<h1 id="程序生成一张图片的RGBA值"><a href="#程序生成一张图片的RGBA值" class="headerlink" title="程序生成一张图片的RGBA值"></a>程序生成一张图片的RGBA值</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scene = <span class="keyword">new</span> THREE.Scene();</span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.PlaneGeometry(<span class="number">128</span>, <span class="number">128</span>); <span class="comment">//矩形平面</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建纹理对象的像素数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> width = <span class="number">32</span>; <span class="comment">//纹理宽度</span></span><br><span class="line"><span class="keyword">var</span> height = <span class="number">32</span>; <span class="comment">//纹理高度</span></span><br><span class="line"><span class="keyword">var</span> size = width * height; <span class="comment">//像素大小</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(size * <span class="number">4</span>); <span class="comment">//size*4：像素在缓冲区占用空间</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; size * <span class="number">4</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">  <span class="comment">// 随机设置RGB分量的值</span></span><br><span class="line">  data[i] = <span class="number">255</span> * <span class="built_in">Math</span>.random()</span><br><span class="line">  data[i + <span class="number">1</span>] = <span class="number">255</span> * <span class="built_in">Math</span>.random()</span><br><span class="line">  data[i + <span class="number">2</span>] = <span class="number">255</span> * <span class="built_in">Math</span>.random()</span><br><span class="line">  <span class="comment">// 设置透明度分量A</span></span><br><span class="line">  data[i + <span class="number">3</span>] = <span class="number">255</span> * <span class="number">0.5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建数据文理对象   RGBA格式：THREE.RGBAFormat</span></span><br><span class="line"><span class="keyword">var</span> texture = <span class="keyword">new</span> THREE.DataTexture(data, width, height, THREE.RGBAFormat);</span><br><span class="line">texture.needsUpdate = <span class="literal">true</span>; <span class="comment">//纹理更新</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshPhongMaterial(&#123;</span><br><span class="line">  map: texture, <span class="comment">// 设置纹理贴图</span></span><br><span class="line">  transparent:<span class="literal">true</span>,<span class="comment">//允许透明设置</span></span><br><span class="line">&#125;); <span class="comment">//材质对象Material</span></span><br><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span><br></pre></td></tr></table></figure>

<p><img src="./02.jpg" alt="程序生成一张图片的RGBA值"></p>
]]></content>
  </entry>
  <entry>
    <title>精灵模型对象Sprite</title>
    <url>/2020/07/22/02web/ThreeJS/10%E7%B2%BE%E7%81%B5%E6%A8%A1%E5%9E%8B,%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/01%E7%B2%BE%E7%81%B5%E6%A8%A1%E5%9E%8B%E5%AF%B9%E8%B1%A1Sprite/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><ul>
<li>Three.js的精灵模型对象Sprite和Threejs的网格模型Mesh一样都是模型对象</li>
<li>创建精灵模型对象Sprite和创建网格模型对象一样需要创建一个材质对象</li>
<li>不同的地方在于创建精灵模型对象不需要创建几何体对象Geometry</li>
<li>精灵模型对象本质上你可以理解为已经内部封装了一个平面矩形几何体PlaneGeometry</li>
<li>矩形精灵模型与矩形网格模型的区别在于精灵模型的矩形平面会始终平行于Canvas画布。</li>
</ul>
<h1 id="创建精灵模型"><a href="#创建精灵模型" class="headerlink" title="创建精灵模型"></a>创建精灵模型</h1><ul>
<li>通过Sprite创建精灵模型不需要几何体</li>
<li>只需要给构造函数Sprite的参数设置为一个精灵材质SpriteMaterial即可。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载纹理贴图</span></span><br><span class="line"><span class="keyword">var</span> texture = <span class="keyword">new</span> THREE.TextureLoader().load(<span class="string">"sprite.png"</span>);</span><br><span class="line"><span class="comment">// 创建精灵材质对象SpriteMaterial</span></span><br><span class="line"><span class="keyword">var</span> spriteMaterial = <span class="keyword">new</span> THREE.SpriteMaterial(&#123;</span><br><span class="line">  <span class="comment">// color:0xff00ff,//设置精灵矩形区域颜色</span></span><br><span class="line">  rotation:<span class="built_in">Math</span>.PI/<span class="number">4</span>,<span class="comment">//旋转精灵对象45度，弧度值</span></span><br><span class="line">  map: texture,<span class="comment">//设置精灵纹理贴图</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 创建精灵模型对象，不需要几何体geometry参数</span></span><br><span class="line"><span class="keyword">var</span> sprite = <span class="keyword">new</span> THREE.Sprite(spriteMaterial);</span><br><span class="line">scene.add(sprite);</span><br><span class="line"><span class="comment">// 控制精灵大小，比如可视化中精灵大小表征数据大小</span></span><br><span class="line">sprite.scale.set(<span class="number">40</span>, <span class="number">40</span>, <span class="number">1</span>); <span class="comment">//// 只需要设置x、y两个分量就可以</span></span><br></pre></td></tr></table></figure>

<p><img src="./01.png" alt="创建精灵模型"></p>
<h2 id="scale和-position"><a href="#scale和-position" class="headerlink" title=".scale和.position"></a>.scale和.position</h2><ul>
<li>精灵模型对象和网格模型Mesh对一样基类都是Object3D</li>
<li>精灵模型也有缩放属性.scale和位置属性.position</li>
<li>一般设置精灵模型的大小是通过.scale属性实现</li>
<li>而精灵模型的位置通过属性.position实现</li>
<li>精灵模型和普通模型一样，可以改变它在三维场景中的位置</li>
<li>区别在于精灵模型的正面一直平行于canvas画布。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>窗口变化自适应渲染</title>
    <url>/2020/07/22/02web/ThreeJS/09%E7%9B%B8%E6%9C%BA%E5%AF%B9%E8%B1%A1/02%E7%AA%97%E5%8F%A3%E5%8F%98%E5%8C%96%E8%87%AA%E9%80%82%E5%BA%94%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<ul>
<li>开发的过程中你可能会遇到这样一个问题，通过鼠标拖动使浏览器的窗口变大，因为Threejs渲染器的渲染尺寸范围没有跟着变化，出现局部空白区域。</li>
<li>对于这种情况要做的就是重新获取浏览器窗口新的宽高尺寸，然后通过新的宽高尺寸更新相机Camera和渲染器WebGLRenderer的参数即可。</li>
</ul>
<h1 id="视图矩阵-matrixWorldInverse和投影矩阵-projectionMatrix"><a href="#视图矩阵-matrixWorldInverse和投影矩阵-projectionMatrix" class="headerlink" title="视图矩阵.matrixWorldInverse和投影矩阵.projectionMatrix"></a>视图矩阵.matrixWorldInverse和投影矩阵.projectionMatrix</h1><ul>
<li>所谓相机对象Camera本质上就是视图矩阵.matrixWorldInverse和投影矩阵.projectionMatrix</li>
<li>Threejs渲染场景的时候调用相机对象的视图矩阵和投影矩阵值对顶点进行矩阵变换</li>
<li>影响视图矩阵.matrixWorldInverse计算的相关代码,无论透视投影相机还是正投影相机都一样。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">camera.position.set(<span class="number">200</span>, <span class="number">300</span>, <span class="number">200</span>); <span class="comment">//设置相机位置</span></span><br><span class="line">camera.lookAt(scene.position); <span class="comment">//设置相机方向(指向的场景对象)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>影响投影矩阵.projectionMatrix计算相机参数的相关代码</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正投影相机对象</span></span><br><span class="line"><span class="keyword">var</span> camera = <span class="keyword">new</span> THREE.OrthographicCamera(-s * k, s * k, s, -s, <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 透视投影相机对象</span></span><br><span class="line"><span class="keyword">var</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera(<span class="number">60</span>, width / height, <span class="number">1</span>, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<h1 id="正投影相机OrthographicCamera自适应渲染"><a href="#正投影相机OrthographicCamera自适应渲染" class="headerlink" title="正投影相机OrthographicCamera自适应渲染"></a>正投影相机OrthographicCamera自适应渲染</h1><ul>
<li>比如全屏渲染的时候，为了适应窗口的大小变化，要重新设置相机对象和渲染器对象的参数</li>
<li>只需要通过窗口事件window.onresize来触发一个函数，然后在函数中更新相机Camera和渲染器WebGLRenderer的参数。</li>
<li>渲染区域变化了，要通过Three.js渲染器.setSize()方法重置渲染器渲染尺寸。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 相机设置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> width = <span class="built_in">window</span>.innerWidth; <span class="comment">//窗口宽度</span></span><br><span class="line"><span class="keyword">var</span> height = <span class="built_in">window</span>.innerHeight; <span class="comment">//窗口高度</span></span><br><span class="line"><span class="keyword">var</span> k = width / height; <span class="comment">//窗口宽高比</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="number">150</span>; <span class="comment">//三维场景显示范围控制系数，系数越大，显示的范围越大</span></span><br><span class="line"><span class="comment">//创建相机对象</span></span><br><span class="line"><span class="keyword">var</span> camera = <span class="keyword">new</span> THREE.OrthographicCamera(-s * k, s * k, s, -s, <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">camera.position.set(<span class="number">200</span>, <span class="number">300</span>, <span class="number">200</span>); <span class="comment">//设置相机位置</span></span><br><span class="line">camera.lookAt(scene.position); <span class="comment">//设置相机方向(指向的场景对象)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// onresize 事件会在窗口被调整大小时发生</span></span><br><span class="line"><span class="built_in">window</span>.onresize=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 重置渲染器输出画布canvas尺寸</span></span><br><span class="line">  renderer.setSize(<span class="built_in">window</span>.innerWidth,<span class="built_in">window</span>.innerHeight);</span><br><span class="line">  <span class="comment">// 重置相机投影的相关参数</span></span><br><span class="line">  k = <span class="built_in">window</span>.innerWidth/<span class="built_in">window</span>.innerHeight;<span class="comment">//窗口宽高比</span></span><br><span class="line">  camera.left = -s*k;</span><br><span class="line">  camera.right = s*k;</span><br><span class="line">  camera.top = s;</span><br><span class="line">  camera.bottom = -s;</span><br><span class="line">  <span class="comment">// 渲染器执行render方法的时候会读取相机对象的投影矩阵属性projectionMatrix</span></span><br><span class="line">  <span class="comment">// 但是不会每渲染一帧，就通过相机的属性计算投影矩阵(节约计算资源)</span></span><br><span class="line">  <span class="comment">// 如果相机的一些属性发生了变化，需要执行updateProjectionMatrix ()方法更新相机的投影矩阵</span></span><br><span class="line">  camera.updateProjectionMatrix ();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="透视投影相机PerspectiveCamera自适应渲染"><a href="#透视投影相机PerspectiveCamera自适应渲染" class="headerlink" title="透视投影相机PerspectiveCamera自适应渲染"></a>透视投影相机PerspectiveCamera自适应渲染</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 透视投影相机设置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> width = <span class="built_in">window</span>.innerWidth; <span class="comment">//窗口宽度</span></span><br><span class="line"><span class="keyword">var</span> height = <span class="built_in">window</span>.innerHeight; <span class="comment">//窗口高度</span></span><br><span class="line"><span class="comment">/**透视投影相机对象*/</span></span><br><span class="line"><span class="keyword">var</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera(<span class="number">60</span>, width / height, <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">camera.position.set(<span class="number">200</span>, <span class="number">300</span>, <span class="number">200</span>); <span class="comment">//设置相机位置</span></span><br><span class="line">camera.lookAt(scene.position); <span class="comment">//设置相机方向(指向的场景对象)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// onresize 事件会在窗口被调整大小时发生</span></span><br><span class="line"><span class="built_in">window</span>.onresize=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 重置渲染器输出画布canvas尺寸</span></span><br><span class="line">  renderer.setSize(<span class="built_in">window</span>.innerWidth,<span class="built_in">window</span>.innerHeight);</span><br><span class="line">  <span class="comment">// 全屏情况下：设置观察范围长宽比aspect为窗口宽高比</span></span><br><span class="line">  camera.aspect = <span class="built_in">window</span>.innerWidth/<span class="built_in">window</span>.innerHeight;</span><br><span class="line">  <span class="comment">// 渲染器执行render方法的时候会读取相机对象的投影矩阵属性projectionMatrix</span></span><br><span class="line">  <span class="comment">// 但是不会每渲染一帧，就通过相机的属性计算投影矩阵(节约计算资源)</span></span><br><span class="line">  <span class="comment">// 如果相机的一些属性发生了变化，需要执行updateProjectionMatrix ()方法更新相机的投影矩阵</span></span><br><span class="line">  camera.updateProjectionMatrix ();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>城市PM2.5</title>
    <url>/2020/07/22/02web/ThreeJS/10%E7%B2%BE%E7%81%B5%E6%A8%A1%E5%9E%8B,%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/02%E5%9F%8E%E5%B8%82PM2.5/</url>
    <content><![CDATA[<h1 id="通过精灵模型实现"><a href="#通过精灵模型实现" class="headerlink" title="通过精灵模型实现"></a>通过精灵模型实现</h1><ul>
<li>加载圆圈图片作为精灵模型的贴图</li>
<li>创建组对象，放所有精灵对象的</li>
<li>加载json文件</li>
<li>循环数组，每次都创建精灵模型并贴图<ul>
<li>计算value大小控制圈大小</li>
<li>获取位置坐标，改变精灵坐标位置</li>
<li>精灵坐标放到组对象内</li>
</ul>
</li>
<li>最后不让相机移动，因为精灵模型始终时向屏幕外的</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载一个背景透明的圆形贴图，矩形精灵显示为圆形效果</span></span><br><span class="line"><span class="keyword">var</span> texture = <span class="keyword">new</span> THREE.TextureLoader().load(<span class="string">"sprite.png"</span>);</span><br><span class="line"><span class="comment">// 创建组对象，包含所有精灵对象</span></span><br><span class="line"><span class="keyword">let</span> group = <span class="keyword">new</span> THREE.Group();</span><br><span class="line"><span class="comment">// 文件加载对象</span></span><br><span class="line"><span class="keyword">var</span> loader = <span class="keyword">new</span> THREE.FileLoader().setResponseType(<span class="string">'json'</span>);</span><br><span class="line"><span class="comment">// 加载PM2.5数据</span></span><br><span class="line">loader.load(<span class="string">'数据.json'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//遍历数据</span></span><br><span class="line">  data.forEach(<span class="function"><span class="params">elem</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 精灵材质</span></span><br><span class="line">    <span class="keyword">var</span> spriteMaterial = <span class="keyword">new</span> THREE.SpriteMaterial(&#123;</span><br><span class="line">      map: texture, <span class="comment">//设置精灵纹理贴图</span></span><br><span class="line">      transparent: <span class="literal">true</span>,</span><br><span class="line">      opacity: <span class="number">0.5</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 创建精灵模型对象</span></span><br><span class="line">    <span class="keyword">var</span> sprite = <span class="keyword">new</span> THREE.Sprite(spriteMaterial);</span><br><span class="line">    group.add(sprite);</span><br><span class="line">    <span class="comment">// 控制精灵大小   使用PM2.5大小设置精灵模型的大小</span></span><br><span class="line">    <span class="comment">// 注意适当缩放pm2.5大小,以便得到更好的显示效果</span></span><br><span class="line">    <span class="keyword">var</span> k = elem.value / <span class="number">200</span></span><br><span class="line">    sprite.scale.set(k, k, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//获得城市坐标设置精灵模型对象的位置</span></span><br><span class="line">    sprite.position.set(elem.coordinate[<span class="number">0</span>], elem.coordinate[<span class="number">1</span>], <span class="number">0</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 中国城市坐标整体的几何中心不在坐标原点，需要适当的平移</span></span><br><span class="line">  group.position.set(<span class="number">-110</span>, <span class="number">-30</span>, <span class="number">0</span>);</span><br><span class="line">  scene.add(group);<span class="comment">//把精灵群组插入场景中</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建控件对象  相机对象camera作为参数   控件可以监听鼠标的变化，改变相机对象的属性</span></span><br><span class="line"><span class="keyword">var</span> controls = <span class="keyword">new</span> THREE.OrbitControls(camera,renderer.domElement);</span><br><span class="line"><span class="comment">// 禁止旋转操作</span></span><br><span class="line">controls.enableRotate = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p><img src="./01.png" alt="通过精灵模型实现"></p>
<h1 id="通过圆形几何体实现"><a href="#通过圆形几何体实现" class="headerlink" title="通过圆形几何体实现"></a>通过圆形几何体实现</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建组对象</span></span><br><span class="line"><span class="keyword">let</span> group = <span class="keyword">new</span> THREE.Group();</span><br><span class="line"><span class="comment">// 文件加载对象</span></span><br><span class="line"><span class="keyword">var</span> loader = <span class="keyword">new</span> THREE.FileLoader().setResponseType(<span class="string">'json'</span>);</span><br><span class="line"><span class="comment">// 加载PM2.5数据</span></span><br><span class="line">loader.load(<span class="string">'数据.json'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//遍历数据</span></span><br><span class="line">  data.forEach(<span class="function"><span class="params">elem</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123;</span><br><span class="line">      color: <span class="number">0xffff00</span>,</span><br><span class="line">      transparent: <span class="literal">true</span>,</span><br><span class="line">      opacity: <span class="number">0.5</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.CircleGeometry(<span class="number">0.5</span>, <span class="number">30</span>)</span><br><span class="line">    <span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material)</span><br><span class="line">    group.add(mesh);</span><br><span class="line">    <span class="comment">// 控制精灵大小   使用PM2.5大小设置精灵模型的大小</span></span><br><span class="line">    <span class="comment">// 注意适当缩放pm2.5大小,以便得到更好的显示效果</span></span><br><span class="line">    <span class="keyword">var</span> k = elem.value / <span class="number">200</span></span><br><span class="line">    mesh.scale.set(k, k, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//获得城市坐标设置精灵模型对象的位置</span></span><br><span class="line">    mesh.position.set(elem.coordinate[<span class="number">0</span>], elem.coordinate[<span class="number">1</span>], <span class="number">0</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 中国城市坐标整体的几何中心不在坐标原点，需要适当的平移</span></span><br><span class="line">  group.position.set(<span class="number">-110</span>, <span class="number">-30</span>, <span class="number">0</span>);</span><br><span class="line">  scene.add(group); <span class="comment">//把精灵群组插入场景中</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="./02.png" alt="通过圆形几何体实现"></p>
<h1 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h1><p>如果相机都可以旋转，两个模型从侧面观察如下</p>
<p><img src="./03.png" alt="通过圆形几何体实现"><br><img src="./04.png" alt="通过圆形几何体实现"></p>
<p>一个所有点都向外，一个看到点侧面</p>
]]></content>
  </entry>
  <entry>
    <title>下雨场景</title>
    <url>/2020/07/22/02web/ThreeJS/10%E7%B2%BE%E7%81%B5%E6%A8%A1%E5%9E%8B,%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/03%E4%B8%8B%E9%9B%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<h1 id="空中随机生成雨滴"><a href="#空中随机生成雨滴" class="headerlink" title="空中随机生成雨滴"></a>空中随机生成雨滴</h1><ul>
<li>加载雨滴贴图</li>
<li>循环创建400给精灵模型</li>
<li>给每个精灵模型贴图</li>
<li>设置每个精灵模型的大小</li>
<li>(200 * k1, 200*k3, 200 * k2)来限制这些精灵模型的位置</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载雨滴理贴图</span></span><br><span class="line"><span class="keyword">var</span> textureTree = <span class="keyword">new</span> THREE.TextureLoader().load(<span class="string">"rain.png"</span>);</span><br><span class="line"><span class="comment">// 创建一个组表示所有的雨滴</span></span><br><span class="line"><span class="keyword">var</span> group = <span class="keyword">new</span> THREE.Group();</span><br><span class="line"><span class="comment">// 批量创建表示雨滴的精灵模型</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">400</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> spriteMaterial = <span class="keyword">new</span> THREE.SpriteMaterial(&#123;</span><br><span class="line">    map:textureTree,<span class="comment">//设置精灵纹理贴图</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 创建精灵模型对象</span></span><br><span class="line">  <span class="keyword">var</span> sprite = <span class="keyword">new</span> THREE.Sprite(spriteMaterial);</span><br><span class="line">  group.add(sprite);</span><br><span class="line">  <span class="comment">// 控制精灵大小,</span></span><br><span class="line">  sprite.scale.set(<span class="number">8</span>, <span class="number">10</span>, <span class="number">1</span>); <span class="comment">//// 只需要设置x、y两个分量就可以</span></span><br><span class="line">  <span class="keyword">var</span> k1 = <span class="built_in">Math</span>.random() - <span class="number">0.5</span>;</span><br><span class="line">  <span class="keyword">var</span> k2 = <span class="built_in">Math</span>.random() - <span class="number">0.5</span>;</span><br><span class="line">  <span class="keyword">var</span> k3 = <span class="built_in">Math</span>.random() - <span class="number">0.5</span>;</span><br><span class="line">  <span class="comment">// 设置精灵模型位置，在整个空间上上随机分布</span></span><br><span class="line">  sprite.position.set(<span class="number">200</span> * k1, <span class="number">200</span>*k3, <span class="number">200</span> * k2)</span><br><span class="line">&#125;</span><br><span class="line">scene.add(group);<span class="comment">//雨滴群组插入场景中</span></span><br><span class="line"><span class="comment">// 坐标系辅助显示</span></span><br><span class="line"><span class="keyword">var</span> axesHelper = <span class="keyword">new</span> THREE.AxesHelper(<span class="number">200</span>);</span><br><span class="line">scene.add(axesHelper);</span><br></pre></td></tr></table></figure>

<p><img src="./01.png" alt="空中随机生成雨滴"></p>
<h1 id="控制雨滴下落"><a href="#控制雨滴下落" class="headerlink" title="控制雨滴下落"></a>控制雨滴下落</h1><ul>
<li>循环雨滴组,让每个雨滴都在Y方向-1</li>
<li>当减少到0时，重新设置为200</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 渲染函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 每次渲染遍历雨滴群组，刷新频率30~60FPS，两帧时间间隔16.67ms~33.33ms</span></span><br><span class="line">  <span class="comment">// 每次渲染都会更新雨滴的位置，进而产生动画效果</span></span><br><span class="line">  group.children.forEach(<span class="function"><span class="params">sprite</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 雨滴的y坐标每次减1</span></span><br><span class="line">    sprite.position.y -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (sprite.position.y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果雨滴落到地面，重置y，从新下落</span></span><br><span class="line">      sprite.position.y = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  renderer.render(scene, camera); <span class="comment">//执行渲染操作</span></span><br><span class="line">  requestAnimationFrame(render);<span class="comment">//请求再次执行渲染函数render，渲染下一帧</span></span><br><span class="line">&#125;</span><br><span class="line">render();</span><br></pre></td></tr></table></figure>

<p><img src="./02.gif" alt="空中随机生成雨滴"></p>
<h1 id="站在雨中的效果"><a href="#站在雨中的效果" class="headerlink" title="站在雨中的效果"></a>站在雨中的效果</h1><p>使用透视投影相机PerspectiveCamera(近大远小效果)，同时把透视投影相机对象的位置设置在雨粒子系统里面而不是雨粒子系统的外面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**透视投影相机对象*/</span></span><br><span class="line"><span class="keyword">var</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera(<span class="number">60</span>, width / height, <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">camera.position.set(<span class="number">292</span>, <span class="number">109</span>, <span class="number">268</span>);<span class="comment">//设置相机位置</span></span><br></pre></td></tr></table></figure>

<p><img src="./03.gif" alt="空中随机生成雨滴"></p>
]]></content>
  </entry>
  <entry>
    <title>解析外部模型的的帧动画</title>
    <url>/2020/07/22/02web/ThreeJS/11%E5%B8%A7%E5%8A%A8%E7%94%BB/02%E8%A7%A3%E6%9E%90%E5%A4%96%E9%83%A8%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%9A%84%E5%B8%A7%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<h1 id="外部数据"><a href="#外部数据" class="headerlink" title="外部数据"></a>外部数据</h1><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"object": &#123;</span><br><span class="line">  <span class="comment">// 绑定动画的模型名称Box</span></span><br><span class="line">  "name": "Box",</span><br><span class="line">...</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 动画数据</span></span><br><span class="line">"animations": [&#123;</span><br><span class="line">  "name": "default",</span><br><span class="line">  "fps": 24,</span><br><span class="line">  "tracks": [</span><br><span class="line">    <span class="comment">// 位置变化关键帧</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"vector3"</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"Box.position"</span>,</span><br><span class="line">    <span class="attr">"keys"</span>: [&#123;</span><br><span class="line">      <span class="attr">"value"</span>: [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">      <span class="attr">"time"</span>: <span class="number">0</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      <span class="attr">"value"</span>: [<span class="number">-100</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">      <span class="attr">"time"</span>: <span class="number">50</span></span><br><span class="line">    &#125;,...]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 角度变化关键帧</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"quaternion"</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"Box.quaternion"</span>,</span><br><span class="line">    <span class="attr">"keys"</span>: [&#123;</span><br><span class="line">      <span class="attr">"value"</span>: [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">      <span class="attr">"time"</span>: <span class="number">0</span></span><br><span class="line">    &#125;,...]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 颜色变化关键帧</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"color"</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"Box.material.color"</span>,</span><br><span class="line">    <span class="attr">"keys"</span>: [&#123;</span><br><span class="line">      <span class="attr">"value"</span>: [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">      <span class="attr">"time"</span>: <span class="number">20</span></span><br><span class="line">    &#125;, ...]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<h1 id="播放模型帧动画"><a href="#播放模型帧动画" class="headerlink" title="播放模型帧动画"></a>播放模型帧动画</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过ObjectLoader加载模型文件model.json</span></span><br><span class="line"><span class="keyword">var</span> loader = <span class="keyword">new</span> THREE.ObjectLoader();</span><br><span class="line"><span class="keyword">var</span> mixer = <span class="literal">null</span>; <span class="comment">//声明一个混合器变量</span></span><br><span class="line"><span class="comment">// 加载文件返回一个对象obj</span></span><br><span class="line">loader.load(<span class="string">"model.json"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  obj.scale.set(<span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>);<span class="comment">//缩放加载的模型</span></span><br><span class="line">  scene.add(obj);</span><br><span class="line">  <span class="comment">// obj作为混合器的参数，可以播放obj包含的帧动画数据</span></span><br><span class="line">  mixer = <span class="keyword">new</span> THREE.AnimationMixer(obj);</span><br><span class="line">  <span class="comment">// obj.animations[0]：获得剪辑clip对象</span></span><br><span class="line">  <span class="comment">// // 剪辑clip作为参数，通过混合器clipAction方法返回一个操作对象AnimationAction</span></span><br><span class="line">  <span class="keyword">var</span> AnimationAction = mixer.clipAction(obj.animations[<span class="number">0</span>]);</span><br><span class="line">  AnimationAction.play();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="加载动画"><a href="#加载动画" class="headerlink" title="加载动画"></a>加载动画</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个时钟对象Clock</span></span><br><span class="line"><span class="keyword">var</span> clock = <span class="keyword">new</span> THREE.Clock();</span><br><span class="line"><span class="comment">// 渲染函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  renderer.render(scene, camera); <span class="comment">//执行渲染操作</span></span><br><span class="line">  requestAnimationFrame(render); <span class="comment">//请求再次执行渲染函数render，渲染下一帧</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(mixer!==<span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="comment">//clock.getDelta()方法获得两帧的时间间隔</span></span><br><span class="line">    <span class="comment">// 更新混合器相关的时间</span></span><br><span class="line">    mixer.update(clock.getDelta());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">render();</span><br></pre></td></tr></table></figure>

<h1 id="播放设置"><a href="#播放设置" class="headerlink" title="播放设置"></a>播放设置</h1><p>可以通过操作AnimationAction的相关属性设置播放效果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不循环播放(默认是循环播放)</span></span><br><span class="line">AnimationAction.loop = THREE.LoopOnce</span><br><span class="line"></span><br><span class="line"><span class="comment">//暂停在最后一帧播放的状态</span></span><br><span class="line">AnimationAction.clampWhenFinished=<span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>编辑关键帧并解析播放</title>
    <url>/2020/07/22/02web/ThreeJS/11%E5%B8%A7%E5%8A%A8%E7%94%BB/01%E7%BC%96%E8%BE%91%E5%85%B3%E9%94%AE%E5%B8%A7%E5%B9%B6%E8%A7%A3%E6%9E%90%E6%92%AD%E6%94%BE/</url>
    <content><![CDATA[<p><img src="./01.png" alt="编辑关键帧并解析播放"></p>
<ul>
<li>使用关键帧KeyframeTrack和剪辑AnimationClip编写一个关键帧动画</li>
<li>然后调用操作AnimationAction、混合器AnimationMixer播放编写好的关键帧动画</li>
</ul>
<h1 id="创建两个用于动画的网格模型"><a href="#创建两个用于动画的网格模型" class="headerlink" title="创建两个用于动画的网格模型"></a>创建两个用于动画的网格模型</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> group = <span class="keyword">new</span> THREE.Group(); <span class="comment">//作为网格模型的父对象</span></span><br><span class="line"><span class="comment">// 网格模型1</span></span><br><span class="line"><span class="keyword">var</span> geometry1 = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">40</span>, <span class="number">6</span>, <span class="number">6</span>); <span class="comment">//长方体</span></span><br><span class="line"><span class="keyword">var</span> material1 = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x0000ff</span></span><br><span class="line">&#125;); <span class="comment">//材质对象Material</span></span><br><span class="line"><span class="keyword">var</span> mesh1 = <span class="keyword">new</span> THREE.Mesh(geometry1, material1); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">mesh1.name = <span class="string">"Box"</span>; <span class="comment">//网格模型命名</span></span><br><span class="line">group.add(mesh1); <span class="comment">//网格模型添加到组中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 网格模型2</span></span><br><span class="line"><span class="keyword">var</span> geometry2 = <span class="keyword">new</span> THREE.SphereGeometry(<span class="number">10</span>, <span class="number">25</span>, <span class="number">25</span>); <span class="comment">//球体</span></span><br><span class="line"><span class="keyword">var</span> material2 = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">  color: <span class="number">0xff00ff</span></span><br><span class="line">&#125;); <span class="comment">//材质对象Material</span></span><br><span class="line"><span class="keyword">var</span> mesh2 = <span class="keyword">new</span> THREE.Mesh(geometry2, material2); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">mesh2.name = <span class="string">"Sphere"</span>; <span class="comment">//网格模型命名</span></span><br><span class="line">group.add(mesh2); <span class="comment">//网格模型添加到组中</span></span><br><span class="line">scene.add(group); <span class="comment">//组添加到场景中中</span></span><br></pre></td></tr></table></figure>

<h1 id="编辑关键帧"><a href="#编辑关键帧" class="headerlink" title="编辑关键帧"></a>编辑关键帧</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建名为Box对象的关键帧数据</span></span><br><span class="line"><span class="keyword">var</span> times = [<span class="number">0</span>, <span class="number">10</span>]; <span class="comment">//关键帧时间数组，离散的时间点序列</span></span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">150</span>, <span class="number">0</span>, <span class="number">0</span>]; <span class="comment">//与时间点对应的值组成的数组</span></span><br><span class="line"><span class="comment">// 创建位置关键帧对象：0时刻对应位置0, 0, 0   10时刻对应位置150, 0, 0</span></span><br><span class="line"><span class="keyword">var</span> posTrack = <span class="keyword">new</span> THREE.KeyframeTrack(<span class="string">'Box.position'</span>, times, values);</span><br><span class="line"><span class="comment">// 创建颜色关键帧对象：10时刻对应颜色1, 0, 0   20时刻对应颜色0, 0, 1</span></span><br><span class="line"><span class="keyword">var</span> colorKF = <span class="keyword">new</span> THREE.KeyframeTrack(<span class="string">'Box.material.color'</span>, [<span class="number">10</span>, <span class="number">20</span>], [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]);</span><br><span class="line"><span class="comment">// 创建名为Sphere对象的关键帧数据  从0~20时间段，尺寸scale缩放3倍</span></span><br><span class="line"><span class="keyword">var</span> scaleTrack = <span class="keyword">new</span> THREE.KeyframeTrack(<span class="string">'Sphere.scale'</span>, [<span class="number">0</span>, <span class="number">20</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure>
<h1 id="关键帧剪辑"><a href="#关键帧剪辑" class="headerlink" title="关键帧剪辑"></a>关键帧剪辑</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// duration决定了默认的播放时间，一般取所有帧动画的最大时间</span></span><br><span class="line"><span class="comment">// duration偏小，帧动画数据无法播放完，偏大，播放完帧动画会继续空播放</span></span><br><span class="line"><span class="keyword">var</span> duration = <span class="number">20</span>;</span><br><span class="line"><span class="comment">// 多个帧动画作为元素创建一个剪辑clip对象，命名"default"，持续时间20</span></span><br><span class="line"><span class="keyword">var</span> clip = <span class="keyword">new</span> THREE.AnimationClip(<span class="string">"default"</span>, duration, [posTrack, colorKF, scaleTrack]);</span><br></pre></td></tr></table></figure>

<h1 id="播放关键帧动画"><a href="#播放关键帧动画" class="headerlink" title="播放关键帧动画"></a>播放关键帧动画</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// group作为混合器的参数，可以播放group中所有子对象的帧动画</span></span><br><span class="line"><span class="keyword">var</span> mixer = <span class="keyword">new</span> THREE.AnimationMixer(group);</span><br><span class="line"><span class="comment">// 剪辑clip作为参数，通过混合器clipAction方法返回一个操作对象AnimationAction</span></span><br><span class="line"><span class="keyword">var</span> AnimationAction = mixer.clipAction(clip);</span><br><span class="line"><span class="comment">//通过操作Action设置播放方式</span></span><br><span class="line">AnimationAction.timeScale = <span class="number">20</span>;<span class="comment">//默认1，可以调节播放速度</span></span><br><span class="line"><span class="comment">// AnimationAction.loop = THREE.LoopOnce; //不循环播放</span></span><br><span class="line">AnimationAction.play();<span class="comment">//开始播放</span></span><br></pre></td></tr></table></figure>

<h1 id="渲染动画"><a href="#渲染动画" class="headerlink" title="渲染动画"></a>渲染动画</h1><ul>
<li>播放关键帧动画的时候，注意在渲染函数render()中执行mixer.update(渲染间隔时间)</li>
<li>告诉帧动画系统Threejs两次渲染的时间间隔</li>
<li>获得时间间隔可以通过Threejs提供的一个时钟类Clock实现</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个时钟对象Clock</span></span><br><span class="line"><span class="keyword">var</span> clock = <span class="keyword">new</span> THREE.Clock();</span><br><span class="line"><span class="comment">// 渲染函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  renderer.render(scene, camera); <span class="comment">//执行渲染操作</span></span><br><span class="line">  requestAnimationFrame(render); <span class="comment">//请求再次执行渲染函数render，渲染下一帧</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//clock.getDelta()方法获得两帧的时间间隔</span></span><br><span class="line">  <span class="comment">// 更新混合器相关的时间</span></span><br><span class="line">  mixer.update(clock.getDelta());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>播放设置</title>
    <url>/2020/07/23/02web/ThreeJS/11%E5%B8%A7%E5%8A%A8%E7%94%BB/03%E6%92%AD%E6%94%BE%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p>可以通过剪辑AnimationClip、操作AnimationAction、混合器AnimationMixer完成一些播放效果。</p>
<h1 id="播放-暂停-paused属性"><a href="#播放-暂停-paused属性" class="headerlink" title="播放/暂停(.paused属性)"></a>播放/暂停(.paused属性)</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">"pause()"</span> type=<span class="string">"button"</span> style=<span class="string">"position: absolute;padding: 10px;"</span>&gt;暂停/继续&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 暂停继续播放函数</span></span><br><span class="line"><span class="regexp">  function pause() &#123;</span></span><br><span class="line"><span class="regexp">    if (AnimationAction.paused) &#123;</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ 如果是播放状态，设置为暂停状态</span></span><br><span class="line"><span class="regexp">      AnimationAction.paused = false;</span></span><br><span class="line"><span class="regexp">    &#125; else &#123;</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ 如果是暂停状态，设置为播放状态</span></span><br><span class="line"><span class="regexp">      AnimationAction.paused = true;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<h1 id="播放clip特定时间段"><a href="#播放clip特定时间段" class="headerlink" title="播放clip特定时间段"></a>播放clip特定时间段</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 播放编辑好的关键帧数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mixer = <span class="keyword">new</span> THREE.AnimationMixer(mesh); <span class="comment">//创建混合器</span></span><br><span class="line"><span class="keyword">var</span> AnimationAction = mixer.clipAction(clip); <span class="comment">//返回动画操作对象</span></span><br><span class="line"><span class="comment">// AnimationAction.timeScale = 5; //默认1，可以调节播放速度</span></span><br><span class="line">AnimationAction.loop = THREE.LoopOnce; <span class="comment">//不循环播放</span></span><br><span class="line">AnimationAction.clampWhenFinished = <span class="literal">true</span>; <span class="comment">//暂停在最后一帧播放的状态</span></span><br><span class="line"><span class="comment">// 设置播放区间10~18   关键帧数据总时间是20</span></span><br><span class="line">AnimationAction.time = <span class="number">10</span>; <span class="comment">//操作对象设置开始播放时间</span></span><br><span class="line">clip.duration = <span class="number">18</span>;<span class="comment">//剪辑对象设置播放结束时间</span></span><br><span class="line">AnimationAction.play(); <span class="comment">//开始播放</span></span><br></pre></td></tr></table></figure>

<h2 id="定位在某个时间点"><a href="#定位在某个时间点" class="headerlink" title="定位在某个时间点"></a>定位在某个时间点</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开始结束时间设置为一样，相当于播放时间为0，直接跳转到时间点对应的状态</span></span><br><span class="line">AnimationAction.time = <span class="number">10</span>; <span class="comment">//操作对象设置开始播放时间</span></span><br><span class="line">clip.duration = AnimationAction.time;<span class="comment">//剪辑对象设置播放结束时间</span></span><br></pre></td></tr></table></figure>

<h1 id="快进-按钮递增时间点"><a href="#快进-按钮递增时间点" class="headerlink" title="快进(按钮递增时间点)"></a>快进(按钮递增时间点)</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">"pos()"</span> type=<span class="string">"button"</span> style=<span class="string">"position: absolute;padding: 10px;"</span>&gt;时间递增&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 时间点设置函数</span></span><br><span class="line"><span class="regexp">  function pos() &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 开始结束时间设置为一样，相当于播放时间为0，直接跳转到时间点对应的状态</span></span><br><span class="line"><span class="regexp">    AnimationAction.time += 2; /</span><span class="regexp">/操作对象设置开始播放时间</span></span><br><span class="line"><span class="regexp">    clip.duration = AnimationAction.time;/</span><span class="regexp">/剪辑对象设置播放结束时间</span></span><br><span class="line"><span class="regexp">    AnimationAction.play(); /</span><span class="regexp">/开始播放</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>加载外部变形动画</title>
    <url>/2020/07/27/02web/ThreeJS/12%E9%AA%A8%E9%AA%BC,%E5%8F%98%E5%BD%A2%E5%8A%A8%E7%94%BB/04%E5%8A%A0%E8%BD%BD%E5%A4%96%E9%83%A8%E5%8F%98%E5%BD%A2%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<h1 id="加载静态文件"><a href="#加载静态文件" class="headerlink" title="加载静态文件"></a>加载静态文件</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过加载器JSONLoader加载变形动画模型文件./人/umich_ucs.json</span></span><br><span class="line"><span class="keyword">var</span> loader = <span class="keyword">new</span> THREE.JSONLoader();</span><br><span class="line">loader.load(<span class="string">"./人/umich_ucs.json"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">geometry, materials</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log(geometry);</span></span><br><span class="line">  <span class="comment">// console.log(materials);</span></span><br><span class="line">  <span class="comment">// 通过平均面法线来计算顶点法线，效果更光滑</span></span><br><span class="line">  geometry.computeVertexNormals();</span><br><span class="line">  <span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, materials[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">// 材质对象开启渲染目标</span></span><br><span class="line">  mesh.material.morphTargets = <span class="literal">true</span></span><br><span class="line">  mesh.rotateX(-<span class="built_in">Math</span>.PI / <span class="number">2</span>);</span><br><span class="line">  mesh.position.y = <span class="number">-50</span>;</span><br><span class="line">  scene.add(mesh); <span class="comment">//插入到场景中</span></span><br><span class="line">  <span class="comment">// 查看变形目标数据</span></span><br><span class="line">  <span class="built_in">console</span>.log(geometry.morphTargets);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 变胖(调整0-1之间可以改变胖瘦变化)</span></span><br><span class="line"><span class="comment">// mesh.morphTargetInfluences[0] = 1;</span></span><br><span class="line"><span class="comment">// 变瘦</span></span><br><span class="line">mesh.morphTargetInfluences[<span class="number">4</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h1 id="加载动画"><a href="#加载动画" class="headerlink" title="加载动画"></a>加载动画</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> loader = <span class="keyword">new</span> THREE.JSONLoader(); <span class="comment">//创建加载器</span></span><br><span class="line"><span class="keyword">var</span> mixer = <span class="literal">null</span>; <span class="comment">//声明一个网格模型变量</span></span><br><span class="line">loader.load(<span class="string">"./鸟/flamingo.json"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">geometry</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log(geometry);</span></span><br><span class="line">  <span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshPhongMaterial(&#123;</span><br><span class="line">    morphTargets: <span class="literal">true</span>,</span><br><span class="line">    vertexColors: THREE.FaceColors,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 通过平均面法线来计算顶点法线，效果更光滑</span></span><br><span class="line">  geometry.computeVertexNormals();</span><br><span class="line">  <span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material);</span><br><span class="line">  scene.add(mesh); <span class="comment">//插入到场景中</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个混合器，播放网格模型模型的变形动画</span></span><br><span class="line">  mixer = <span class="keyword">new</span> THREE.AnimationMixer(mesh);</span><br><span class="line">  <span class="comment">// 通过该方法把多个变形目标自动化生成剪辑对象clip</span></span><br><span class="line">  <span class="comment">// 30是fps，影响动画速度</span></span><br><span class="line">  <span class="keyword">var</span> clip = THREE.AnimationClip.CreateFromMorphTargetSequence(<span class="string">'default'</span>, geometry.morphTargets, <span class="number">30</span>);</span><br><span class="line">  <span class="keyword">var</span> AnimationAction=mixer.clipAction(clip);</span><br><span class="line">  AnimationAction.timeScale = <span class="number">0.5</span>; <span class="comment">//默认1，可以调节播放速度</span></span><br><span class="line">  <span class="comment">// AnimationAction.loop = THREE.LoopOnce; //不循环播放</span></span><br><span class="line">  <span class="comment">// AnimationAction.clampWhenFinished=true;//暂停在最后一帧播放的状态</span></span><br><span class="line">  AnimationAction.play();<span class="comment">//播放动画</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个时钟对象Clock</span></span><br><span class="line"><span class="keyword">var</span> clock = <span class="keyword">new</span> THREE.Clock();</span><br><span class="line"><span class="comment">// 渲染函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  renderer.render(scene, camera); <span class="comment">//执行渲染操作</span></span><br><span class="line">  requestAnimationFrame(render); <span class="comment">//请求再次执行渲染函数render，渲染下一帧</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mixer !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//clock.getDelta()方法获得两帧的时间间隔</span></span><br><span class="line">    <span class="comment">// 更新混合器相关的时间</span></span><br><span class="line">    mixer.update(clock.getDelta());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">render();</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>骨骼动画原理</title>
    <url>/2020/07/27/02web/ThreeJS/12%E9%AA%A8%E9%AA%BC,%E5%8F%98%E5%BD%A2%E5%8A%A8%E7%94%BB/01%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<ul>
<li>人体的骨骼运动，骨骼运动会带动肌肉和人体皮肤的空间移动和表面变化</li>
<li>Threejs骨骼动画需要通过骨骼网格模型类SkinnedMesh来实现</li>
<li>一般来说骨骼动画模型都是3D美术创建，然后程序员通过threejs引擎加载解析</li>
</ul>
<h1 id="相关类"><a href="#相关类" class="headerlink" title="相关类"></a>相关类</h1><ul>
<li>骨头关节Bone</li>
<li>骨骼网格模型SkinnedMesh</li>
<li>骨架对象Skeleton</li>
</ul>
<p><img src="./01.png" alt="相关类"></p>
<h2 id="Bone"><a href="#Bone" class="headerlink" title="Bone"></a>Bone</h2><ul>
<li>通过Bone类可以实例化一个骨关节对象</li>
<li>通过多个骨关节对象可以构成一个骨骼层级系统</li>
<li>Bone基类是Object3D,可以通过add方法给一个骨关节对象Bone添加一个子骨关节Bone</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Bone1 = <span class="keyword">new</span> THREE.Bone(); <span class="comment">//关节1，用来作为根关节</span></span><br><span class="line"><span class="keyword">var</span> Bone2 = <span class="keyword">new</span> THREE.Bone(); <span class="comment">//关节2</span></span><br><span class="line"><span class="keyword">var</span> Bone3 = <span class="keyword">new</span> THREE.Bone(); <span class="comment">//关节3</span></span><br><span class="line"><span class="comment">// 设置关节父子关系   多个骨头关节构成一个树结构</span></span><br><span class="line">Bone1.add(Bone2);</span><br><span class="line">Bone2.add(Bone3);</span><br><span class="line"><span class="comment">// 设置关节之间的相对位置</span></span><br><span class="line"><span class="comment">//根关节Bone1默认位置是(0,0,0)</span></span><br><span class="line">Bone2.position.y = <span class="number">60</span>; <span class="comment">//Bone2相对父对象Bone1位置</span></span><br><span class="line">Bone3.position.y = <span class="number">40</span>; <span class="comment">//Bone3相对父对象Bone2位置</span></span><br></pre></td></tr></table></figure>

<h2 id="骨架Skeleton"><a href="#骨架Skeleton" class="headerlink" title="骨架Skeleton"></a>骨架Skeleton</h2><p>Threejs通过Skeleton类可以把所有骨关节对象Bone包含进来。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 所有Bone对象插入到Skeleton中，全部设置为.bones属性的元素</span></span><br><span class="line"><span class="keyword">var</span> skeleton = <span class="keyword">new</span> THREE.Skeleton([Bone1, Bone2, Bone3]); <span class="comment">//创建骨骼系统</span></span><br><span class="line"><span class="comment">// 查看.bones属性中所有骨关节Bone</span></span><br><span class="line"><span class="built_in">console</span>.log(skeleton.bones);</span><br><span class="line"><span class="comment">// 返回所有关节的世界坐标</span></span><br><span class="line">skeleton.bones.forEach(<span class="function"><span class="params">elem</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(elem.getWorldPosition(<span class="keyword">new</span> THREE.Vector3()));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Geometry-skinWeights和-skinIndices属性"><a href="#Geometry-skinWeights和-skinIndices属性" class="headerlink" title="Geometry(.skinWeights和.skinIndices属性)"></a>Geometry(.skinWeights和.skinIndices属性)</h2><ul>
<li>.skinWeights和.skinIndices主要作用是用来设置几何体的顶点位置是如何受骨关节运动影响的</li>
<li>.skinWeights的字面意思就是设置骨骼蒙皮的权重</li>
<li>.skinIndices蒙皮索引属性</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个圆柱几何体，高度120，顶点坐标y分量范围[-60,60]</span></span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.CylinderGeometry(<span class="number">5</span>, <span class="number">10</span>, <span class="number">120</span>, <span class="number">50</span>, <span class="number">300</span>);</span><br><span class="line">geometry.translate(<span class="number">0</span>, <span class="number">60</span>, <span class="number">0</span>); <span class="comment">//平移后，y分量范围[0,120]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span>, geometry.vertices); <span class="comment">//控制台查看顶点坐标</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置几何体对象Geometry的蒙皮索引skinIndices、权重skinWeights属性</span></span><br><span class="line"><span class="comment"> * 实现一个模拟腿部骨骼运动的效果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//遍历几何体顶点，为每一个顶点设置蒙皮索引、权重属性</span></span><br><span class="line"><span class="comment">//根据y来分段，0~60一段、60~100一段、100~120一段</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; geometry.vertices.length; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> vertex = geometry.vertices[i]; <span class="comment">//第i个顶点</span></span><br><span class="line">  <span class="keyword">if</span> (vertex.y &lt;= <span class="number">60</span>) &#123;</span><br><span class="line">    <span class="comment">// 设置每个顶点蒙皮索引属性  受根关节Bone1影响</span></span><br><span class="line">    geometry.skinIndices.push(<span class="keyword">new</span> THREE.Vector4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 设置每个顶点蒙皮权重属性</span></span><br><span class="line">    <span class="comment">// 影响该顶点关节Bone1对应权重是1-vertex.y/60</span></span><br><span class="line">    geometry.skinWeights.push(<span class="keyword">new</span> THREE.Vector4(<span class="number">1</span> - vertex.y / <span class="number">60</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">60</span> &lt; vertex.y &amp;&amp; vertex.y &lt;= <span class="number">60</span> + <span class="number">40</span>) &#123;</span><br><span class="line">    <span class="comment">// Vector4(1, 0, 0, 0)表示对应顶点受关节Bone2影响</span></span><br><span class="line">    geometry.skinIndices.push(<span class="keyword">new</span> THREE.Vector4(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 影响该顶点关节Bone2对应权重是1-(vertex.y-60)/40</span></span><br><span class="line">    geometry.skinWeights.push(<span class="keyword">new</span> THREE.Vector4(<span class="number">1</span> - (vertex.y - <span class="number">60</span>) / <span class="number">40</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">60</span> + <span class="number">40</span> &lt; vertex.y &amp;&amp; vertex.y &lt;= <span class="number">60</span> + <span class="number">40</span> + <span class="number">20</span>) &#123;</span><br><span class="line">    <span class="comment">// Vector4(2, 0, 0, 0)表示对应顶点受关节Bone3影响</span></span><br><span class="line">    geometry.skinIndices.push(<span class="keyword">new</span> THREE.Vector4(<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 影响该顶点关节Bone3对应权重是1-(vertex.y-100)/20</span></span><br><span class="line">    geometry.skinWeights.push(<span class="keyword">new</span> THREE.Vector4(<span class="number">1</span> - (vertex.y - <span class="number">100</span>) / <span class="number">20</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="皮肤顶点权重属性-skinWeights"><a href="#皮肤顶点权重属性-skinWeights" class="headerlink" title="皮肤顶点权重属性.skinWeights"></a>皮肤顶点权重属性.skinWeights</h3><ul>
<li>.skinWeights表示的是几何体顶点权重数据</li>
<li>当使用骨骼动画网格模型SkinnedMesh的时候, 每个顶点最多可以有4个骨关节Bone影响它</li>
<li>.skinWeights属性是一个权重值数组，对应于几何体中顶点的顺序。 <ul>
<li>例如，第一个skinWeight将对应于几何体中的第一个顶点. </li>
<li>由于每个顶点可以被4个骨关节Bone修改，因此使用四维向量对象Vector4表示一个顶点的权重.</li>
</ul>
</li>
<li>四维向量Vector4每个分量的值通常应在0和1之间。<ul>
<li>当设置为0时，骨关节Bone变换将不起作用；</li>
<li>设置为0.5时，将产生50％的影响；</li>
<li>设置为100％时，会产生100％的影响。 </li>
</ul>
</li>
<li>如果只有一个骨关节Bone与顶点关联，那么你只需要考虑设置四维向量Vector4的第一个分量，其余分量的可以忽略并设置为0.</li>
</ul>
<h3 id="顶点索引属性-skinIndices"><a href="#顶点索引属性-skinIndices" class="headerlink" title="顶点索引属性.skinIndices"></a>顶点索引属性.skinIndices</h3><ul>
<li>顶点索引属性.skinIndices就像skinWeights属性一样，</li>
<li>skinIndices的值对应几何体的顶点. 每个顶点最多可以有4个与之关联的骨关节Bone</li>
</ul>
<h2 id="骨骼材质对象MeshPhongMaterial"><a href="#骨骼材质对象MeshPhongMaterial" class="headerlink" title="骨骼材质对象MeshPhongMaterial"></a>骨骼材质对象MeshPhongMaterial</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 材质对象</span></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshPhongMaterial(&#123;</span><br><span class="line">  skinning: <span class="literal">true</span>, <span class="comment">//允许蒙皮动画</span></span><br><span class="line">  <span class="comment">// wireframe:true,</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>

<h2 id="骨骼网格模型SkinnedMesh"><a href="#骨骼网格模型SkinnedMesh" class="headerlink" title="骨骼网格模型SkinnedMesh"></a>骨骼网格模型SkinnedMesh</h2><ul>
<li>骨骼网格模型SkinnedMesh的基类是普通网格模型Mesh</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> SkinnedMesh = <span class="keyword">new</span> THREE.SkinnedMesh(geometry, material);</span><br><span class="line">SkinnedMesh.position.set(<span class="number">50</span>, <span class="number">120</span>, <span class="number">50</span>); <span class="comment">//设置网格模型位置</span></span><br><span class="line">SkinnedMesh.rotateX(<span class="built_in">Math</span>.PI); <span class="comment">//旋转网格模型</span></span><br><span class="line">scene.add(SkinnedMesh); <span class="comment">//网格模型添加到场景中</span></span><br><span class="line"><span class="comment">//骨骼关联网格模型</span></span><br><span class="line">SkinnedMesh.add(Bone1); <span class="comment">//根骨头关节添加到网格模型</span></span><br><span class="line">SkinnedMesh.bind(skeleton); <span class="comment">//网格模型绑定到骨骼系统</span></span><br></pre></td></tr></table></figure>

<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建骨骼网格模型SkinnedMesh</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 创建一个圆柱几何体，高度120，顶点坐标y分量范围[-60,60]</span></span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.CylinderGeometry(<span class="number">5</span>, <span class="number">10</span>, <span class="number">120</span>, <span class="number">50</span>, <span class="number">300</span>);</span><br><span class="line">geometry.translate(<span class="number">0</span>, <span class="number">60</span>, <span class="number">0</span>); <span class="comment">//平移后，y分量范围[0,120]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span>, geometry.vertices); <span class="comment">//控制台查看顶点坐标</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置几何体对象Geometry的蒙皮索引skinIndices、权重skinWeights属性</span></span><br><span class="line"><span class="comment"> * 实现一个模拟腿部骨骼运动的效果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//遍历几何体顶点，为每一个顶点设置蒙皮索引、权重属性</span></span><br><span class="line"><span class="comment">//根据y来分段，0~60一段、60~100一段、100~120一段</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; geometry.vertices.length; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> vertex = geometry.vertices[i]; <span class="comment">//第i个顶点</span></span><br><span class="line">  <span class="keyword">if</span> (vertex.y &lt;= <span class="number">60</span>) &#123;</span><br><span class="line">    <span class="comment">// 设置每个顶点蒙皮索引属性  受根关节Bone1影响</span></span><br><span class="line">    geometry.skinIndices.push(<span class="keyword">new</span> THREE.Vector4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 设置每个顶点蒙皮权重属性</span></span><br><span class="line">    <span class="comment">// 影响该顶点关节Bone1对应权重是1-vertex.y/60</span></span><br><span class="line">    geometry.skinWeights.push(<span class="keyword">new</span> THREE.Vector4(<span class="number">1</span> - vertex.y / <span class="number">60</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">60</span> &lt; vertex.y &amp;&amp; vertex.y &lt;= <span class="number">60</span> + <span class="number">40</span>) &#123;</span><br><span class="line">    <span class="comment">// Vector4(1, 0, 0, 0)表示对应顶点受关节Bone2影响</span></span><br><span class="line">    geometry.skinIndices.push(<span class="keyword">new</span> THREE.Vector4(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 影响该顶点关节Bone2对应权重是1-(vertex.y-60)/40</span></span><br><span class="line">    geometry.skinWeights.push(<span class="keyword">new</span> THREE.Vector4(<span class="number">1</span> - (vertex.y - <span class="number">60</span>) / <span class="number">40</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">60</span> + <span class="number">40</span> &lt; vertex.y &amp;&amp; vertex.y &lt;= <span class="number">60</span> + <span class="number">40</span> + <span class="number">20</span>) &#123;</span><br><span class="line">    <span class="comment">// Vector4(2, 0, 0, 0)表示对应顶点受关节Bone3影响</span></span><br><span class="line">    geometry.skinIndices.push(<span class="keyword">new</span> THREE.Vector4(<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 影响该顶点关节Bone3对应权重是1-(vertex.y-100)/20</span></span><br><span class="line">    geometry.skinWeights.push(<span class="keyword">new</span> THREE.Vector4(<span class="number">1</span> - (vertex.y - <span class="number">100</span>) / <span class="number">20</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 材质对象</span></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshPhongMaterial(&#123;</span><br><span class="line">  skinning: <span class="literal">true</span>, <span class="comment">//允许蒙皮动画</span></span><br><span class="line">  <span class="comment">// wireframe:true,</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 创建骨骼网格模型</span></span><br><span class="line"><span class="keyword">var</span> SkinnedMesh = <span class="keyword">new</span> THREE.SkinnedMesh(geometry, material);</span><br><span class="line">SkinnedMesh.position.set(<span class="number">50</span>, <span class="number">120</span>, <span class="number">50</span>); <span class="comment">//设置网格模型位置</span></span><br><span class="line">SkinnedMesh.rotateX(<span class="built_in">Math</span>.PI); <span class="comment">//旋转网格模型</span></span><br><span class="line">scene.add(SkinnedMesh); <span class="comment">//网格模型添加到场景中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 骨骼系统</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> Bone1 = <span class="keyword">new</span> THREE.Bone(); <span class="comment">//关节1，用来作为根关节</span></span><br><span class="line"><span class="keyword">var</span> Bone2 = <span class="keyword">new</span> THREE.Bone(); <span class="comment">//关节2</span></span><br><span class="line"><span class="keyword">var</span> Bone3 = <span class="keyword">new</span> THREE.Bone(); <span class="comment">//关节3</span></span><br><span class="line"><span class="comment">// 设置关节父子关系   多个骨头关节构成一个树结构</span></span><br><span class="line">Bone1.add(Bone2);</span><br><span class="line">Bone2.add(Bone3);</span><br><span class="line"><span class="comment">// 设置关节之间的相对位置</span></span><br><span class="line"><span class="comment">//根关节Bone1默认位置是(0,0,0)</span></span><br><span class="line">Bone2.position.y = <span class="number">60</span>; <span class="comment">//Bone2相对父对象Bone1位置</span></span><br><span class="line">Bone3.position.y = <span class="number">40</span>; <span class="comment">//Bone3相对父对象Bone2位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有Bone对象插入到Skeleton中，全部设置为.bones属性的元素</span></span><br><span class="line"><span class="keyword">var</span> skeleton = <span class="keyword">new</span> THREE.Skeleton([Bone1, Bone2, Bone3]); <span class="comment">//创建骨骼系统</span></span><br><span class="line"><span class="comment">// console.log(skeleton.bones);</span></span><br><span class="line"><span class="comment">// 返回所有关节的世界坐标</span></span><br><span class="line"><span class="comment">// skeleton.bones.forEach(elem =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   console.log(elem.getWorldPosition(new THREE.Vector3()));</span></span><br><span class="line"><span class="comment">// &#125;);</span></span><br><span class="line"><span class="comment">//骨骼关联网格模型</span></span><br><span class="line">SkinnedMesh.add(Bone1); <span class="comment">//根骨头关节添加到网格模型</span></span><br><span class="line">SkinnedMesh.bind(skeleton); <span class="comment">//网格模型绑定到骨骼系统</span></span><br><span class="line"><span class="built_in">console</span>.log(SkinnedMesh);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 骨骼辅助显示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> skeletonHelper = <span class="keyword">new</span> THREE.SkeletonHelper(SkinnedMesh);</span><br><span class="line">scene.add(skeletonHelper);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转动关节带动骨骼网格模型出现弯曲效果  好像腿弯曲一样</span></span><br><span class="line">skeleton.bones[<span class="number">1</span>].rotation.x = <span class="number">0.5</span>;</span><br><span class="line">skeleton.bones[<span class="number">2</span>].rotation.x = <span class="number">0.5</span>;</span><br></pre></td></tr></table></figure>

<p><img src="./02.png" alt="相关类"></p>
<h1 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> T = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">var</span> step = <span class="number">0.01</span>;</span><br><span class="line"><span class="comment">// 渲染函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  renderer.render(scene, camera);</span><br><span class="line">  requestAnimationFrame(render);</span><br><span class="line">  n += <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; T) &#123;</span><br><span class="line">    <span class="comment">// 改变骨关节角度</span></span><br><span class="line">    skeleton.bones[<span class="number">0</span>].rotation.x = skeleton.bones[<span class="number">0</span>].rotation.x - step;</span><br><span class="line">    skeleton.bones[<span class="number">1</span>].rotation.x = skeleton.bones[<span class="number">1</span>].rotation.x + step;</span><br><span class="line">    skeleton.bones[<span class="number">2</span>].rotation.x = skeleton.bones[<span class="number">2</span>].rotation.x + <span class="number">2</span> * step;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">2</span> * T &amp;&amp; n &gt; T) &#123;</span><br><span class="line">    skeleton.bones[<span class="number">0</span>].rotation.x = skeleton.bones[<span class="number">0</span>].rotation.x + step;</span><br><span class="line">    skeleton.bones[<span class="number">1</span>].rotation.x = skeleton.bones[<span class="number">1</span>].rotation.x - step;</span><br><span class="line">    skeleton.bones[<span class="number">2</span>].rotation.x = skeleton.bones[<span class="number">2</span>].rotation.x - <span class="number">2</span> * step;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span> * T) &#123;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">render();</span><br></pre></td></tr></table></figure>

<p><img src="./02.gif" alt="相关类"></p>
]]></content>
  </entry>
  <entry>
    <title>Three.js数据结构导入导出</title>
    <url>/2020/07/28/02web/ThreeJS/14%E6%A8%A1%E5%9E%8B%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/01Three.js%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/</url>
    <content><![CDATA[<h1 id="Threejs导出模型信息"><a href="#Threejs导出模型信息" class="headerlink" title="Threejs导出模型信息"></a>Threejs导出模型信息</h1><ul>
<li>Geometry、Material、Light、Object3D等类，提供了一个.toJSON()方法</li>
<li>通过这个方法可以导出Threejs三维模型的各类数据</li>
<li>该方法的功能就是把Threejs的几何体、材质、光源等对象转化为JSON格式导出</li>
</ul>
<h2 id="导出几何体信息"><a href="#导出几何体信息" class="headerlink" title="导出几何体信息"></a>导出几何体信息</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"><span class="comment">// 控制台查看立方体数据</span></span><br><span class="line"><span class="built_in">console</span>.log(geometry);</span><br><span class="line"><span class="comment">// 控制台查看geometry.toJSON()结果</span></span><br><span class="line"><span class="built_in">console</span>.log(geometry.toJSON());</span><br><span class="line"><span class="comment">// JSON对象转化为字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(geometry.toJSON()));</span><br><span class="line"><span class="comment">// JSON.stringify()方法内部会自动调用参数的toJSON()方法</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(geometry))</span><br></pre></td></tr></table></figure>

<h2 id="导出材质信息"><a href="#导出材质信息" class="headerlink" title="导出材质信息"></a>导出材质信息</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">  color: <span class="number">0x0000ff</span>,</span><br><span class="line">&#125;); <span class="comment">//材质对象Material</span></span><br><span class="line"><span class="built_in">console</span>.log(material);</span><br><span class="line"><span class="built_in">console</span>.log(material.toJSON());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(material));</span><br></pre></td></tr></table></figure>

<h2 id="导出场景scene信息"><a href="#导出场景scene信息" class="headerlink" title="导出场景scene信息"></a>导出场景scene信息</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span><br><span class="line"><span class="built_in">console</span>.log(scene);</span><br><span class="line"><span class="built_in">console</span>.log(scene.toJSON());</span><br></pre></td></tr></table></figure>

<h1 id="自定义模型加载器文件"><a href="#自定义模型加载器文件" class="headerlink" title="自定义模型加载器文件"></a>自定义模型加载器文件</h1><ul>
<li>Threejs在three.js-master\examples\js\loaders目录下会提供一系列的加载器</li>
<li>这些加载器本质上都是解析模型文件的字符串</li>
<li>通过正则表达式提取相关的顶点、材质等信息转化为Threejs自身的类表示的对象</li>
</ul>
<p><img src="01Three.js%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/01.png" alt="自定义模型加载器文件"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/ 如果编写通用的材质加载器需要枚举所有的材质，这里没有列举完</span><br><span class="line"><span class="keyword">var</span> typeAPI = &#123;</span><br><span class="line">  MeshLambertMaterial: THREE.MeshLambertMaterial,</span><br><span class="line">  MeshBasicMaterial: THREE.MeshBasicMaterial,</span><br><span class="line">  MeshPhongMaterial: THREE.MeshPhongMaterial,</span><br><span class="line">  PointsMaterial: THREE.PointsMaterial,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建一个文件加载器，该加载器是对异步加载的封装</span></span><br><span class="line"><span class="keyword">var</span> loader = <span class="keyword">new</span> THREE.FileLoader();</span><br><span class="line">loader.load(<span class="string">'material.json'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">elem</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(elem);<span class="comment">// 查看加载返回的内容</span></span><br><span class="line">  <span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(elem);<span class="comment">// 字符串转JSON对象</span></span><br><span class="line">  <span class="built_in">console</span>.log(obj);<span class="comment">// 查看转化结果</span></span><br><span class="line">  <span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 解析材质数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 根据type的值判断调用threejs的哪一个API</span></span><br><span class="line">  <span class="keyword">var</span> material = <span class="keyword">new</span> typeAPI[obj.type]();</span><br><span class="line">  <span class="comment">// 从obj.color中提取颜色</span></span><br><span class="line">  <span class="comment">// 16711935对应颜色0xFF00FF  255对应颜色0x0000FF</span></span><br><span class="line">  material.color.r = (obj.color &gt;&gt; <span class="number">16</span> &amp; <span class="number">255</span>) / <span class="number">255</span>; <span class="comment">//获取颜色值R部分</span></span><br><span class="line">  material.color.g = (obj.color &gt;&gt; <span class="number">8</span> &amp; <span class="number">255</span>) / <span class="number">255</span>; <span class="comment">//获取颜色值G部分</span></span><br><span class="line">  material.color.b = (obj.color &amp; <span class="number">255</span>) / <span class="number">255</span>; <span class="comment">//获取颜色值B部分</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">  scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="加载Three-js导出的模型数据"><a href="#加载Three-js导出的模型数据" class="headerlink" title="加载Three.js导出的模型数据"></a>加载Three.js导出的模型数据</h2><h3 id="缓冲几何体数据加载器"><a href="#缓冲几何体数据加载器" class="headerlink" title="缓冲几何体数据加载器"></a>缓冲几何体数据加载器</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> loader = <span class="keyword">new</span> THREE.BufferGeometryLoader();</span><br><span class="line">loader.load(<span class="string">'bufferGeometry.json'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">geometry</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 控制台查看加载放回的threejs对象结构</span></span><br><span class="line">  <span class="built_in">console</span>.log(geometry);</span><br><span class="line">  <span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">    color: <span class="number">0x0000ff</span>,</span><br><span class="line">  &#125;); <span class="comment">//材质对象Material</span></span><br><span class="line">  <span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">  scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="网格模型Mesh加载"><a href="#网格模型Mesh加载" class="headerlink" title="网格模型Mesh加载"></a>网格模型Mesh加载</h3><p>包含几何体Geometry和材质Material</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> loader = <span class="keyword">new</span> THREE.ObjectLoader();</span><br><span class="line">loader.load(<span class="string">'model.json'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj.type);</span><br><span class="line">  obj.scale.set(<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>)</span><br><span class="line">  scene.add(obj)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="加载组Group对象"><a href="#加载组Group对象" class="headerlink" title="加载组Group对象"></a>加载组Group对象</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">loader.load(<span class="string">'group.json'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(obj);</span><br><span class="line">  <span class="built_in">console</span>.log(obj.type);</span><br><span class="line">  scene.add(obj)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="加载场景对象"><a href="#加载场景对象" class="headerlink" title="加载场景对象"></a>加载场景对象</h3><p>场景对象不仅包含模型，还包括光源对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">loader.load(<span class="string">'scene.json'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(obj);</span><br><span class="line">  <span class="built_in">console</span>.log(obj.type);</span><br><span class="line">  obj.scale.set(<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>)</span><br><span class="line">  scene.add(obj)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>加载外部模型骨骼动画</title>
    <url>/2020/07/27/02web/ThreeJS/12%E9%AA%A8%E9%AA%BC,%E5%8F%98%E5%BD%A2%E5%8A%A8%E7%94%BB/02%E5%8A%A0%E8%BD%BD%E5%A4%96%E9%83%A8%E6%A8%A1%E5%9E%8B%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<h1 id="查看骨骼动画数据"><a href="#查看骨骼动画数据" class="headerlink" title="查看骨骼动画数据"></a>查看骨骼动画数据</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载解析骨骼模型动画</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> loader = <span class="keyword">new</span> THREE.ObjectLoader(); <span class="comment">//创建一个加载器</span></span><br><span class="line"><span class="keyword">var</span> SkinnedMesh =<span class="literal">null</span>; <span class="comment">//声明一个骨骼网格模型变量</span></span><br><span class="line">loader.load(<span class="string">"./marine_anims_core.json"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log(obj)</span></span><br><span class="line">  scene.add(obj); <span class="comment">//添加到场景中</span></span><br><span class="line">  <span class="comment">//从返回对象获得骨骼网格模型</span></span><br><span class="line">  SkinnedMesh = obj.children[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// 查看骨头关节Bone</span></span><br><span class="line">  <span class="built_in">console</span>.log(SkinnedMesh.skeleton.bones);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 骨骼辅助显示</span></span><br><span class="line">  <span class="keyword">var</span> skeletonHelper = <span class="keyword">new</span> THREE.SkeletonHelper(SkinnedMesh);</span><br><span class="line">  scene.add(skeletonHelper);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历骨骼模型中的骨关节Bone，并获得世界坐标</span></span><br><span class="line">  SkinnedMesh.traverse(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elem.type === <span class="string">'Bone'</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(elem.getWorldPosition(<span class="keyword">new</span> THREE.Vector3()));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="./01.png" alt="查看骨骼动画数据"></p>
<h1 id="解析渲染骨骼动画"><a href="#解析渲染骨骼动画" class="headerlink" title="解析渲染骨骼动画"></a>解析渲染骨骼动画</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> loader = <span class="keyword">new</span> THREE.ObjectLoader(); <span class="comment">//创建一个加载器</span></span><br><span class="line"><span class="keyword">var</span> mixer = <span class="literal">null</span>; <span class="comment">//声明一个混合器变量</span></span><br><span class="line">loader.load(<span class="string">"./marine_anims_core.json"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  scene.add(obj); <span class="comment">//添加到场景中</span></span><br><span class="line">  <span class="comment">//从返回对象获得骨骼网格模型</span></span><br><span class="line">  <span class="keyword">var</span> SkinnedMesh = obj.children[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">//骨骼网格模型作为参数创建一个混合器</span></span><br><span class="line">  mixer = <span class="keyword">new</span> THREE.AnimationMixer(SkinnedMesh);</span><br><span class="line">  <span class="comment">// 查看骨骼网格模型的帧动画数据</span></span><br><span class="line">  <span class="comment">// console.log(SkinnedMesh.geometry.animations)</span></span><br><span class="line">  <span class="comment">// 解析跑步状态对应剪辑对象clip中的关键帧数据</span></span><br><span class="line">  <span class="keyword">var</span> AnimationAction = mixer.clipAction(SkinnedMesh.geometry.animations[<span class="number">1</span>]);</span><br><span class="line">  <span class="comment">// 解析步行状态对应剪辑对象clip中的关键帧数据</span></span><br><span class="line">  <span class="comment">// var AnimationAction = mixer.clipAction(SkinnedMesh.geometry.animations[3]);</span></span><br><span class="line">  AnimationAction.play();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个时钟对象Clock</span></span><br><span class="line"><span class="keyword">var</span> clock = <span class="keyword">new</span> THREE.Clock();</span><br><span class="line"><span class="comment">// 渲染函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  renderer.render(scene, camera); <span class="comment">//执行渲染操作</span></span><br><span class="line">  requestAnimationFrame(render); <span class="comment">//请求再次执行渲染函数render，渲染下一帧</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mixer !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//clock.getDelta()方法获得两帧的时间间隔</span></span><br><span class="line">    <span class="comment">// 更新混合器相关的时间</span></span><br><span class="line">    mixer.update(clock.getDelta());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">render();</span><br></pre></td></tr></table></figure>

<p><img src="./02.gif" alt="解析渲染骨骼动画"></p>
]]></content>
  </entry>
  <entry>
    <title>变形动画</title>
    <url>/2020/07/27/02web/ThreeJS/12%E9%AA%A8%E9%AA%BC,%E5%8F%98%E5%BD%A2%E5%8A%A8%E7%94%BB/03%E5%8F%98%E5%BD%A2%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<ul>
<li>多组顶点数据，从一个状态变化到另一个状态<ul>
<li>比如人的面部表情</li>
<li>哭的表情用一系列的顶点表示</li>
<li>笑的表情用一系列的顶点表示</li>
<li>从哭的表情过渡到笑的表情，就是表情对应的两组顶点之间的过渡</li>
</ul>
</li>
<li>几何体的顶点的位置坐标发生变化，从一个状态过渡到另一个状态自然就产生了变形动画。</li>
<li>变形动画和骨骼动画一样，由3D美术编辑好变形动画的模型数据，然后程序员通过Threejs相关的API解析渲染变形动画。</li>
</ul>
<h1 id="创建变形动画的顶点数据"><a href="#创建变形动画的顶点数据" class="headerlink" title="创建变形动画的顶点数据"></a>创建变形动画的顶点数据</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建网格模型，并给模型的几何体设置多个变形目标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 创建一个几何体具有8个顶点</span></span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>); <span class="comment">//立方体几何对象</span></span><br><span class="line"><span class="built_in">console</span>.log(geometry.vertices);</span><br><span class="line"><span class="comment">// 为geometry提供变形目标的数据</span></span><br><span class="line"><span class="keyword">var</span> box1 = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">100</span>, <span class="number">5</span>, <span class="number">100</span>); <span class="comment">//为变形目标1提供数据</span></span><br><span class="line"><span class="keyword">var</span> box2 = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">5</span>, <span class="number">200</span>, <span class="number">5</span>); <span class="comment">//为变形目标2提供数据</span></span><br><span class="line"><span class="comment">// 设置变形目标的数据</span></span><br><span class="line">geometry.morphTargets[<span class="number">0</span>] = &#123;<span class="attr">name</span>: <span class="string">'target1'</span>,<span class="attr">vertices</span>: box1.vertices&#125;;</span><br><span class="line">geometry.morphTargets[<span class="number">1</span>] = &#123;<span class="attr">name</span>: <span class="string">'target2'</span>,<span class="attr">vertices</span>: box2.vertices&#125;;</span><br><span class="line"><span class="comment">//材质对象</span></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">  morphTargets: <span class="literal">true</span>, <span class="comment">//允许变形</span></span><br><span class="line">  color: <span class="number">0x0000ff</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型对象</span></span><br><span class="line">scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span><br></pre></td></tr></table></figure>

<h1 id="生成变形动画"><a href="#生成变形动画" class="headerlink" title="生成变形动画"></a>生成变形动画</h1><ul>
<li>第一步先利用关键帧KeyframeTrack、剪辑AnimationClip两个类创建好帧动画。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置关键帧数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 设置变形目标1对应权重随着时间的变化</span></span><br><span class="line"><span class="keyword">var</span> Track1 = <span class="keyword">new</span> THREE.KeyframeTrack(<span class="string">'.morphTargetInfluences[0]'</span>, [<span class="number">0</span>,<span class="number">10</span>,<span class="number">20</span>], [<span class="number">0</span>,<span class="number">1</span>, <span class="number">0</span>]);</span><br><span class="line"><span class="comment">// 设置变形目标2对应权重随着时间的变化</span></span><br><span class="line"><span class="keyword">var</span> Track2 = <span class="keyword">new</span> THREE.KeyframeTrack(<span class="string">'.morphTargetInfluences[1]'</span>, [<span class="number">20</span>,<span class="number">30</span>, <span class="number">40</span>], [<span class="number">0</span>, <span class="number">1</span>,<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// 创建一个剪辑clip对象，命名"default"，持续时间40</span></span><br><span class="line"><span class="keyword">var</span> clip = <span class="keyword">new</span> THREE.AnimationClip(<span class="string">"default"</span>, <span class="number">40</span>, [Track1,Track2]);</span><br></pre></td></tr></table></figure>

<ul>
<li>第二步是使用混合器AnimationMixer播放设置好的关键帧动画。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 播放编辑好的关键帧数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mixer = <span class="keyword">new</span> THREE.AnimationMixer(mesh); <span class="comment">//创建混合器</span></span><br><span class="line"><span class="keyword">var</span> AnimationAction = mixer.clipAction(clip); <span class="comment">//返回动画操作对象</span></span><br><span class="line">AnimationAction.timeScale = <span class="number">5</span>; <span class="comment">//默认1，可以调节播放速度</span></span><br><span class="line"><span class="comment">// AnimationAction.loop = THREE.LoopOnce; //不循环播放</span></span><br><span class="line"><span class="comment">// AnimationAction.clampWhenFinished=true;//暂停在最后一帧播放的状态</span></span><br><span class="line">AnimationAction.play(); <span class="comment">//开始播放</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 创建一个时钟对象Clock</span></span><br><span class="line"><span class="keyword">var</span> clock = <span class="keyword">new</span> THREE.Clock();</span><br><span class="line"><span class="comment">// 渲染函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  renderer.render(scene, camera); <span class="comment">//执行渲染操作</span></span><br><span class="line">  requestAnimationFrame(render); <span class="comment">//请求再次执行渲染函数render，渲染下一帧</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//clock.getDelta()方法获得两帧的时间间隔</span></span><br><span class="line">  <span class="comment">// 更新混合器相关的时间</span></span><br><span class="line">  mixer.update(clock.getDelta());</span><br><span class="line">&#125;</span><br><span class="line">render();</span><br></pre></td></tr></table></figure>

<p><img src="./01.gif" alt="相关类"></p>
]]></content>
  </entry>
  <entry>
    <title>stl格式模型加载</title>
    <url>/2020/07/28/02web/ThreeJS/14%E6%A8%A1%E5%9E%8B%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/02stl%E6%A0%BC%E5%BC%8F%E6%A8%A1%E5%9E%8B%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<ul>
<li>基本所有的三维软件都支持导出.stl格式的三维模型文件</li>
<li>.stl格式的三维模型不包含材质Material信息,只包含几何体顶点数据的信息</li>
<li>可以简单地把stl文件理解为几何体对象Geometry</li>
</ul>
<h1 id="stl文件数据结构"><a href="#stl文件数据结构" class="headerlink" title="stl文件数据结构"></a>stl文件数据结构</h1><h2 id="三角形面信息"><a href="#三角形面信息" class="headerlink" title="三角形面信息"></a>三角形面信息</h2><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三角面1</span></span><br><span class="line">   facet <span class="attribute">normal</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">1</span>    //三角形面法向量</span><br><span class="line">      outer loop</span><br><span class="line">         vertex <span class="number">50</span> <span class="number">50</span> -<span class="number">50</span>   <span class="comment">//顶点位置</span></span><br><span class="line">         vertex <span class="number">50</span> -<span class="number">50</span> -<span class="number">50</span>  <span class="comment">//顶点位置</span></span><br><span class="line">         vertex -<span class="number">50</span> <span class="number">50</span> -<span class="number">50</span>  <span class="comment">//顶点位置</span></span><br><span class="line">      endloop</span><br><span class="line">   endfacet</span><br></pre></td></tr></table></figure>

<h2 id="立方体"><a href="#立方体" class="headerlink" title="立方体"></a>立方体</h2><ul>
<li>一个立方体有6个矩形平面</li>
<li>每个矩形平面至少需要两个三角形拼接而成</li>
<li>方体6个矩形平面至少需要12个三角形面构成</li>
<li>查看文件box.STL中的12个三角形信息</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">solid box  <span class="comment">//文件名字</span></span><br><span class="line"><span class="comment">//三角面1</span></span><br><span class="line">   facet <span class="attribute">normal</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">1</span>    //三角形面法向量</span><br><span class="line">      outer loop</span><br><span class="line">         vertex <span class="number">50</span> <span class="number">50</span> -<span class="number">50</span>   <span class="comment">//顶点位置</span></span><br><span class="line">         vertex <span class="number">50</span> -<span class="number">50</span> -<span class="number">50</span>  <span class="comment">//顶点位置</span></span><br><span class="line">         vertex -<span class="number">50</span> <span class="number">50</span> -<span class="number">50</span>  <span class="comment">//顶点位置</span></span><br><span class="line">      endloop</span><br><span class="line">   endfacet</span><br><span class="line"><span class="comment">//三角面2</span></span><br><span class="line">   facet <span class="attribute">normal</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">1</span>    //三角形面法向量</span><br><span class="line">      outer loop</span><br><span class="line">         vertex -<span class="number">50</span> <span class="number">50</span> -<span class="number">50</span>   <span class="comment">//顶点位置</span></span><br><span class="line">         vertex <span class="number">50</span> -<span class="number">50</span> -<span class="number">50</span>   <span class="comment">//顶点位置</span></span><br><span class="line">         vertex -<span class="number">50</span> -<span class="number">50</span> -<span class="number">50</span>  <span class="comment">//顶点位置</span></span><br><span class="line">      endloop</span><br><span class="line">   endfacet</span><br><span class="line">   facet <span class="attribute">normal</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line">      .....</span><br><span class="line">      .....</span><br><span class="line"><span class="comment">//三角面12</span></span><br><span class="line">   facet <span class="attribute">normal</span> -<span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">      outer loop</span><br><span class="line">         vertex -<span class="number">50</span> -<span class="number">50</span> -<span class="number">50</span></span><br><span class="line">         vertex -<span class="number">50</span> <span class="number">50</span> <span class="number">50</span></span><br><span class="line">         vertex -<span class="number">50</span> <span class="number">50</span> -<span class="number">50</span></span><br><span class="line">      endloop</span><br><span class="line">   endfacet</span><br><span class="line">endsolid</span><br></pre></td></tr></table></figure>

<h1 id="通过STLLoader-js加载-stl文件"><a href="#通过STLLoader-js加载-stl文件" class="headerlink" title="通过STLLoader.js加载.stl文件"></a>通过STLLoader.js加载.stl文件</h1><ul>
<li>通过Threejs加载.stl格式三维模型文件，可以使用Threejs提供的一个扩展库stl加载器STLLoader.js</li>
<li>在Three.js-master包中找到STLLoader.js文件,具体路径是three.js-master\examples\js\loaders</li>
</ul>
<h2 id="加载外部文件渲染正方体"><a href="#加载外部文件渲染正方体" class="headerlink" title="加载外部文件渲染正方体"></a>加载外部文件渲染正方体</h2><ul>
<li>THREE.STLLoader()实例化一个加载器<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入STLLoader.js文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"STLLoader.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>通过构造函数THREE.STLLoader()可以把.stl文件中几何体顶点信息提取出来转化为Three.js自身格式的几何体对象BufferGeometry<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// THREE.STLLoader创建一个加载器</span></span><br><span class="line"><span class="keyword">var</span> loader = <span class="keyword">new</span> THREE.STLLoader();</span><br><span class="line">loader.load(<span class="string">'立方体.stl'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">geometry</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 加载完成后会返回一个几何体对象BufferGeometry，你可以通过Mesh、Points等方式渲染该几何体</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * stl数据加载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> loader = <span class="keyword">new</span> THREE.STLLoader();</span><br><span class="line"><span class="comment">// 立方体默认尺寸长宽高各200</span></span><br><span class="line">loader.load(<span class="string">'立方体.stl'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">geometry</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 控制台查看加载放回的threejs对象结构</span></span><br><span class="line">  <span class="built_in">console</span>.log(geometry);</span><br><span class="line">  <span class="comment">// 查看顶点数，一个立方体6个矩形面，每个矩形面至少2个三角面，每个三角面3个顶点，</span></span><br><span class="line">  <span class="comment">// 如果没有索引index复用顶点，就是说一个立方体至少36个顶点</span></span><br><span class="line">  <span class="built_in">console</span>.log(geometry.attributes.position.count);</span><br><span class="line">  <span class="comment">// 缩放几何体</span></span><br><span class="line">  <span class="comment">// geometry.scale(0.5,0.5,0.5);</span></span><br><span class="line">  <span class="comment">// 几何体居中</span></span><br><span class="line">  <span class="comment">// geometry.center();</span></span><br><span class="line">  <span class="comment">// 平移立方体</span></span><br><span class="line">  <span class="comment">// geometry.translate(-50,-50,-50);</span></span><br><span class="line">  <span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">    color: <span class="number">0x0000ff</span>,</span><br><span class="line">  &#125;); <span class="comment">//材质对象Material</span></span><br><span class="line">  <span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">  scene.add(mesh); <span class="comment">//网格模型添加到场景中</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="使用点模型渲染STL文件"><a href="#使用点模型渲染STL文件" class="headerlink" title="使用点模型渲染STL文件"></a>使用点模型渲染STL文件</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 点渲染模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> loader.load(<span class="string">'离心叶轮.stl'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">geometry</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> material = <span class="keyword">new</span> THREE.PointsMaterial(&#123;</span><br><span class="line">     color: <span class="number">0x000000</span>,</span><br><span class="line">     size: <span class="number">0.5</span><span class="comment">//点对象像素尺寸</span></span><br><span class="line">   &#125;); <span class="comment">//材质对象</span></span><br><span class="line">   <span class="keyword">var</span> points = <span class="keyword">new</span> THREE.Points(geometry, material); <span class="comment">//点模型对象</span></span><br><span class="line">   scene.add(points); <span class="comment">//点对象添加到场景中</span></span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>音乐可视化</title>
    <url>/2020/07/28/02web/ThreeJS/13%E8%AF%AD%E9%9F%B3%E6%A8%A1%E5%9D%97/02%E9%9F%B3%E4%B9%90%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<p>通过Threejs音频相关的APi可以获得音乐音频的频率数据然后可视化。</p>
<h1 id="查看平均频率"><a href="#查看平均频率" class="headerlink" title="查看平均频率"></a>查看平均频率</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> analyser = <span class="literal">null</span>; <span class="comment">// 声明一个分析器变量</span></span><br><span class="line"><span class="comment">// 渲染函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  renderer.render(scene, camera); <span class="comment">//执行渲染操作</span></span><br><span class="line">  requestAnimationFrame(render); <span class="comment">//请求再次执行渲染函数render，渲染下一帧</span></span><br><span class="line">  <span class="keyword">if</span> (analyser) &#123;</span><br><span class="line">    <span class="comment">// getAverageFrequency()返回平均音频</span></span><br><span class="line">    <span class="keyword">var</span> frequency = analyser.getAverageFrequency();</span><br><span class="line">    mesh.scale.y = <span class="number">5</span> * frequency / <span class="number">256</span>;</span><br><span class="line">    mesh.material.color.r = <span class="number">3</span> * frequency / <span class="number">256</span>;</span><br><span class="line">    <span class="comment">// 返回傅里叶变换得到的所有频率</span></span><br><span class="line">    <span class="comment">// console.log(analyser.getFrequencyData())</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">render();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> listener = <span class="keyword">new</span> THREE.AudioListener() <span class="comment">//监听者</span></span><br><span class="line"><span class="keyword">var</span> audio = <span class="keyword">new</span> THREE.Audio(listener); <span class="comment">//非位置音频对象</span></span><br><span class="line"><span class="keyword">var</span> audioLoader = <span class="keyword">new</span> THREE.AudioLoader(); <span class="comment">//音频加载器</span></span><br><span class="line"><span class="comment">// 加载音频文件</span></span><br><span class="line">audioLoader.load(<span class="string">'中国人.mp3'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">AudioBuffer</span>) </span>&#123;</span><br><span class="line">  audio.setBuffer(AudioBuffer); <span class="comment">// 音频缓冲区对象关联到音频对象audio</span></span><br><span class="line">  audio.setLoop(<span class="literal">true</span>); <span class="comment">//是否循环</span></span><br><span class="line">  audio.setVolume(<span class="number">0.5</span>); <span class="comment">//音量</span></span><br><span class="line">  audio.play(); <span class="comment">//播放</span></span><br><span class="line">  <span class="comment">// 音频分析器和音频绑定，可以实时采集音频时域数据进行快速傅里叶变换</span></span><br><span class="line">  analyser = <span class="keyword">new</span> THREE.AudioAnalyser(audio);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="频率数据可视化案例"><a href="#频率数据可视化案例" class="headerlink" title="频率数据可视化案例"></a>频率数据可视化案例</h1><p>获取频率数据，然后通过频率数据控制网格模型的长度方向伸缩变化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建多个网格模型组成的组对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">var</span> group = <span class="keyword">new</span> THREE.Group();</span><br><span class="line"> <span class="keyword">let</span> N = <span class="number">128</span>; <span class="comment">//控制音频分析器返回频率数据数量</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; N / <span class="number">2</span>; i++) &#123;</span><br><span class="line">   <span class="keyword">var</span> box = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">10</span>, <span class="number">100</span>, <span class="number">10</span>); <span class="comment">//创建一个立方体几何对象</span></span><br><span class="line">   <span class="keyword">var</span> material = <span class="keyword">new</span> THREE.MeshPhongMaterial(&#123;</span><br><span class="line">     color: <span class="number">0x0000ff</span></span><br><span class="line">   &#125;); <span class="comment">//材质对象</span></span><br><span class="line">   <span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.Mesh(box, material); <span class="comment">//网格模型对象</span></span><br><span class="line">   <span class="comment">// 长方体间隔20，整体居中</span></span><br><span class="line">   mesh.position.set(<span class="number">20</span> * i - N / <span class="number">2</span> * <span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">   group.add(mesh)</span><br><span class="line"> &#125;</span><br><span class="line"> scene.add(group)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> analyser = <span class="literal">null</span>; <span class="comment">// 声明一个分析器变量</span></span><br><span class="line"><span class="comment">// 渲染函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  renderer.render(scene, camera); <span class="comment">//执行渲染操作</span></span><br><span class="line">  requestAnimationFrame(render); <span class="comment">//请求再次执行渲染函数render，渲染下一帧</span></span><br><span class="line">  <span class="keyword">if</span> (analyser) &#123;</span><br><span class="line">    <span class="comment">// 获得频率数据N个</span></span><br><span class="line">    <span class="keyword">var</span> arr = analyser.getFrequencyData();</span><br><span class="line">    <span class="comment">// console.log(arr);</span></span><br><span class="line">    <span class="comment">// 遍历组对象，每个网格子对象设置一个对应的频率数据</span></span><br><span class="line">    group.children.forEach(<span class="function">(<span class="params">elem, index</span>) =&gt;</span> &#123;</span><br><span class="line">      elem.scale.y = arr[index] / <span class="number">80</span></span><br><span class="line">      elem.material.color.r = arr[index] / <span class="number">200</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> listener = <span class="keyword">new</span> THREE.AudioListener() <span class="comment">//监听者</span></span><br><span class="line"><span class="keyword">var</span> audio = <span class="keyword">new</span> THREE.Audio(listener); <span class="comment">//非位置音频对象</span></span><br><span class="line"><span class="keyword">var</span> audioLoader = <span class="keyword">new</span> THREE.AudioLoader(); <span class="comment">//音频加载器</span></span><br><span class="line"><span class="comment">// 加载音频文件</span></span><br><span class="line">audioLoader.load(<span class="string">'中国人.mp3'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">AudioBuffer</span>) </span>&#123;</span><br><span class="line">  audio.setBuffer(AudioBuffer); <span class="comment">// 音频缓冲区对象关联到音频对象audio</span></span><br><span class="line">  audio.setLoop(<span class="literal">true</span>); <span class="comment">//是否循环</span></span><br><span class="line">  audio.setVolume(<span class="number">0.5</span>); <span class="comment">//音量</span></span><br><span class="line">  audio.play(); <span class="comment">//播放</span></span><br><span class="line">  <span class="comment">// 音频分析器和音频绑定，可以实时采集音频时域数据进行快速傅里叶变换</span></span><br><span class="line">  analyser = <span class="keyword">new</span> THREE.AudioAnalyser(audio,<span class="number">2</span>*N);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>加载.obj模型文件</title>
    <url>/2020/07/28/02web/ThreeJS/14%E6%A8%A1%E5%9E%8B%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/03%E5%8A%A0%E8%BD%BD.obj%E6%A8%A1%E5%9E%8B%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<ul>
<li>使用三维软件导出.obj模型文件的时候，会同时导出一个材质文件.mtl</li>
<li>.obj和.stl文件包含的信息一样都是几何体顶点相关数据</li>
<li>材质文件.mtl包含的是模型的材质信息，比如颜色、贴图路径等</li>
<li>加载.obj三维模型的时候，可以只加载.obj文件，然后借助three.js引擎自定义材质Material</li>
<li>也可以同时加载.obj和.mtl文件</li>
</ul>
<h1 id="只加载obj文件"><a href="#只加载obj文件" class="headerlink" title="只加载obj文件"></a>只加载obj文件</h1><ul>
<li>只加载obj文件，引入路径three.js-master/examples/js/loaders/OBJLoader.js下的OBJLoader.js文件即可</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入obj模型加载库OBJLoader.js --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../../three.js-master/examples/js/loaders/OBJLoader.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>文件加载<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * OBJ文件加载  只加载obj文件中的几何信息，不加载材质文件.mtl</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> loader = <span class="keyword">new</span> THREE.OBJLoader();</span><br><span class="line"><span class="comment">// 没有材质文件，系统自动设置Phong网格材质</span></span><br><span class="line">loader.load(<span class="string">'./立方体/box.obj'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 控制台查看返回结构：包含一个网格模型Mesh的组Group</span></span><br><span class="line">  <span class="built_in">console</span>.log(obj);</span><br><span class="line">  <span class="comment">// 查看加载器生成的材质对象：MeshPhongMaterial</span></span><br><span class="line">  <span class="built_in">console</span>.log(obj.children[<span class="number">0</span>].material);</span><br><span class="line">  scene.add(obj);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>加载文件返回的对象插入场景中后，你也可以做一些自定的设置，比如缩放、居中等操作。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载后的一些编辑操作</span></span><br><span class="line">obj.children[<span class="number">0</span>].scale.set(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>);<span class="comment">//网格模型缩放</span></span><br><span class="line">obj.children[<span class="number">0</span>].geometry.center();<span class="comment">//网格模型的几何体居中</span></span><br><span class="line">obj.children[<span class="number">0</span>].material.color.set(<span class="number">0xff0000</span>);<span class="comment">//设置材质颜色</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="同时加载obj文件和mtl文件"><a href="#同时加载obj文件和mtl文件" class="headerlink" title="同时加载obj文件和mtl文件"></a>同时加载obj文件和mtl文件</h1><ul>
<li>引入文件<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入obj模型加载库OBJLoader.js --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../../three.js-master/examples/js/loaders/OBJLoader.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引入obj模型材质加载库MTLLoader.js --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../../three.js-master/examples/js/loaders/MTLLoader.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>加载obj和mtl<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * OBJ和材质文件mtl加载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> OBJLoader = <span class="keyword">new</span> THREE.OBJLoader();<span class="comment">//obj加载器</span></span><br><span class="line"><span class="keyword">var</span> MTLLoader = <span class="keyword">new</span> THREE.MTLLoader();<span class="comment">//材质文件加载器</span></span><br><span class="line">MTLLoader.load(<span class="string">'./立方体/box.mtl'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">materials</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回一个包含材质的对象MaterialCreator</span></span><br><span class="line">  <span class="built_in">console</span>.log(materials);</span><br><span class="line">  <span class="comment">//obj的模型会和MaterialCreator包含的材质对应起来</span></span><br><span class="line">  OBJLoader.setMaterials(materials);</span><br><span class="line">  OBJLoader.load(<span class="string">'./立方体/box.obj'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(obj);</span><br><span class="line">    obj.scale.set(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>); <span class="comment">//放大obj组对象</span></span><br><span class="line">    scene.add(obj);<span class="comment">//返回的组对象插入场景中</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="obj包含多个网格模型"><a href="#obj包含多个网格模型" class="headerlink" title="obj包含多个网格模型"></a>obj包含多个网格模型</h1><p>obj文件可以包含多个网格模型对象，不一定就是一个，这些网格模型对象全部是并列关系，无法通过父子关系构建一个树结构层级模型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有材质文件，系统自动设置Phong网格材质</span></span><br><span class="line">OBJLoader.load(<span class="string">'./多个模型/model.obj'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 控制台查看返回结构：包含一个网格模型Mesh的组Group</span></span><br><span class="line">  <span class="built_in">console</span>.log(obj);</span><br><span class="line">  scene.add(obj);</span><br><span class="line">  <span class="comment">// 加载后的一些编辑操作</span></span><br><span class="line">  obj.scale.set(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>);<span class="comment">//网格模型缩放</span></span><br><span class="line">  <span class="comment">// 设置其中一个网格模型的颜色</span></span><br><span class="line">  obj.children[<span class="number">0</span>].material.color.set(<span class="number">0xff0000</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="模型纹理贴图"><a href="#模型纹理贴图" class="headerlink" title="模型纹理贴图"></a>模型纹理贴图</h1><ul>
<li>obj模型的mtl文件可能包含纹理贴图，也可能不包含，这主要看3D美术是否设置。</li>
<li>一个包含纹理贴图路径的.mtl文件,如果路径有问题，可能会无法加载，可以仿照该案例修改。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 一个包含纹理贴图路径的.mtl文件</span><br><span class="line">newmtl material_1</span><br><span class="line">    Ns 32</span><br><span class="line">    d 1</span><br><span class="line">    Tr 0</span><br><span class="line">    Tf 1 1 1</span><br><span class="line">    illum 2</span><br><span class="line">    Ka 0.5880 0.5880 0.5880</span><br><span class="line">    Kd 0.9880 0.9880 0.9880</span><br><span class="line">    Ks 0.1200 0.1200 0.1200</span><br><span class="line">    map_Kd .&#x2F;贴图&#x2F;Earth.png</span><br><span class="line">  map_ks .&#x2F;贴图&#x2F;EarthSpec.png</span><br><span class="line">    norm .&#x2F;贴图&#x2F;EarthNormal.png</span><br></pre></td></tr></table></figure>

<p>mtl和threejs贴图对应关系</p>
<table>
<thead>
<tr>
<th>mtl贴图</th>
<th align="center">Threejs贴图</th>
</tr>
</thead>
<tbody><tr>
<td>map_kd</td>
<td align="center">map</td>
</tr>
<tr>
<td>map_ks</td>
<td align="center">specularMap</td>
</tr>
<tr>
<td>map_bump/bump</td>
<td align="center">bumpMap</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * OBJ和材质文件mtl加载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> OBJLoader = <span class="keyword">new</span> THREE.OBJLoader(); <span class="comment">//obj加载器</span></span><br><span class="line"><span class="keyword">var</span> MTLLoader = <span class="keyword">new</span> THREE.MTLLoader(); <span class="comment">//材质文件加载器</span></span><br><span class="line">MTLLoader.load(<span class="string">'./贴图/material.mtl'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">materials</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回一个包含材质的对象MaterialCreator</span></span><br><span class="line">  <span class="built_in">console</span>.log(materials);</span><br><span class="line">  <span class="comment">//obj的模型会和MaterialCreator包含的材质对应起来</span></span><br><span class="line">  OBJLoader.setMaterials(materials);</span><br><span class="line">  OBJLoader.load(<span class="string">'./贴图/model.obj'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(obj);</span><br><span class="line">    scene.add(obj); <span class="comment">//返回的组对象插入场景中</span></span><br><span class="line">    <span class="comment">// 加载后操作</span></span><br><span class="line">    obj.children[<span class="number">0</span>].scale.set(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>); <span class="comment">//缩放球体网格模型</span></span><br><span class="line">    <span class="comment">// 通过调节参数，地球表面的凹凸感更强</span></span><br><span class="line">    obj.children[<span class="number">0</span>].material.normalScale.set(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="导出-obj和-mtl的名称、路径问题"><a href="#导出-obj和-mtl的名称、路径问题" class="headerlink" title="导出.obj和.mtl的名称、路径问题"></a>导出.obj和.mtl的名称、路径问题</h2><ul>
<li>3dmax导出的obj和mtl模型文件有时候需要修改一下个别位置字符</li>
<li>比如.obj中.mtl文件的名称可能是乱码mtllib �����.mtl，.mtl文件中贴图的路径要设置正确</li>
</ul>
<h2 id="obj文件不包含信息"><a href="#obj文件不包含信息" class="headerlink" title=".obj文件不包含信息"></a>.obj文件不包含信息</h2><ul>
<li>.obj文件不包含场景的相机Camera、光源Light等信息</li>
<li>不能导出骨骼动画、变形动画</li>
<li>如果希望导出光照信息、相机信息、骨骼动画信息、变形动画信息，可以选择.fbx、.gltf等格式。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Three.js数据结构导入导出</title>
    <url>/2020/07/28/02web/ThreeJS/14%E6%A8%A1%E5%9E%8B%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/04%E5%8A%A0%E8%BD%BDFBX%E5%B9%B6%E8%A7%A3%E6%9E%90%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<p>通过Threejs先加载一个.FBX格式的三维模型文件，然后解析该文件中的骨骼动画信息。</p>
<h1 id="加载器FBXLoader-js"><a href="#加载器FBXLoader-js" class="headerlink" title="加载器FBXLoader.js"></a>加载器FBXLoader.js</h1><p>引入FBX加载器相关文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入fbx模型加载库FBXLoader --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://www.yanhuangxueyuan.com/versions/threejsR92/examples/js/loaders/FBXLoader.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 辅助文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://www.yanhuangxueyuan.com/versions/threejsR92/examples/js/libs/inflate.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="加载fbx模型文件"><a href="#加载fbx模型文件" class="headerlink" title="加载fbx模型文件"></a>加载fbx模型文件</h1><p>加载模型文件，加载完成后，如果模型显示位置不符合要求，可以让3D美术修改，也可以通过Threejs程序进行平移、缩放等操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> loader = <span class="keyword">new</span> THREE.FBXLoader();<span class="comment">//创建一个FBX加载器</span></span><br><span class="line">loader.load(<span class="string">"SambaDancing.fbx"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log(obj);//查看加载后返回的模型对象</span></span><br><span class="line">  scene.add(obj)</span><br><span class="line">  <span class="comment">// 适当平移fbx模型位置</span></span><br><span class="line">  obj.translateY(<span class="number">-80</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="FBX模型帧动画数据"><a href="#FBX模型帧动画数据" class="headerlink" title="FBX模型帧动画数据"></a>FBX模型帧动画数据</h1><ul>
<li>stl、obj都是静态模型，不可以包含动画</li>
<li>fbx除了包含几何、材质信息，可以存储骨骼动画等数据</li>
<li>obj.animations属性的数组包含两个剪辑对象AnimationClip<ul>
<li>obj.animations[0]对应剪辑对象AnimationClip包含多组关键帧KeyframeTrack数据</li>
<li>obj.animations[1]对应的剪辑对象AnimationClip没有关键帧数据，也就是说没有关键帧动画</li>
</ul>
</li>
<li>具体的开发中，可能美术提供的模型有很多包含关键帧动画的剪辑对象AnimationClip，你可以根据自己的需要解析某个剪辑对象AnimationClip对应的动画</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> loader = <span class="keyword">new</span> THREE.FBXLoader();<span class="comment">//创建一个FBX加载器</span></span><br><span class="line">loader.load(<span class="string">"SambaDancing.fbx"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 可以在控制台打印obj对象，找到animations属性</span></span><br><span class="line">  <span class="built_in">console</span>.log(obj)</span><br><span class="line">  <span class="comment">// 查看动画数据  2个剪辑对象AnimationClip，一个有关键帧动画，一个没有</span></span><br><span class="line">  <span class="built_in">console</span>.log(obj.animations)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="解析fbx模型骨骼动画"><a href="#解析fbx模型骨骼动画" class="headerlink" title="解析fbx模型骨骼动画"></a>解析fbx模型骨骼动画</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mixer=<span class="literal">null</span>;<span class="comment">//声明一个混合器变量</span></span><br><span class="line"><span class="keyword">var</span> loader = <span class="keyword">new</span> THREE.FBXLoader();<span class="comment">//创建一个FBX加载器</span></span><br><span class="line">loader.load(<span class="string">"SambaDancing.fbx"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log(obj)</span></span><br><span class="line">  scene.add(obj)</span><br><span class="line">  obj.translateY(<span class="number">-80</span>);</span><br><span class="line">  <span class="comment">// obj作为参数创建一个混合器，解析播放obj及其子对象包含的动画数据</span></span><br><span class="line">  mixer = <span class="keyword">new</span> THREE.AnimationMixer(obj);</span><br><span class="line">  <span class="comment">// 查看动画数据</span></span><br><span class="line">  <span class="built_in">console</span>.log(obj.animations)</span><br><span class="line">  <span class="comment">// obj.animations[0]：获得剪辑对象clip</span></span><br><span class="line">  <span class="keyword">var</span> AnimationAction=mixer.clipAction(obj.animations[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">// AnimationAction.timeScale = 1; //默认1，可以调节播放速度</span></span><br><span class="line">  <span class="comment">// AnimationAction.loop = THREE.LoopOnce; //不循环播放</span></span><br><span class="line">  <span class="comment">// AnimationAction.clampWhenFinished=true;//暂停在最后一帧播放的状态</span></span><br><span class="line">  AnimationAction.play();<span class="comment">//播放动画</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个时钟对象Clock</span></span><br><span class="line"><span class="keyword">var</span> clock = <span class="keyword">new</span> THREE.Clock();</span><br><span class="line"><span class="comment">// 渲染函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  renderer.render(scene, camera); <span class="comment">//执行渲染操作</span></span><br><span class="line">  requestAnimationFrame(render); <span class="comment">//请求再次执行渲染函数render，渲染下一帧</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mixer !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//clock.getDelta()方法获得两帧的时间间隔</span></span><br><span class="line">    <span class="comment">// 更新混合器相关的时间</span></span><br><span class="line">    mixer.update(clock.getDelta());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">render();</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>在线预览案例</title>
    <url>/2020/07/29/02web/ThreeJS/14%E6%A8%A1%E5%9E%8B%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/05%E5%9C%A8%E7%BA%BF%E9%A2%84%E8%A7%88%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<h1 id="商品预览"><a href="#商品预览" class="headerlink" title="商品预览"></a>商品预览</h1><h2 id="设置纹理贴图"><a href="#设置纹理贴图" class="headerlink" title="设置纹理贴图"></a>设置纹理贴图</h2><p>model.obj文件中已经包含纹理映射的UV坐标数据，直接给模型颜色贴图属性.map赋值即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * OBJ文件加载  只加载obj文件中的几何信息，不加载材质文件.mtl</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> loader = <span class="keyword">new</span> THREE.OBJLoader();</span><br><span class="line">loader.load(<span class="string">'./model.obj'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 控制台查看返回结构：包含一个网格模型Mesh的组Group</span></span><br><span class="line">  <span class="comment">// console.log(obj);</span></span><br><span class="line">  <span class="comment">//加载纹理贴图texture1.png</span></span><br><span class="line">  <span class="keyword">var</span> texture = <span class="keyword">new</span> THREE.TextureLoader().load(<span class="string">'texture1.png'</span>);</span><br><span class="line">  <span class="comment">// 颜色贴图中已经包含了光照信息，所以直接使用不受光照影响的基础网格材质MeshBasicMaterial</span></span><br><span class="line">  obj.children[<span class="number">0</span>].material= <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123;</span><br><span class="line">    map:texture,<span class="comment">//设置颜色纹理贴图</span></span><br><span class="line">  &#125;)</span><br><span class="line">  scene.add(obj);</span><br><span class="line">  obj.children[<span class="number">0</span>].scale.set(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>);<span class="comment">//网格模型缩放</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="切换颜色"><a href="#切换颜色" class="headerlink" title="切换颜色"></a>切换颜色</h2><p>可以在上面代码.load()回调函数中插入下面语句，给玉镯设置其它的颜色款式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更换纹理贴图</span></span><br><span class="line"><span class="keyword">var</span> texture = <span class="keyword">new</span> THREE.TextureLoader().load(<span class="string">'texture2.png'</span>);</span><br><span class="line">obj.children[<span class="number">0</span>].material.map=texture</span><br></pre></td></tr></table></figure>

<h1 id="心脏在线预览-法线、高光贴图"><a href="#心脏在线预览-法线、高光贴图" class="headerlink" title="心脏在线预览(法线、高光贴图)"></a>心脏在线预览(法线、高光贴图)</h1><h2 id="心脏次时代模型加载设置"><a href="#心脏次时代模型加载设置" class="headerlink" title="心脏次时代模型加载设置"></a>心脏次时代模型加载设置</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * OBJ文件加载  只加载obj文件中的几何信息，不加载材质文件.mtl</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> loader = <span class="keyword">new</span> THREE.OBJLoader();</span><br><span class="line"><span class="comment">// 没有材质文件，系统自动设置Phong网格材质</span></span><br><span class="line"><span class="keyword">var</span> mesh = <span class="literal">null</span>; <span class="comment">//声明一个网格模型变量</span></span><br><span class="line">loader.load(<span class="string">'./heart/model.obj'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 控制台查看返回结构：包含一个网格模型Mesh的组Group</span></span><br><span class="line">  <span class="built_in">console</span>.log(obj);</span><br><span class="line">  scene.add(obj);</span><br><span class="line">  mesh = obj.children[<span class="number">0</span>]; <span class="comment">//获得心脏网格模型</span></span><br><span class="line">  mesh.scale.set(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>); <span class="comment">//网格模型缩放</span></span><br><span class="line">  <span class="comment">// 创建一个纹理加载器</span></span><br><span class="line">  <span class="keyword">var</span> textureLoader = <span class="keyword">new</span> THREE.TextureLoader();</span><br><span class="line">...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="设置模型的颜色贴图-map"><a href="#设置模型的颜色贴图-map" class="headerlink" title="设置模型的颜色贴图.map"></a>设置模型的颜色贴图.map</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载颜色纹理</span></span><br><span class="line"><span class="keyword">var</span> texture = textureLoader.load(<span class="string">'./heart/color.png'</span>);</span><br><span class="line">mesh.material.map = texture;</span><br></pre></td></tr></table></figure>

<h2 id="设置模型的法线贴图-normalMap"><a href="#设置模型的法线贴图-normalMap" class="headerlink" title="设置模型的法线贴图.normalMap"></a>设置模型的法线贴图.normalMap</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> textureNormal = textureLoader.load(<span class="string">'./heart/normal.png'</span>);</span><br><span class="line">mesh.material.normalMap = textureNormal</span><br><span class="line"><span class="comment">// 设置深浅程度</span></span><br><span class="line">mesh.material.normalScale.set(<span class="number">1.5</span>, <span class="number">1.5</span>)</span><br></pre></td></tr></table></figure>

<h2 id="高光贴图-specularMap"><a href="#高光贴图-specularMap" class="headerlink" title="高光贴图.specularMap"></a>高光贴图.specularMap</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置高光贴图，一个网格模型不同的区域反射光线的能力不同</span></span><br><span class="line"><span class="keyword">var</span> textureSpecular = textureLoader.load(<span class="string">'./heart/Specular.png'</span>);</span><br><span class="line">mesh.material.specularMap = textureSpecular;</span><br><span class="line">mesh.material.specular.set(<span class="number">0xffffff</span>);<span class="comment">// 高光反射颜色</span></span><br><span class="line">mesh.material.shininess = <span class="number">100</span>;<span class="comment">// 高光高亮程度，默认30</span></span><br></pre></td></tr></table></figure>

<h2 id="设置环境贴图-envMap"><a href="#设置环境贴图-envMap" class="headerlink" title="设置环境贴图.envMap"></a>设置环境贴图.envMap</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> textureCube = <span class="keyword">new</span> THREE.CubeTextureLoader()</span><br><span class="line">  .setPath(<span class="string">'环境贴图/'</span>)</span><br><span class="line">  .load([<span class="string">'px.jpg'</span>, <span class="string">'nx.jpg'</span>, <span class="string">'py.jpg'</span>, <span class="string">'ny.jpg'</span>, <span class="string">'pz.jpg'</span>, <span class="string">'nz.jpg'</span>]);</span><br><span class="line">mesh.material.envMap = textureCube;</span><br></pre></td></tr></table></figure>

<h2 id="设置光源"><a href="#设置光源" class="headerlink" title="设置光源"></a>设置光源</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 光源设置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//点光源</span></span><br><span class="line"><span class="keyword">var</span> point = <span class="keyword">new</span> THREE.PointLight(<span class="number">0xffffff</span>, <span class="number">0.3</span>);</span><br><span class="line">point.position.set(<span class="number">400</span>, <span class="number">200</span>, <span class="number">300</span>); <span class="comment">//点光源位置</span></span><br><span class="line">scene.add(point); <span class="comment">//点光源添加到场景中</span></span><br><span class="line"><span class="comment">// 环境光</span></span><br><span class="line"><span class="keyword">var</span> ambient = <span class="keyword">new</span> THREE.AmbientLight(<span class="number">0xffffff</span>, <span class="number">0.8</span>);</span><br><span class="line">scene.add(ambient);</span><br><span class="line"><span class="comment">// 方向光1</span></span><br><span class="line"><span class="keyword">var</span> directionalLight = <span class="keyword">new</span> THREE.DirectionalLight(<span class="number">0xffffff</span>, <span class="number">0.5</span>);</span><br><span class="line">directionalLight.position.set(<span class="number">400</span>, <span class="number">200</span>, <span class="number">300</span>);</span><br><span class="line">scene.add(directionalLight);</span><br><span class="line"><span class="comment">// 方向光2</span></span><br><span class="line"><span class="keyword">var</span> directionalLight = <span class="keyword">new</span> THREE.DirectionalLight(<span class="number">0xffffff</span>, <span class="number">0.5</span>);</span><br><span class="line">directionalLight.position.set(<span class="number">-400</span>, <span class="number">-200</span>, <span class="number">-300</span>);</span><br><span class="line">scene.add(directionalLight);</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>音频与场景关连</title>
    <url>/2020/07/28/02web/ThreeJS/13%E8%AF%AD%E9%9F%B3%E6%A8%A1%E5%9D%97/01%E9%9F%B3%E9%A2%91%E4%B8%8E%E5%9C%BA%E6%99%AF%E5%85%B3%E8%81%94/</url>
    <content><![CDATA[<h1 id="非位置音频THREE-Audio"><a href="#非位置音频THREE-Audio" class="headerlink" title="非位置音频THREE.Audio"></a>非位置音频THREE.Audio</h1><ul>
<li>音频播放效果不受具体位置影响</li>
<li>一般可以用于一个三维场景的背景音乐</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非位置音频可用于不考虑位置的背景音乐</span></span><br><span class="line"><span class="comment">// 创建一个监听者</span></span><br><span class="line"><span class="keyword">var</span> listener = <span class="keyword">new</span> THREE.AudioListener();</span><br><span class="line"><span class="comment">// camera.add( listener );</span></span><br><span class="line"><span class="comment">// 创建一个非位置音频对象  用来控制播放</span></span><br><span class="line"><span class="keyword">var</span> audio = <span class="keyword">new</span> THREE.Audio(listener);</span><br><span class="line"><span class="comment">// 创建一个音频加载器对象</span></span><br><span class="line"><span class="keyword">var</span> audioLoader = <span class="keyword">new</span> THREE.AudioLoader();</span><br><span class="line"><span class="comment">// 加载音频文件，返回一个音频缓冲区对象作为回调函数参数</span></span><br><span class="line">audioLoader.load(<span class="string">'中国人.mp3'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">AudioBuffer</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log(AudioBuffer)</span></span><br><span class="line">  <span class="comment">// 音频缓冲区对象关联到音频对象audio</span></span><br><span class="line">  audio.setBuffer(AudioBuffer);</span><br><span class="line">  audio.setLoop(<span class="literal">true</span>); <span class="comment">//是否循环</span></span><br><span class="line">  audio.setVolume(<span class="number">0.5</span>); <span class="comment">//音量</span></span><br><span class="line">  <span class="comment">// 播放缓冲区中的音频数据</span></span><br><span class="line">  audio.play(); <span class="comment">//play播放、stop停止、pause暂停</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="位置音频THREE-PositionalAudio"><a href="#位置音频THREE-PositionalAudio" class="headerlink" title="位置音频THREE.PositionalAudio"></a>位置音频THREE.PositionalAudio</h1><ul>
<li>在实际生活中，听到声音的效果，受音源相对监听者的位置和角度影响</li>
<li>频源位置发生变化，听到的声音有所变化</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// 用来定位音源的网格模型</span></span><br><span class="line"><span class="keyword">var</span> audioMesh = <span class="keyword">new</span> THREE.Mesh(geometry, material);</span><br><span class="line"><span class="comment">// 设置网格模型的位置，相当于设置音源的位置</span></span><br><span class="line">audioMesh.position.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">300</span>);</span><br><span class="line">scene.add(audioMesh);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个虚拟的监听者</span></span><br><span class="line"><span class="keyword">var</span> listener = <span class="keyword">new</span> THREE.AudioListener();</span><br><span class="line"><span class="comment">// 监听者绑定到相机对象</span></span><br><span class="line">camera.add(listener);</span><br><span class="line"><span class="comment">// 创建一个位置音频对象,监听者作为参数,音频和监听者关联。</span></span><br><span class="line"><span class="keyword">var</span> PosAudio = <span class="keyword">new</span> THREE.PositionalAudio(listener);</span><br><span class="line"><span class="comment">//音源绑定到一个网格模型上</span></span><br><span class="line">audioMesh.add(PosAudio);</span><br><span class="line"><span class="comment">// 创建一个音频加载器</span></span><br><span class="line"><span class="keyword">var</span> audioLoader = <span class="keyword">new</span> THREE.AudioLoader();</span><br><span class="line"><span class="comment">// 加载音频文件，返回一个音频缓冲区对象作为回调函数参数</span></span><br><span class="line">audioLoader.load(<span class="string">'./中国人.mp3'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">AudioBuffer</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log(buffer);</span></span><br><span class="line">  <span class="comment">// 音频缓冲区对象关联到音频对象audio</span></span><br><span class="line">  PosAudio.setBuffer(AudioBuffer);</span><br><span class="line">  PosAudio.setVolume(<span class="number">0.9</span>); <span class="comment">//音量</span></span><br><span class="line">  PosAudio.setRefDistance(<span class="number">200</span>); <span class="comment">//参数值越大,声音越大</span></span><br><span class="line">  PosAudio.play(); <span class="comment">//播放</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>渲染页面</title>
    <url>/2020/07/29/02web/ThreeJS/14%E6%A8%A1%E5%9E%8B%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/06%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<h1 id="全屏渲染"><a href="#全屏渲染" class="headerlink" title="全屏渲染"></a>全屏渲染</h1><p>直接通过Three.js的WebGL渲染器WebGLRenderer的.setSize()方法设置渲染尺寸为浏览器body区域宽高度。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> width = <span class="built_in">window</span>.innerWidth; <span class="comment">//浏览器窗口宽度</span></span><br><span class="line"><span class="keyword">var</span> height = <span class="built_in">window</span>.innerHeight; <span class="comment">//浏览器窗口高度</span></span><br><span class="line"><span class="comment">// 相机参数设置</span></span><br><span class="line"><span class="keyword">var</span> k = width / height;</span><br><span class="line"><span class="keyword">var</span> s = <span class="number">150</span>;</span><br><span class="line"><span class="comment">//正投影相机设置</span></span><br><span class="line"><span class="keyword">var</span> camera = <span class="keyword">new</span> THREE.OrthographicCamera(-s * k, s * k, s, -s, <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">//透视投影相机设置</span></span><br><span class="line"><span class="comment">// var camera = new THREE.PerspectiveCamera(60, width / height, 1, 1000);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer();</span><br><span class="line"><span class="comment">//设置渲染区域尺寸</span></span><br><span class="line">renderer.setSize(width, height);</span><br><span class="line"><span class="comment">// body元素中插入Threejs渲染结果：canvas对象</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(renderer.domElement);</span><br></pre></td></tr></table></figure>

<h1 id="局部渲染"><a href="#局部渲染" class="headerlink" title="局部渲染"></a>局部渲染</h1><p>下面代码实现的功能是Threejs渲染区域尺寸是300x300px，渲染结果.domElement(Canvas元素)插入到一个div元素中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 把Three.js渲染结果一个canvas元素插入到div中 --&gt;</span><br><span class="line">&lt;div id=<span class="string">"pos"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 注意相机参数设置</span></span><br><span class="line"><span class="regexp">var width = 300; /</span><span class="regexp">/窗口宽度</span></span><br><span class="line"><span class="regexp">var height = 300; /</span><span class="regexp">/窗口高度</span></span><br><span class="line"><span class="regexp">var k = width /</span> height; <span class="comment">//窗口宽高比</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="number">150</span>; <span class="comment">//三维场景显示范围控制系数，系数越大，显示的范围越大</span></span><br><span class="line"><span class="comment">//正投影相机设置</span></span><br><span class="line"><span class="keyword">var</span> camera = <span class="keyword">new</span> THREE.OrthographicCamera(-s * k, s * k, s, -s, <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">//透视投影相机设置</span></span><br><span class="line"><span class="comment">// var camera = new THREE.PerspectiveCamera(60, width / height, 1, 1000);</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer();</span><br><span class="line"><span class="comment">// 设置渲染区域尺寸，本质就是设置输出canvas的尺寸</span></span><br><span class="line">renderer.setSize(<span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line"><span class="comment">// 把渲染器的渲染结果canvas对象插入到'pos'对应的div元素中</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'pos'</span>).appendChild(renderer.domElement);</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以通过渲染结果.domElement(Canvas元素)的父元素div来控制渲染区域在浏览器上的位置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 控制div位置 绝对定位  距离上方<span class="number">100</span>px  距离左侧<span class="number">30</span>px --&gt;</span><br><span class="line">&lt;div id=<span class="string">"pos"</span> style=<span class="string">"position: absolute;left: 30px;top: 100px;"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="相机控件OrbitControls作用范围"><a href="#相机控件OrbitControls作用范围" class="headerlink" title="相机控件OrbitControls作用范围"></a>相机控件OrbitControls作用范围</h1><ul>
<li>如果渲染区域变化了，不仅仅要改变WebGL渲染器相关参数，</li>
<li>如果使用的其它扩展库与Threejs渲染范围有关，</li>
<li>比如OrbitControls.js<ul>
<li>也需要设置该控件的鼠标作用范围</li>
<li>通过OrbitControls创建一个相机控件对象的时候</li>
<li>默认情况下，在浏览器的窗口整个内容区域body发生鼠标事件都会旋转、平移或缩放三维场景</li>
<li>如果局部渲染，注意设置构造函数THREE.OrbitControls的参数。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 局部渲染设置OrbitControls空间作用范围</span></span><br><span class="line"><span class="keyword">var</span> controls = <span class="keyword">new</span> THREE.OrbitControls(camera, renderer.domElement);</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>简单实现</title>
    <url>/2020/09/08/02web/GraphQL/02%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="简答实现"><a href="#简答实现" class="headerlink" title="简答实现"></a>简答实现</h1><p>用express创建一个服务端</p>
<h2 id="初始化一个项目"><a href="#初始化一个项目" class="headerlink" title="初始化一个项目"></a>初始化一个项目</h2><p>新建一个graphql_express文件夹</p>
<blockquote>
<p>npm init –y</p>
</blockquote>
<p>安装依赖包</p>
<blockquote>
<p>npm install –save -D express express-graphql graphql</p>
</blockquote>
<p>一个简单的示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> graphqlHTTP = <span class="built_in">require</span>(<span class="string">'express-graphql'</span>).graphqlHTTP;;</span><br><span class="line"><span class="keyword">var</span> &#123; buildSchema &#125; = <span class="built_in">require</span>(<span class="string">'graphql'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> schema = buildSchema(<span class="string">`</span></span><br><span class="line"><span class="string">  type Query &#123;</span></span><br><span class="line"><span class="string">    hello: String</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> root = &#123;</span><br><span class="line">    hello: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Hello world!'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.use(<span class="string">'/graphql'</span>, graphqlHTTP(&#123;</span><br><span class="line">    schema: schema,</span><br><span class="line">    rootValue: root,</span><br><span class="line">    graphiql: <span class="literal">true</span>,</span><br><span class="line">&#125;));</span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'Now browse to localhost:4000/graphql'</span>));</span><br></pre></td></tr></table></figure>

<p>打开<a href="http://localhost:3000/graphql" target="_blank" rel="noopener">http://localhost:3000/graphql</a></p>
<p>查询处输入</p>
<blockquote>
<p>query{hello}</p>
</blockquote>
<p><img src="./01.png" alt="初始化一个项目"></p>
<h2 id="多个条件"><a href="#多个条件" class="headerlink" title="多个条件"></a>多个条件</h2><ul>
<li>在root中添加新的数据</li>
<li>root中添加renturn的返回值</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> graphqlHTTP = <span class="built_in">require</span>(<span class="string">'express-graphql'</span>).graphqlHTTP;;</span><br><span class="line"><span class="keyword">var</span> &#123; buildSchema &#125; = <span class="built_in">require</span>(<span class="string">'graphql'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> schema = buildSchema(<span class="string">`</span></span><br><span class="line"><span class="string">  type Query &#123;</span></span><br><span class="line"><span class="string">    hello: String</span></span><br><span class="line"><span class="string">    accountNam: String</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> root = &#123;</span><br><span class="line">    hello: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Hello world!'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    accountNam:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"linjiad"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.use(<span class="string">'/graphql'</span>, graphqlHTTP(&#123;</span><br><span class="line">    schema: schema,</span><br><span class="line">    rootValue: root,</span><br><span class="line">    graphiql: <span class="literal">true</span>,</span><br><span class="line">&#125;));</span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'Now browse to localhost:4000/graphql'</span>));</span><br></pre></td></tr></table></figure>

<h2 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h2><ul>
<li>myType是我们自定义的类型<ul>
<li>用type定义类型</li>
<li>把myType放到Query（account）</li>
<li>account定义到root中</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> graphqlHTTP = <span class="built_in">require</span>(<span class="string">'express-graphql'</span>).graphqlHTTP;;</span><br><span class="line"><span class="keyword">var</span> &#123; buildSchema &#125; = <span class="built_in">require</span>(<span class="string">'graphql'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> schema = buildSchema(<span class="string">`</span></span><br><span class="line"><span class="string">  type myType &#123;</span></span><br><span class="line"><span class="string">    name: String</span></span><br><span class="line"><span class="string">    age: Int</span></span><br><span class="line"><span class="string">    sex: String</span></span><br><span class="line"><span class="string">    department: String</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  type Query &#123;</span></span><br><span class="line"><span class="string">    hello: String</span></span><br><span class="line"><span class="string">    accountNam: String</span></span><br><span class="line"><span class="string">    account: myType</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> root = &#123;</span><br><span class="line">    hello: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Hello world!'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    accountNam:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"linjiad"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    account:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            name:<span class="string">"linjiad"</span>,</span><br><span class="line">            age:<span class="number">18</span>,</span><br><span class="line">            sex:<span class="string">"男"</span>,</span><br><span class="line">            department:<span class="string">"科学院"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.use(<span class="string">'/graphql'</span>, graphqlHTTP(&#123;</span><br><span class="line">    schema: schema,</span><br><span class="line">    rootValue: root,</span><br><span class="line">    graphiql: <span class="literal">true</span>,</span><br><span class="line">&#125;));</span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'Now browse to localhost:3000/graphql'</span>));</span><br></pre></td></tr></table></figure>

<p>这时候可以访问特定字段</p>
<blockquote>
<p>query{<br>    account {<br>      name<br>      age<br>    }<br>  }</p>
</blockquote>
<p><img src="./02.png" alt="自定义类型"></p>
<h2 id="查询条件"><a href="#查询条件" class="headerlink" title="查询条件"></a>查询条件</h2><p>根据查询条件查询</p>
<ul>
<li>getClassMates(classNo: Int!):[String]<ul>
<li>定义查询方法</li>
<li>括号内定义参数和参数类型</li>
</ul>
</li>
<li>getClassMates({classNo}){})<ul>
<li>方法的返回值</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ————————————————————————————查询条件————————————————————————</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> graphqlHTTP = <span class="built_in">require</span>(<span class="string">'express-graphql'</span>).graphqlHTTP;;</span><br><span class="line"><span class="keyword">var</span> &#123; buildSchema &#125; = <span class="built_in">require</span>(<span class="string">'graphql'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// getClassMates(classNo:31)就是查询</span></span><br><span class="line"><span class="keyword">var</span> schema = buildSchema(<span class="string">`</span></span><br><span class="line"><span class="string">  type Query &#123;</span></span><br><span class="line"><span class="string">    getClassMates(classNo: Int!):[String]</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> root = &#123;</span><br><span class="line">    <span class="comment">// 处理getClassMates()查询返回值</span></span><br><span class="line">    getClassMates(&#123;classNo&#125;)&#123;</span><br><span class="line">        <span class="keyword">const</span> obj = &#123;</span><br><span class="line">            <span class="number">31</span>:[<span class="string">"张三"</span>,<span class="string">"李四"</span>,<span class="string">"王五"</span>],</span><br><span class="line">            <span class="number">62</span>:[<span class="string">"张三大"</span>,<span class="string">"李四大"</span>,<span class="string">"王五大"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj[classNo];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.use(<span class="string">'/graphql'</span>, graphqlHTTP(&#123;</span><br><span class="line">    schema: schema,</span><br><span class="line">    rootValue: root,</span><br><span class="line">    graphiql: <span class="literal">true</span>,</span><br><span class="line">&#125;));</span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'Now browse to localhost:3000/graphql'</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>query{<br>    getClassMates(classNo:31)<br>  }</p>
</blockquote>
<p><img src="./03.png" alt="查询条件"></p>
<h2 id="查询条件包含查询条件"><a href="#查询条件包含查询条件" class="headerlink" title="查询条件包含查询条件"></a>查询条件包含查询条件</h2><p>根据查询条件查询</p>
<ul>
<li>定义查询类型Account</li>
<li>account(username:String):Account<ul>
<li>定义查询方法</li>
<li>括号内定义参数和参数类型</li>
<li>返回类型</li>
</ul>
</li>
<li>account({username})<ul>
<li>方法的返回值</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ————————————————————————————查询条件————————————————————————</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> graphqlHTTP = <span class="built_in">require</span>(<span class="string">'express-graphql'</span>).graphqlHTTP;;</span><br><span class="line"><span class="keyword">var</span> &#123; buildSchema &#125; = <span class="built_in">require</span>(<span class="string">'graphql'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// getClassMates(classNo:31)就是查询</span></span><br><span class="line"><span class="keyword">var</span> schema = buildSchema(<span class="string">`</span></span><br><span class="line"><span class="string">  type Account &#123;</span></span><br><span class="line"><span class="string">    name: String</span></span><br><span class="line"><span class="string">    age: Int</span></span><br><span class="line"><span class="string">    sex: String</span></span><br><span class="line"><span class="string">    department: String</span></span><br><span class="line"><span class="string">    salary(city:String):Int</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  type Query &#123;</span></span><br><span class="line"><span class="string">    getClassMates(classNo: Int!):[String]</span></span><br><span class="line"><span class="string">    account(username:String):Account</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> root = &#123;</span><br><span class="line">    <span class="comment">// 处理getClassMates()查询返回值</span></span><br><span class="line">    getClassMates(&#123;classNo&#125;)&#123;</span><br><span class="line">        <span class="keyword">const</span> obj = &#123;</span><br><span class="line">            <span class="number">31</span>:[<span class="string">"张三"</span>,<span class="string">"李四"</span>,<span class="string">"王五"</span>],</span><br><span class="line">            <span class="number">62</span>:[<span class="string">"张三大"</span>,<span class="string">"李四大"</span>,<span class="string">"王五大"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj[classNo];</span><br><span class="line">    &#125;,</span><br><span class="line">    account(&#123;username&#125;)&#123;</span><br><span class="line">        <span class="keyword">const</span> name = username;</span><br><span class="line">        <span class="keyword">const</span> sex = <span class="string">"man"</span>;</span><br><span class="line">        <span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line">        <span class="keyword">const</span> department = <span class="string">"开发部"</span>;</span><br><span class="line">        <span class="keyword">const</span> salary = <span class="function">(<span class="params">&#123;city&#125;</span>) =&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(city === <span class="string">"北京"</span> || city=== <span class="string">"上海"</span> || city ===<span class="string">"广州"</span> || city===<span class="string">"深圳"</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">10000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            name,</span><br><span class="line">            sex,</span><br><span class="line">            age,</span><br><span class="line">            department,</span><br><span class="line">            salary</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.use(<span class="string">'/graphql'</span>, graphqlHTTP(&#123;</span><br><span class="line">    schema: schema,</span><br><span class="line">    rootValue: root,</span><br><span class="line">    graphiql: <span class="literal">true</span>,</span><br><span class="line">&#125;));</span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'Now browse to localhost:3000/graphql'</span>));</span><br></pre></td></tr></table></figure>

<p><img src="./04.png" alt="查询条件"></p>
<blockquote>
<p>query{<br>    account(username:”张三”){<br>      name<br>      sex<br>      age<br>      salary(city:”南京”)<br>    }<br>  }</p>
</blockquote>
<h2 id="客户端访问"><a href="#客户端访问" class="headerlink" title="客户端访问"></a>客户端访问</h2><ul>
<li>首先创建一个public空文件夹</li>
<li>之后配置让node能返回这个静态文件<ul>
<li>app.use(express.static(“public”))</li>
</ul>
</li>
<li>再public下创建index.html</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"getData()"</span>&gt;</span>获取数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">const</span> query = `</span></span><br><span class="line"><span class="javascript">         query Account($username:<span class="built_in">String</span>)&#123;</span></span><br><span class="line">            account(username:$username)&#123;</span><br><span class="line">                name</span><br><span class="line">                age</span><br><span class="line">                sex</span><br><span class="line"><span class="actionscript">                salary(city:<span class="string">"北京"</span>)</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        `</span><br><span class="line"><span class="actionscript">        <span class="keyword">const</span> variables = &#123;username:<span class="string">"李四大"</span>&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        fetch(<span class="string">"/graphql"</span>,&#123;</span></span><br><span class="line"><span class="actionscript">            method:<span class="string">"POST"</span>,</span></span><br><span class="line">            headers:&#123;</span><br><span class="line"><span class="actionscript">                <span class="string">'Content-Type'</span>:<span class="string">'application/json'</span>,</span></span><br><span class="line"><span class="actionscript">                <span class="string">'Accept'</span>:<span class="string">'application/json'</span></span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            body:<span class="built_in">JSON</span>.stringify(&#123;</span></span><br><span class="line">                query:query,</span><br><span class="line">                variables:variables</span><br><span class="line">            &#125;)</span><br><span class="line"><span class="javascript">        &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span></span><br><span class="line"><span class="javascript">        .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.dir(data);</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="把城市也变成参数"><a href="#把城市也变成参数" class="headerlink" title="把城市也变成参数"></a>把城市也变成参数</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"getData()"</span>&gt;</span>获取数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 把城市也拿出来当作参数</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">const</span> query = `</span></span><br><span class="line"><span class="javascript">         query Account($username:<span class="built_in">String</span>,<span class="attr">$city</span>:<span class="built_in">String</span>)&#123;</span></span><br><span class="line">            account(username:$username)&#123;</span><br><span class="line">                name</span><br><span class="line">                age</span><br><span class="line">                sex</span><br><span class="line">                salary(city:$city)</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        `</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="keyword">const</span> variables = &#123;username:<span class="string">"李四大"</span>,city:<span class="string">"重庆"</span>&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        fetch(<span class="string">"/graphql"</span>,&#123;</span></span><br><span class="line"><span class="actionscript">            method:<span class="string">"POST"</span>,</span></span><br><span class="line">            headers:&#123;</span><br><span class="line"><span class="actionscript">                <span class="string">'Content-Type'</span>:<span class="string">'application/json'</span>,</span></span><br><span class="line"><span class="actionscript">                <span class="string">'Accept'</span>:<span class="string">'application/json'</span></span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            body:<span class="built_in">JSON</span>.stringify(&#123;</span></span><br><span class="line">                query:query,</span><br><span class="line">                variables:variables</span><br><span class="line">            &#125;)</span><br><span class="line"><span class="javascript">        &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span></span><br><span class="line"><span class="javascript">        .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.dir(data);</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="使用Mutations修改数据"><a href="#使用Mutations修改数据" class="headerlink" title="使用Mutations修改数据"></a>使用Mutations修改数据</h2><ul>
<li>新建一个增加类——————input AccountInput</li>
<li>定义新增方法——————createAccount(input:AccountInput):Account</li>
<li>实现新增方法——————createAccount({input})</li>
<li>GraphiQL中必须含有查询类type Query，否则会报错</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ————————————————————————————页面查询————————————————————————</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> graphqlHTTP = <span class="built_in">require</span>(<span class="string">'express-graphql'</span>).graphqlHTTP;;</span><br><span class="line"><span class="keyword">var</span> &#123; buildSchema &#125; = <span class="built_in">require</span>(<span class="string">'graphql'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// getClassMates(classNo:31)就是查询</span></span><br><span class="line"><span class="keyword">var</span> schema = buildSchema(<span class="string">`</span></span><br><span class="line"><span class="string">  input AccountInput&#123;</span></span><br><span class="line"><span class="string">    id: String</span></span><br><span class="line"><span class="string">    name: String</span></span><br><span class="line"><span class="string">    age: Int</span></span><br><span class="line"><span class="string">    sex: String</span></span><br><span class="line"><span class="string">    department: String</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  type Account &#123;</span></span><br><span class="line"><span class="string">    id: String</span></span><br><span class="line"><span class="string">    name: String</span></span><br><span class="line"><span class="string">    age: Int</span></span><br><span class="line"><span class="string">    sex: String</span></span><br><span class="line"><span class="string">    department: String</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  type Mutation&#123;</span></span><br><span class="line"><span class="string">    createAccount(input:AccountInput):Account</span></span><br><span class="line"><span class="string">    updateAccount(id:ID!,input:AccountInput):Account</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  type Query &#123;</span></span><br><span class="line"><span class="string">    account:[Account]</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fakeDb = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> root = &#123;</span><br><span class="line">    <span class="comment">// 处理getClassMates()查询返回值</span></span><br><span class="line">    account()&#123;</span><br><span class="line">        <span class="keyword">var</span> arr = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> fakeDb)&#123;</span><br><span class="line">            arr.push(fakeDb[key])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 新增</span></span><br><span class="line">    createAccount(&#123;input&#125;)&#123;</span><br><span class="line">        <span class="comment">// 相当于数据库保存</span></span><br><span class="line">        fakeDb[input.name] = input;</span><br><span class="line">        <span class="comment">// 返回保存结果</span></span><br><span class="line">        <span class="keyword">return</span> fakeDb[input.name]</span><br><span class="line">    &#125;,</span><br><span class="line">    updateAccount(&#123;id,input&#125;)&#123;</span><br><span class="line">        <span class="comment">// 相当于数据库更新</span></span><br><span class="line">        <span class="keyword">const</span> updateAccount = <span class="built_in">Object</span>.assign(&#123;&#125;,fakeDb[id],input);</span><br><span class="line">        fakeDb[id] = updateAccount;</span><br><span class="line">        <span class="keyword">return</span> updateAccount</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.use(<span class="string">'/graphql'</span>, graphqlHTTP(&#123;</span><br><span class="line">    schema: schema,</span><br><span class="line">    rootValue: root,</span><br><span class="line">    graphiql: <span class="literal">true</span>,</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公开文件夹，供用户访问静态文件</span></span><br><span class="line">app.use(express.static(<span class="string">"public"</span>))</span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'Now browse to localhost:3000/graphql'</span>));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>mutation{<br>    createAccount(input:{<br>      id:”2”,<br>      name:”linjiad2”,<br>      age:18,<br>      sex:”男”,<br>      department:”程序员”<br>    }){<br>      name<br>    }<br>  }<br>  mutation{<br>    updateAccount(id:”1”,input:{<br>      age:19<br>    }){<br>      age<br>    }<br>  }<br>  query{<br>    account{<br>      name<br>      age<br>      sex<br>      department<br>    }<br>  }</p>
</blockquote>
<p><img src="./05.png" alt="查询条件"></p>
<h2 id="添加中间件访问安全"><a href="#添加中间件访问安全" class="headerlink" title="添加中间件访问安全"></a>添加中间件访问安全</h2><p>给服务添加拦截器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义中间件拦截</span></span><br><span class="line"><span class="keyword">const</span> middleware = <span class="function">(<span class="params">req,res,next</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(req.url.indexOf(<span class="string">"/graphql"</span>) !== <span class="number">-1</span> &amp;&amp; req.headers.cookie.indexOf(<span class="string">"auth"</span>) === <span class="number">-1</span>)&#123;</span><br><span class="line">        res.send(<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">            error:<span class="string">"您没有访问这个接口得权限"</span></span><br><span class="line">        &#125;));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br><span class="line">app.use(middleware);</span><br></pre></td></tr></table></figure>

<p>整体代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ————————————————————————————中间件拦截————————————————————————</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> graphqlHTTP = <span class="built_in">require</span>(<span class="string">'express-graphql'</span>).graphqlHTTP;;</span><br><span class="line"><span class="keyword">var</span> &#123; buildSchema &#125; = <span class="built_in">require</span>(<span class="string">'graphql'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// getClassMates(classNo:31)就是查询</span></span><br><span class="line"><span class="keyword">var</span> schema = buildSchema(<span class="string">`</span></span><br><span class="line"><span class="string">  input AccountInput&#123;</span></span><br><span class="line"><span class="string">    id: String</span></span><br><span class="line"><span class="string">    name: String</span></span><br><span class="line"><span class="string">    age: Int</span></span><br><span class="line"><span class="string">    sex: String</span></span><br><span class="line"><span class="string">    department: String</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  type Account &#123;</span></span><br><span class="line"><span class="string">    id: String</span></span><br><span class="line"><span class="string">    name: String</span></span><br><span class="line"><span class="string">    age: Int</span></span><br><span class="line"><span class="string">    sex: String</span></span><br><span class="line"><span class="string">    department: String</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  type Mutation&#123;</span></span><br><span class="line"><span class="string">    createAccount(input:AccountInput):Account</span></span><br><span class="line"><span class="string">    updateAccount(id:ID!,input:AccountInput):Account</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  type Query &#123;</span></span><br><span class="line"><span class="string">    account:[Account]</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fakeDb = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> root = &#123;</span><br><span class="line">    <span class="comment">// 处理getClassMates()查询返回值</span></span><br><span class="line">    account()&#123;</span><br><span class="line">        <span class="keyword">var</span> arr = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> fakeDb)&#123;</span><br><span class="line">            arr.push(fakeDb[key])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 新增</span></span><br><span class="line">    createAccount(&#123;input&#125;)&#123;</span><br><span class="line">        <span class="comment">// 相当于数据库保存</span></span><br><span class="line">        fakeDb[input.name] = input;</span><br><span class="line">        <span class="comment">// 返回保存结果</span></span><br><span class="line">        <span class="keyword">return</span> fakeDb[input.name]</span><br><span class="line">    &#125;,</span><br><span class="line">    updateAccount(&#123;id,input&#125;)&#123;</span><br><span class="line">        <span class="comment">// 相当于数据库更新</span></span><br><span class="line">        <span class="keyword">const</span> updateAccount = <span class="built_in">Object</span>.assign(&#123;&#125;,fakeDb[id],input);</span><br><span class="line">        fakeDb[id] = updateAccount;</span><br><span class="line">        <span class="keyword">return</span> updateAccount</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义中间件拦截</span></span><br><span class="line"><span class="keyword">const</span> middleware = <span class="function">(<span class="params">req,res,next</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(req.url.indexOf(<span class="string">"/graphql"</span>) !== <span class="number">-1</span> &amp;&amp; req.headers.cookie.indexOf(<span class="string">"auth"</span>) === <span class="number">-1</span>)&#123;</span><br><span class="line">        res.send(<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">            error:<span class="string">"您没有访问这个接口得权限"</span></span><br><span class="line">        &#125;));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.use(middleware);</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/graphql'</span>, graphqlHTTP(&#123;</span><br><span class="line">    schema: schema,</span><br><span class="line">    rootValue: root,</span><br><span class="line">    graphiql: <span class="literal">true</span>,</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公开文件夹，供用户访问静态文件</span></span><br><span class="line">app.use(express.static(<span class="string">"public"</span>))</span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'Now browse to localhost:3000/graphql'</span>));</span><br></pre></td></tr></table></figure>

<p><img src="./06.png" alt="查询条件"></p>
<h2 id="使用GraphQLObjectType定义Type"><a href="#使用GraphQLObjectType定义Type" class="headerlink" title="使用GraphQLObjectType定义Type"></a>使用GraphQLObjectType定义Type</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ————————————————————————————GraphQLObjectType实现————————————————————————</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> graphqlHTTP = <span class="built_in">require</span>(<span class="string">'express-graphql'</span>).graphqlHTTP;;</span><br><span class="line"><span class="keyword">var</span> graphql = <span class="built_in">require</span>(<span class="string">'graphql'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> AccountType = <span class="keyword">new</span> graphql.GraphQLObjectType(&#123;</span><br><span class="line">    name: <span class="string">"account"</span>,</span><br><span class="line">    description:<span class="string">"人物描述"</span>,</span><br><span class="line">    fields:&#123;</span><br><span class="line">        name:&#123;<span class="attr">type</span>:graphql.GraphQLString,<span class="attr">description</span>:<span class="string">"姓名"</span>&#125;,</span><br><span class="line">        age:&#123;<span class="attr">type</span>:graphql.GraphQLInt,<span class="attr">description</span>:<span class="string">"年龄"</span>&#125;,</span><br><span class="line">        sex:&#123;<span class="attr">type</span>:graphql.GraphQLString,<span class="attr">description</span>:<span class="string">"性别"</span>&#125;,</span><br><span class="line">        department:&#123;<span class="attr">type</span>:graphql.GraphQLString,<span class="attr">description</span>:<span class="string">"部门"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> queryType = <span class="keyword">new</span> graphql.GraphQLObjectType(&#123;</span><br><span class="line">    name: <span class="string">'Query'</span>,</span><br><span class="line">    description: <span class="string">'查询'</span>,</span><br><span class="line">    fields: &#123;</span><br><span class="line">        account: &#123;</span><br><span class="line">            name: <span class="string">'personQuery'</span>,</span><br><span class="line">            description: <span class="string">'查个人'</span>,</span><br><span class="line">            type: AccountType,</span><br><span class="line">            args: &#123;</span><br><span class="line">                username:&#123;<span class="attr">type</span>:graphql.GraphQLString,<span class="attr">description</span>:<span class="string">"人物姓名"</span>&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            resolve:<span class="function"><span class="keyword">function</span> (<span class="params">_,&#123;username&#125;</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">const</span> name = username;</span><br><span class="line">                <span class="keyword">const</span> sex = <span class="string">"man"</span>;</span><br><span class="line">                <span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line">                <span class="keyword">const</span> department = <span class="string">"程序员"</span>;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    name,</span><br><span class="line">                    sex,</span><br><span class="line">                    age,</span><br><span class="line">                    department</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> schema2 = <span class="keyword">new</span> graphql.GraphQLSchema(&#123;<span class="attr">query</span>: queryType&#125;);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/graphql'</span>, graphqlHTTP(&#123;</span><br><span class="line">    schema: schema2,</span><br><span class="line">    graphiql: <span class="literal">true</span>,</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'Now browse to localhost:3000/graphql'</span>));</span><br></pre></td></tr></table></figure>

<h2 id="结合mysql"><a href="#结合mysql" class="headerlink" title="结合mysql"></a>结合mysql</h2><h3 id="连接mysql"><a href="#连接mysql" class="headerlink" title="连接mysql"></a>连接mysql</h3><ul>
<li>创建mysql数据库和表<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">account</span></span><br><span class="line">(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">int</span> auto_increment,</span><br><span class="line">	<span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">45</span>) <span class="literal">null</span>,</span><br><span class="line">	age <span class="built_in">VARCHAR</span>(<span class="number">45</span>) <span class="literal">null</span>,</span><br><span class="line">	sex <span class="built_in">VARCHAR</span>(<span class="number">45</span>) <span class="literal">null</span>,</span><br><span class="line">	department <span class="built_in">VARCHAR</span>(<span class="number">45</span>) <span class="literal">null</span>,</span><br><span class="line">	<span class="keyword">constraint</span> account_pk</span><br><span class="line">		primary <span class="keyword">key</span> (<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<img src="./07.png" alt="查询条件"></li>
<li>安装mysql包<ul>
<li>npm install mysql -s</li>
<li><a href="https://www.npmjs.com/package/mysql" target="_blank" rel="noopener">https://www.npmjs.com/package/mysql</a></li>
</ul>
</li>
<li>配置数据库连接<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mysql      = <span class="built_in">require</span>(<span class="string">'mysql'</span>);</span><br><span class="line"><span class="keyword">var</span> pool = mysql.createConnection(&#123;</span><br><span class="line">    connectionLimit: <span class="number">10</span>,</span><br><span class="line">    host     : <span class="string">'localhost'</span>,</span><br><span class="line">    user     : <span class="string">'root'</span>,</span><br><span class="line">    password : <span class="string">'jkp66902'</span>,</span><br><span class="line">    database : <span class="string">'graphql'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li>这里有个坑需要修改身份认证方式否则连接不上<ul>
<li>ALTER USER ‘root’@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘jkp66902’;</li>
</ul>
</li>
</ul>
<p><img src="./08.png" alt="查询条件"><br><img src="./09.png" alt="查询条件"></p>
<h3 id="创建数据"><a href="#创建数据" class="headerlink" title="创建数据"></a>创建数据</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">createAccount(&#123;input&#125;) &#123;</span><br><span class="line">    <span class="keyword">const</span> data = &#123;</span><br><span class="line">        name:input.name,</span><br><span class="line">        sex:input.sex,</span><br><span class="line">        age:input.age,</span><br><span class="line">        department:input.department</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        pool.query(<span class="string">`insert into account set ?`</span>,data,(err) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"出错了"</span>+err.message);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>mutation{<br>    createAccount(input:{<br>      name:”linjiad”,<br>      age:18,<br>      sex:”男”,<br>      department:”程序员”<br>    }){<br>      name<br>    }<br>  }</p>
</blockquote>
<p><img src="./10.png" alt="查询条件"><br><img src="./11.png" alt="查询条件"></p>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">account() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            pool.query(<span class="string">`select name,age,sex,department from account`</span>,(err,results) =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">"出错了"</span>+err.message);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">const</span> arr = [];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;results.length;i++)&#123;</span><br><span class="line">                    arr.push(&#123;</span><br><span class="line">                        name:results[i].name,</span><br><span class="line">                        sex:results[i].sex,</span><br><span class="line">                        age:results[i].age,</span><br><span class="line">                        department:results[i].department,</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">                resolve(arr);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<blockquote>
<p>query{<br>    account{<br>      name<br>      age<br>      sex<br>      department<br>    }<br>  }</p>
</blockquote>
<p><img src="./12.png" alt="查询条件"></p>
<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">updateAccount(&#123;id, input&#125;) &#123;</span><br><span class="line">        <span class="keyword">const</span> data = input</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            pool.query(<span class="string">`update account set ? where id = ?`</span>,[data , id],(err,results) =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">"出错了"</span>+err.message);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                resolve(results.message);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>mutation{<br>    updateAccount(id:2,input:{<br>      age:21<br>    })<br>  }</p>
</blockquote>
<p><img src="./13.png" alt="查询条件"><br><img src="./14.png" alt="查询条件"></p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">deleteAccount(&#123;id&#125;)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(id);</span><br><span class="line">            pool.query(<span class="string">`DELETE FROM account WHERE id = ?`</span>,[id],(err,results) =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">"出错了"</span>+err.message);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                resolve(results.message);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>mutation{<br>    deleteAccount(id:3)<br>  }</p>
</blockquote>
<p><img src="./15.png" alt="查询条件"></p>
]]></content>
  </entry>
</search>
